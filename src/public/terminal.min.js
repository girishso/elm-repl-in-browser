/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	window.Terminal = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * xterm.js: xterm, in the browser
	 * Originally forked from (with the author's permission):
	 *   Fabrice Bellard's javascript vt100 for jslinux:
	 *   http://bellard.org/jslinux/
	 *   Copyright (c) 2011 Fabrice Bellard
	 *   The original design remains. The terminal itself
	 *   has been extended to include xterm CSI codes, among
	 *   other features.
	 * @license MIT
	 */
	"use strict";
	var CompositionHelper_js_1 = __webpack_require__(2);
	var EventEmitter_js_1 = __webpack_require__(3);
	var Viewport_js_1 = __webpack_require__(4);
	var Clipboard_js_1 = __webpack_require__(5);
	var Browser = __webpack_require__(6);
	/**
	 * Terminal Emulation References:
	 *   http://vt100.net/
	 *   http://invisible-island.net/xterm/ctlseqs/ctlseqs.txt
	 *   http://invisible-island.net/xterm/ctlseqs/ctlseqs.html
	 *   http://invisible-island.net/vttest/
	 *   http://www.inwap.com/pdp10/ansicode.txt
	 *   http://linux.die.net/man/4/console_codes
	 *   http://linux.die.net/man/7/urxvt
	 */
	// Let it work inside Node.js for automated testing purposes.
	var document = (typeof window != 'undefined') ? window.document : null;
	/**
	 * States
	 */
	var normal = 0, escaped = 1, csi = 2, osc = 3, charset = 4, dcs = 5, ignore = 6;
	/**
	 * Terminal
	 */
	/**
	 * Creates a new `Terminal` object.
	 *
	 * @param {object} options An object containing a set of options, the available options are:
	 *   - `cursorBlink` (boolean): Whether the terminal cursor blinks
	 *   - `cols` (number): The number of columns of the terminal (horizontal size)
	 *   - `rows` (number): The number of rows of the terminal (vertical size)
	 *
	 * @public
	 * @class Xterm Xterm
	 * @alias module:xterm/src/xterm
	 */
	function Terminal(options) {
	    var self = this;
	    if (!(this instanceof Terminal)) {
	        return new Terminal(arguments[0], arguments[1], arguments[2]);
	    }
	    self.browser = Browser;
	    self.cancel = Terminal.cancel;
	    EventEmitter_js_1.EventEmitter.call(this);
	    if (typeof options === 'number') {
	        options = {
	            cols: arguments[0],
	            rows: arguments[1],
	            handler: arguments[2]
	        };
	    }
	    options = options || {};
	    Object.keys(Terminal.defaults).forEach(function (key) {
	        if (options[key] == null) {
	            options[key] = Terminal.options[key];
	            if (Terminal[key] !== Terminal.defaults[key]) {
	                options[key] = Terminal[key];
	            }
	        }
	        self[key] = options[key];
	    });
	    if (options.colors.length === 8) {
	        options.colors = options.colors.concat(Terminal._colors.slice(8));
	    }
	    else if (options.colors.length === 16) {
	        options.colors = options.colors.concat(Terminal._colors.slice(16));
	    }
	    else if (options.colors.length === 10) {
	        options.colors = options.colors.slice(0, -2).concat(Terminal._colors.slice(8, -2), options.colors.slice(-2));
	    }
	    else if (options.colors.length === 18) {
	        options.colors = options.colors.concat(Terminal._colors.slice(16, -2), options.colors.slice(-2));
	    }
	    this.colors = options.colors;
	    this.options = options;
	    // this.context = options.context || window;
	    // this.document = options.document || document;
	    this.parent = options.body || options.parent || (document ? document.getElementsByTagName('body')[0] : null);
	    this.cols = options.cols || options.geometry[0];
	    this.rows = options.rows || options.geometry[1];
	    this.geometry = [this.cols, this.rows];
	    if (options.handler) {
	        this.on('data', options.handler);
	    }
	    /**
	     * The scroll position of the y cursor, ie. ybase + y = the y position within the entire
	     * buffer
	     */
	    this.ybase = 0;
	    /**
	     * The scroll position of the viewport
	     */
	    this.ydisp = 0;
	    /**
	     * The cursor's x position after ybase
	     */
	    this.x = 0;
	    /**
	     * The cursor's y position after ybase
	     */
	    this.y = 0;
	    /**
	     * Used to debounce the refresh function
	     */
	    this.isRefreshing = false;
	    /**
	     * Whether there is a full terminal refresh queued
	     */
	    this.cursorState = 0;
	    this.cursorHidden = false;
	    this.convertEol;
	    this.state = 0;
	    this.queue = '';
	    this.scrollTop = 0;
	    this.scrollBottom = this.rows - 1;
	    this.customKeydownHandler = null;
	    // modes
	    this.applicationKeypad = false;
	    this.applicationCursor = false;
	    this.originMode = false;
	    this.insertMode = false;
	    this.wraparoundMode = true; // defaults: xterm - true, vt100 - false
	    this.normal = null;
	    // charset
	    this.charset = null;
	    this.gcharset = null;
	    this.glevel = 0;
	    this.charsets = [null];
	    // mouse properties
	    this.decLocator;
	    this.x10Mouse;
	    this.vt200Mouse;
	    this.vt300Mouse;
	    this.normalMouse;
	    this.mouseEvents;
	    this.sendFocus;
	    this.utfMouse;
	    this.sgrMouse;
	    this.urxvtMouse;
	    // misc
	    this.element;
	    this.children;
	    this.refreshStart;
	    this.refreshEnd;
	    this.savedX;
	    this.savedY;
	    this.savedCols;
	    // stream
	    this.readable = true;
	    this.writable = true;
	    this.defAttr = (0 << 18) | (257 << 9) | (256 << 0);
	    this.curAttr = this.defAttr;
	    this.params = [];
	    this.currentParam = 0;
	    this.prefix = '';
	    this.postfix = '';
	    // leftover surrogate high from previous write invocation
	    this.surrogate_high = '';
	    /**
	     * An array of all lines in the entire buffer, including the prompt. The lines are array of
	     * characters which are 2-length arrays where [0] is an attribute and [1] is the character.
	     */
	    this.lines = [];
	    var i = this.rows;
	    while (i--) {
	        this.lines.push(this.blankLine());
	    }
	    this.tabs;
	    this.setupStops();
	    // Store if user went browsing history in scrollback
	    this.userScrolling = false;
	}
	inherits(Terminal, EventEmitter_js_1.EventEmitter);
	/**
	 * back_color_erase feature for xterm.
	 */
	Terminal.prototype.eraseAttr = function () {
	    // if (this.is('screen')) return this.defAttr;
	    return (this.defAttr & ~0x1ff) | (this.curAttr & 0x1ff);
	};
	/**
	 * Colors
	 */
	// Colors 0-15
	Terminal.tangoColors = [
	    // dark:
	    '#2e3436',
	    '#cc0000',
	    '#4e9a06',
	    '#c4a000',
	    '#3465a4',
	    '#75507b',
	    '#06989a',
	    '#d3d7cf',
	    // bright:
	    '#555753',
	    '#ef2929',
	    '#8ae234',
	    '#fce94f',
	    '#729fcf',
	    '#ad7fa8',
	    '#34e2e2',
	    '#eeeeec'
	];
	// Colors 0-15 + 16-255
	// Much thanks to TooTallNate for writing this.
	Terminal.colors = (function () {
	    var colors = Terminal.tangoColors.slice(), r = [0x00, 0x5f, 0x87, 0xaf, 0xd7, 0xff], i;
	    // 16-231
	    i = 0;
	    for (; i < 216; i++) {
	        out(r[(i / 36) % 6 | 0], r[(i / 6) % 6 | 0], r[i % 6]);
	    }
	    // 232-255 (grey)
	    i = 0;
	    for (; i < 24; i++) {
	        r = 8 + i * 10;
	        out(r, r, r);
	    }
	    function out(r, g, b) {
	        colors.push('#' + hex(r) + hex(g) + hex(b));
	    }
	    function hex(c) {
	        c = c.toString(16);
	        return c.length < 2 ? '0' + c : c;
	    }
	    return colors;
	})();
	Terminal._colors = Terminal.colors.slice();
	Terminal.vcolors = (function () {
	    var out = [], colors = Terminal.colors, i = 0, color;
	    for (; i < 256; i++) {
	        color = parseInt(colors[i].substring(1), 16);
	        out.push([
	            (color >> 16) & 0xff,
	            (color >> 8) & 0xff,
	            color & 0xff
	        ]);
	    }
	    return out;
	})();
	/**
	 * Options
	 */
	Terminal.defaults = {
	    colors: Terminal.colors,
	    theme: 'default',
	    convertEol: false,
	    termName: 'xterm',
	    geometry: [80, 24],
	    cursorBlink: false,
	    visualBell: false,
	    popOnBell: false,
	    scrollback: 1000,
	    screenKeys: false,
	    debug: false,
	    cancelEvents: false
	};
	Terminal.options = {};
	Terminal.focus = null;
	each(keys(Terminal.defaults), function (key) {
	    Terminal[key] = Terminal.defaults[key];
	    Terminal.options[key] = Terminal.defaults[key];
	});
	/**
	 * Focus the terminal. Delegates focus handling to the terminal's DOM element.
	 */
	Terminal.prototype.focus = function () {
	    return this.textarea.focus();
	};
	/**
	 * Retrieves an option's value from the terminal.
	 * @param {string} key The option key.
	 */
	Terminal.prototype.getOption = function (key, value) {
	    if (!(key in Terminal.defaults)) {
	        throw new Error('No option with key "' + key + '"');
	    }
	    if (typeof this.options[key] !== 'undefined') {
	        return this.options[key];
	    }
	    return this[key];
	};
	/**
	 * Sets an option on the terminal.
	 * @param {string} key The option key.
	 * @param {string} value The option value.
	 */
	Terminal.prototype.setOption = function (key, value) {
	    if (!(key in Terminal.defaults)) {
	        throw new Error('No option with key "' + key + '"');
	    }
	    this[key] = value;
	    this.options[key] = value;
	};
	/**
	 * Binds the desired focus behavior on a given terminal object.
	 *
	 * @static
	 */
	Terminal.bindFocus = function (term) {
	    on(term.textarea, 'focus', function (ev) {
	        if (term.sendFocus) {
	            term.send('\x1b[I');
	        }
	        term.element.classList.add('focus');
	        term.showCursor();
	        Terminal.focus = term;
	        term.emit('focus', { terminal: term });
	    });
	};
	/**
	 * Blur the terminal. Delegates blur handling to the terminal's DOM element.
	 */
	Terminal.prototype.blur = function () {
	    return this.textarea.blur();
	};
	/**
	 * Binds the desired blur behavior on a given terminal object.
	 *
	 * @static
	 */
	Terminal.bindBlur = function (term) {
	    on(term.textarea, 'blur', function (ev) {
	        term.refresh(term.y, term.y);
	        if (term.sendFocus) {
	            term.send('\x1b[O');
	        }
	        term.element.classList.remove('focus');
	        Terminal.focus = null;
	        term.emit('blur', { terminal: term });
	    });
	};
	/**
	 * Initialize default behavior
	 */
	Terminal.prototype.initGlobal = function () {
	    var term = this;
	    Terminal.bindKeys(this);
	    Terminal.bindFocus(this);
	    Terminal.bindBlur(this);
	    // Bind clipboard functionality
	    on(this.element, 'copy', function (ev) {
	        Clipboard_js_1.copyHandler.call(this, ev, term);
	    });
	    on(this.textarea, 'paste', function (ev) {
	        Clipboard_js_1.pasteHandler.call(this, ev, term);
	    });
	    on(this.element, 'paste', function (ev) {
	        Clipboard_js_1.pasteHandler.call(this, ev, term);
	    });
	    function rightClickHandlerWrapper(ev) {
	        Clipboard_js_1.rightClickHandler.call(this, ev, term);
	    }
	    if (term.browser.isFirefox) {
	        on(this.element, 'mousedown', function (ev) {
	            if (ev.button == 2) {
	                rightClickHandlerWrapper(ev);
	            }
	        });
	    }
	    else {
	        on(this.element, 'contextmenu', rightClickHandlerWrapper);
	    }
	};
	/**
	 * Apply key handling to the terminal
	 */
	Terminal.bindKeys = function (term) {
	    on(term.element, 'keydown', function (ev) {
	        if (document.activeElement != this) {
	            return;
	        }
	        term.keyDown(ev);
	    }, true);
	    on(term.element, 'keypress', function (ev) {
	        if (document.activeElement != this) {
	            return;
	        }
	        term.keyPress(ev);
	    }, true);
	    on(term.element, 'keyup', term.focus.bind(term));
	    on(term.textarea, 'keydown', function (ev) {
	        term.keyDown(ev);
	    }, true);
	    on(term.textarea, 'keypress', function (ev) {
	        term.keyPress(ev);
	        // Truncate the textarea's value, since it is not needed
	        this.value = '';
	    }, true);
	    on(term.textarea, 'compositionstart', term.compositionHelper.compositionstart.bind(term.compositionHelper));
	    on(term.textarea, 'compositionupdate', term.compositionHelper.compositionupdate.bind(term.compositionHelper));
	    on(term.textarea, 'compositionend', term.compositionHelper.compositionend.bind(term.compositionHelper));
	    term.on('refresh', term.compositionHelper.updateCompositionElements.bind(term.compositionHelper));
	};
	/**
	 * Insert the given row to the terminal or produce a new one
	 * if no row argument is passed. Return the inserted row.
	 * @param {HTMLElement} row (optional) The row to append to the terminal.
	 */
	Terminal.prototype.insertRow = function (row) {
	    if (typeof row != 'object') {
	        row = document.createElement('div');
	    }
	    this.rowContainer.appendChild(row);
	    this.children.push(row);
	    return row;
	};
	/**
	 * Opens the terminal within an element.
	 *
	 * @param {HTMLElement} parent The element to create the terminal within.
	 */
	Terminal.prototype.open = function (parent) {
	    var self = this, i = 0, div;
	    this.parent = parent || this.parent;
	    if (!this.parent) {
	        throw new Error('Terminal requires a parent element.');
	    }
	    // Grab global elements
	    this.context = this.parent.ownerDocument.defaultView;
	    this.document = this.parent.ownerDocument;
	    this.body = this.document.getElementsByTagName('body')[0];
	    //Create main element container
	    this.element = this.document.createElement('div');
	    this.element.classList.add('terminal');
	    this.element.classList.add('xterm');
	    this.element.classList.add('xterm-theme-' + this.theme);
	    this.element.style.height;
	    this.element.setAttribute('tabindex', 0);
	    this.viewportElement = document.createElement('div');
	    this.viewportElement.classList.add('xterm-viewport');
	    this.element.appendChild(this.viewportElement);
	    this.viewportScrollArea = document.createElement('div');
	    this.viewportScrollArea.classList.add('xterm-scroll-area');
	    this.viewportElement.appendChild(this.viewportScrollArea);
	    // Create the container that will hold the lines of the terminal and then
	    // produce the lines the lines.
	    this.rowContainer = document.createElement('div');
	    this.rowContainer.classList.add('xterm-rows');
	    this.element.appendChild(this.rowContainer);
	    this.children = [];
	    // Create the container that will hold helpers like the textarea for
	    // capturing DOM Events. Then produce the helpers.
	    this.helperContainer = document.createElement('div');
	    this.helperContainer.classList.add('xterm-helpers');
	    // TODO: This should probably be inserted once it's filled to prevent an additional layout
	    this.element.appendChild(this.helperContainer);
	    this.textarea = document.createElement('textarea');
	    this.textarea.classList.add('xterm-helper-textarea');
	    this.textarea.setAttribute('autocorrect', 'off');
	    this.textarea.setAttribute('autocapitalize', 'off');
	    this.textarea.setAttribute('spellcheck', 'false');
	    this.textarea.tabIndex = 0;
	    this.textarea.addEventListener('focus', function () {
	        self.emit('focus', { terminal: self });
	    });
	    this.textarea.addEventListener('blur', function () {
	        self.emit('blur', { terminal: self });
	    });
	    this.helperContainer.appendChild(this.textarea);
	    this.compositionView = document.createElement('div');
	    this.compositionView.classList.add('composition-view');
	    this.compositionHelper = new CompositionHelper_js_1.CompositionHelper(this.textarea, this.compositionView, this);
	    this.helperContainer.appendChild(this.compositionView);
	    this.charMeasureElement = document.createElement('div');
	    this.charMeasureElement.classList.add('xterm-char-measure-element');
	    this.charMeasureElement.innerHTML = 'W';
	    this.helperContainer.appendChild(this.charMeasureElement);
	    for (; i < this.rows; i++) {
	        this.insertRow();
	    }
	    this.parent.appendChild(this.element);
	    this.viewport = new Viewport_js_1.Viewport(this, this.viewportElement, this.viewportScrollArea, this.charMeasureElement);
	    // Draw the screen.
	    this.refresh(0, this.rows - 1);
	    // Initialize global actions that
	    // need to be taken on the document.
	    this.initGlobal();
	    // Ensure there is a Terminal.focus.
	    this.focus();
	    on(this.element, 'click', function () {
	        var selection = document.getSelection(), collapsed = selection.isCollapsed, isRange = typeof collapsed == 'boolean' ? !collapsed : selection.type == 'Range';
	        if (!isRange) {
	            self.focus();
	        }
	    });
	    // Listen for mouse events and translate
	    // them into terminal mouse protocols.
	    this.bindMouse();
	    // Figure out whether boldness affects
	    // the character width of monospace fonts.
	    if (Terminal.brokenBold == null) {
	        Terminal.brokenBold = isBoldBroken(this.document);
	    }
	    /**
	     * This event is emitted when terminal has completed opening.
	     *
	     * @event open
	     */
	    this.emit('open');
	};
	/**
	 * Attempts to load an add-on using CommonJS or RequireJS (whichever is available).
	 * @param {string} addon The name of the addon to load
	 * @static
	 */
	Terminal.loadAddon = function (addon, callback) {
	    if (true) {
	        // CommonJS
	        return __webpack_require__(8)("./" + addon + '/' + addon);
	    }
	    else if (typeof define == 'function') {
	        // RequireJS
	        return require(['./addons/' + addon + '/' + addon], callback);
	    }
	    else {
	        console.error('Cannot load a module without a CommonJS or RequireJS environment.');
	        return false;
	    }
	};
	/**
	 * XTerm mouse events
	 * http://invisible-island.net/xterm/ctlseqs/ctlseqs.html#Mouse%20Tracking
	 * To better understand these
	 * the xterm code is very helpful:
	 * Relevant files:
	 *   button.c, charproc.c, misc.c
	 * Relevant functions in xterm/button.c:
	 *   BtnCode, EmitButtonCode, EditorButton, SendMousePosition
	 */
	Terminal.prototype.bindMouse = function () {
	    var el = this.element, self = this, pressed = 32;
	    // mouseup, mousedown, wheel
	    // left click: ^[[M 3<^[[M#3<
	    // wheel up: ^[[M`3>
	    function sendButton(ev) {
	        var button, pos;
	        // get the xterm-style button
	        button = getButton(ev);
	        // get mouse coordinates
	        pos = getCoords(ev);
	        if (!pos)
	            return;
	        sendEvent(button, pos);
	        switch (ev.overrideType || ev.type) {
	            case 'mousedown':
	                pressed = button;
	                break;
	            case 'mouseup':
	                // keep it at the left
	                // button, just in case.
	                pressed = 32;
	                break;
	            case 'wheel':
	                // nothing. don't
	                // interfere with
	                // `pressed`.
	                break;
	        }
	    }
	    // motion example of a left click:
	    // ^[[M 3<^[[M@4<^[[M@5<^[[M@6<^[[M@7<^[[M#7<
	    function sendMove(ev) {
	        var button = pressed, pos;
	        pos = getCoords(ev);
	        if (!pos)
	            return;
	        // buttons marked as motions
	        // are incremented by 32
	        button += 32;
	        sendEvent(button, pos);
	    }
	    // encode button and
	    // position to characters
	    function encode(data, ch) {
	        if (!self.utfMouse) {
	            if (ch === 255)
	                return data.push(0);
	            if (ch > 127)
	                ch = 127;
	            data.push(ch);
	        }
	        else {
	            if (ch === 2047)
	                return data.push(0);
	            if (ch < 127) {
	                data.push(ch);
	            }
	            else {
	                if (ch > 2047)
	                    ch = 2047;
	                data.push(0xC0 | (ch >> 6));
	                data.push(0x80 | (ch & 0x3F));
	            }
	        }
	    }
	    // send a mouse event:
	    // regular/utf8: ^[[M Cb Cx Cy
	    // urxvt: ^[[ Cb ; Cx ; Cy M
	    // sgr: ^[[ Cb ; Cx ; Cy M/m
	    // vt300: ^[[ 24(1/3/5)~ [ Cx , Cy ] \r
	    // locator: CSI P e ; P b ; P r ; P c ; P p & w
	    function sendEvent(button, pos) {
	        // self.emit('mouse', {
	        //   x: pos.x - 32,
	        //   y: pos.x - 32,
	        //   button: button
	        // });
	        if (self.vt300Mouse) {
	            // NOTE: Unstable.
	            // http://www.vt100.net/docs/vt3xx-gp/chapter15.html
	            button &= 3;
	            pos.x -= 32;
	            pos.y -= 32;
	            var data = '\x1b[24';
	            if (button === 0)
	                data += '1';
	            else if (button === 1)
	                data += '3';
	            else if (button === 2)
	                data += '5';
	            else if (button === 3)
	                return;
	            else
	                data += '0';
	            data += '~[' + pos.x + ',' + pos.y + ']\r';
	            self.send(data);
	            return;
	        }
	        if (self.decLocator) {
	            // NOTE: Unstable.
	            button &= 3;
	            pos.x -= 32;
	            pos.y -= 32;
	            if (button === 0)
	                button = 2;
	            else if (button === 1)
	                button = 4;
	            else if (button === 2)
	                button = 6;
	            else if (button === 3)
	                button = 3;
	            self.send('\x1b['
	                + button
	                + ';'
	                + (button === 3 ? 4 : 0)
	                + ';'
	                + pos.y
	                + ';'
	                + pos.x
	                + ';'
	                + (pos.page || 0)
	                + '&w');
	            return;
	        }
	        if (self.urxvtMouse) {
	            pos.x -= 32;
	            pos.y -= 32;
	            pos.x++;
	            pos.y++;
	            self.send('\x1b[' + button + ';' + pos.x + ';' + pos.y + 'M');
	            return;
	        }
	        if (self.sgrMouse) {
	            pos.x -= 32;
	            pos.y -= 32;
	            self.send('\x1b[<'
	                + (((button & 3) === 3 ? button & ~3 : button) - 32)
	                + ';'
	                + pos.x
	                + ';'
	                + pos.y
	                + ((button & 3) === 3 ? 'm' : 'M'));
	            return;
	        }
	        var data = [];
	        encode(data, button);
	        encode(data, pos.x);
	        encode(data, pos.y);
	        self.send('\x1b[M' + String.fromCharCode.apply(String, data));
	    }
	    function getButton(ev) {
	        var button, shift, meta, ctrl, mod;
	        // two low bits:
	        // 0 = left
	        // 1 = middle
	        // 2 = right
	        // 3 = release
	        // wheel up/down:
	        // 1, and 2 - with 64 added
	        switch (ev.overrideType || ev.type) {
	            case 'mousedown':
	                button = ev.button != null
	                    ? +ev.button
	                    : ev.which != null
	                        ? ev.which - 1
	                        : null;
	                if (self.browser.isMSIE) {
	                    button = button === 1 ? 0 : button === 4 ? 1 : button;
	                }
	                break;
	            case 'mouseup':
	                button = 3;
	                break;
	            case 'DOMMouseScroll':
	                button = ev.detail < 0
	                    ? 64
	                    : 65;
	                break;
	            case 'wheel':
	                button = ev.wheelDeltaY > 0
	                    ? 64
	                    : 65;
	                break;
	        }
	        // next three bits are the modifiers:
	        // 4 = shift, 8 = meta, 16 = control
	        shift = ev.shiftKey ? 4 : 0;
	        meta = ev.metaKey ? 8 : 0;
	        ctrl = ev.ctrlKey ? 16 : 0;
	        mod = shift | meta | ctrl;
	        // no mods
	        if (self.vt200Mouse) {
	            // ctrl only
	            mod &= ctrl;
	        }
	        else if (!self.normalMouse) {
	            mod = 0;
	        }
	        // increment to SP
	        button = (32 + (mod << 2)) + button;
	        return button;
	    }
	    // mouse coordinates measured in cols/rows
	    function getCoords(ev) {
	        var x, y, w, h, el;
	        // ignore browsers without pageX for now
	        if (ev.pageX == null)
	            return;
	        x = ev.pageX;
	        y = ev.pageY;
	        el = self.element;
	        // should probably check offsetParent
	        // but this is more portable
	        while (el && el !== self.document.documentElement) {
	            x -= el.offsetLeft;
	            y -= el.offsetTop;
	            el = 'offsetParent' in el
	                ? el.offsetParent
	                : el.parentNode;
	        }
	        // convert to cols/rows
	        w = self.element.clientWidth;
	        h = self.element.clientHeight;
	        x = Math.ceil((x / w) * self.cols);
	        y = Math.ceil((y / h) * self.rows);
	        // be sure to avoid sending
	        // bad positions to the program
	        if (x < 0)
	            x = 0;
	        if (x > self.cols)
	            x = self.cols;
	        if (y < 0)
	            y = 0;
	        if (y > self.rows)
	            y = self.rows;
	        // xterm sends raw bytes and
	        // starts at 32 (SP) for each.
	        x += 32;
	        y += 32;
	        return {
	            x: x,
	            y: y,
	            type: 'wheel'
	        };
	    }
	    on(el, 'mousedown', function (ev) {
	        if (!self.mouseEvents)
	            return;
	        // send the button
	        sendButton(ev);
	        // ensure focus
	        self.focus();
	        // fix for odd bug
	        //if (self.vt200Mouse && !self.normalMouse) {
	        if (self.vt200Mouse) {
	            ev.overrideType = 'mouseup';
	            sendButton(ev);
	            return self.cancel(ev);
	        }
	        // bind events
	        if (self.normalMouse)
	            on(self.document, 'mousemove', sendMove);
	        // x10 compatibility mode can't send button releases
	        if (!self.x10Mouse) {
	            on(self.document, 'mouseup', function up(ev) {
	                sendButton(ev);
	                if (self.normalMouse)
	                    off(self.document, 'mousemove', sendMove);
	                off(self.document, 'mouseup', up);
	                return self.cancel(ev);
	            });
	        }
	        return self.cancel(ev);
	    });
	    //if (self.normalMouse) {
	    //  on(self.document, 'mousemove', sendMove);
	    //}
	    on(el, 'wheel', function (ev) {
	        if (!self.mouseEvents)
	            return;
	        if (self.x10Mouse
	            || self.vt300Mouse
	            || self.decLocator)
	            return;
	        sendButton(ev);
	        return self.cancel(ev);
	    });
	    // allow wheel scrolling in
	    // the shell for example
	    on(el, 'wheel', function (ev) {
	        if (self.mouseEvents)
	            return;
	        self.viewport.onWheel(ev);
	        return self.cancel(ev);
	    });
	};
	/**
	 * Destroys the terminal.
	 */
	Terminal.prototype.destroy = function () {
	    this.readable = false;
	    this.writable = false;
	    this._events = {};
	    this.handler = function () { };
	    this.write = function () { };
	    if (this.element.parentNode) {
	        this.element.parentNode.removeChild(this.element);
	    }
	    //this.emit('close');
	};
	/**
	 * Flags used to render terminal text properly
	 */
	Terminal.flags = {
	    BOLD: 1,
	    UNDERLINE: 2,
	    BLINK: 4,
	    INVERSE: 8,
	    INVISIBLE: 16
	};
	/**
	 * Refreshes (re-renders) terminal content within two rows (inclusive)
	 *
	 * Rendering Engine:
	 *
	 * In the screen buffer, each character is stored as a an array with a character
	 * and a 32-bit integer:
	 *   - First value: a utf-16 character.
	 *   - Second value:
	 *   - Next 9 bits: background color (0-511).
	 *   - Next 9 bits: foreground color (0-511).
	 *   - Next 14 bits: a mask for misc. flags:
	 *     - 1=bold
	 *     - 2=underline
	 *     - 4=blink
	 *     - 8=inverse
	 *     - 16=invisible
	 *
	 * @param {number} start The row to start from (between 0 and terminal's height terminal - 1)
	 * @param {number} end The row to end at (between fromRow and terminal's height terminal - 1)
	 * @param {boolean} queue Whether the refresh should ran right now or be queued
	 */
	Terminal.prototype.refresh = function (start, end, queue) {
	    var self = this;
	    // queue defaults to true
	    queue = (typeof queue == 'undefined') ? true : queue;
	    /**
	     * The refresh queue allows refresh to execute only approximately 30 times a second. For
	     * commands that pass a significant amount of output to the write function, this prevents the
	     * terminal from maxing out the CPU and making the UI unresponsive. While commands can still
	     * run beyond what they do on the terminal, it is far better with a debounce in place as
	     * every single terminal manipulation does not need to be constructed in the DOM.
	     *
	     * A side-effect of this is that it makes ^C to interrupt a process seem more responsive.
	     */
	    if (queue) {
	        // If refresh should be queued, order the refresh and return.
	        if (this._refreshIsQueued) {
	            // If a refresh has already been queued, just order a full refresh next
	            this._fullRefreshNext = true;
	        }
	        else {
	            setTimeout(function () {
	                self.refresh(start, end, false);
	            }, 34);
	            this._refreshIsQueued = true;
	        }
	        return;
	    }
	    // If refresh should be run right now (not be queued), release the lock
	    this._refreshIsQueued = false;
	    // If multiple refreshes were requested, make a full refresh.
	    if (this._fullRefreshNext) {
	        start = 0;
	        end = this.rows - 1;
	        this._fullRefreshNext = false; // reset lock
	    }
	    var x, y, i, line, out, ch, ch_width, width, data, attr, bg, fg, flags, row, parent, focused = document.activeElement;
	    // If this is a big refresh, remove the terminal rows from the DOM for faster calculations
	    if (end - start >= this.rows / 2) {
	        parent = this.element.parentNode;
	        if (parent) {
	            this.element.removeChild(this.rowContainer);
	        }
	    }
	    width = this.cols;
	    y = start;
	    if (end >= this.rows.length) {
	        this.log('`end` is too large. Most likely a bad CSR.');
	        end = this.rows.length - 1;
	    }
	    for (; y <= end; y++) {
	        row = y + this.ydisp;
	        line = this.lines[row];
	        out = '';
	        if (this.y === y - (this.ybase - this.ydisp)
	            && this.cursorState
	            && !this.cursorHidden) {
	            x = this.x;
	        }
	        else {
	            x = -1;
	        }
	        attr = this.defAttr;
	        i = 0;
	        for (; i < width; i++) {
	            data = line[i][0];
	            ch = line[i][1];
	            ch_width = line[i][2];
	            if (!ch_width)
	                continue;
	            if (i === x)
	                data = -1;
	            if (data !== attr) {
	                if (attr !== this.defAttr) {
	                    out += '</span>';
	                }
	                if (data !== this.defAttr) {
	                    if (data === -1) {
	                        out += '<span class="reverse-video terminal-cursor';
	                        if (this.cursorBlink) {
	                            out += ' blinking';
	                        }
	                        out += '">';
	                    }
	                    else {
	                        var classNames = [];
	                        bg = data & 0x1ff;
	                        fg = (data >> 9) & 0x1ff;
	                        flags = data >> 18;
	                        if (flags & Terminal.flags.BOLD) {
	                            if (!Terminal.brokenBold) {
	                                classNames.push('xterm-bold');
	                            }
	                            // See: XTerm*boldColors
	                            if (fg < 8)
	                                fg += 8;
	                        }
	                        if (flags & Terminal.flags.UNDERLINE) {
	                            classNames.push('xterm-underline');
	                        }
	                        if (flags & Terminal.flags.BLINK) {
	                            classNames.push('xterm-blink');
	                        }
	                        // If inverse flag is on, then swap the foreground and background variables.
	                        if (flags & Terminal.flags.INVERSE) {
	                            /* One-line variable swap in JavaScript: http://stackoverflow.com/a/16201730 */
	                            bg = [fg, fg = bg][0];
	                            // Should inverse just be before the
	                            // above boldColors effect instead?
	                            if ((flags & 1) && fg < 8)
	                                fg += 8;
	                        }
	                        if (flags & Terminal.flags.INVISIBLE) {
	                            classNames.push('xterm-hidden');
	                        }
	                        /**
	                         * Weird situation: Invert flag used black foreground and white background results
	                         * in invalid background color, positioned at the 256 index of the 256 terminal
	                         * color map. Pin the colors manually in such a case.
	                         *
	                         * Source: https://github.com/sourcelair/xterm.js/issues/57
	                         */
	                        if (flags & Terminal.flags.INVERSE) {
	                            if (bg == 257) {
	                                bg = 15;
	                            }
	                            if (fg == 256) {
	                                fg = 0;
	                            }
	                        }
	                        if (bg < 256) {
	                            classNames.push('xterm-bg-color-' + bg);
	                        }
	                        if (fg < 256) {
	                            classNames.push('xterm-color-' + fg);
	                        }
	                        out += '<span';
	                        if (classNames.length) {
	                            out += ' class="' + classNames.join(' ') + '"';
	                        }
	                        out += '>';
	                    }
	                }
	            }
	            switch (ch) {
	                case '&':
	                    out += '&amp;';
	                    break;
	                case '<':
	                    out += '&lt;';
	                    break;
	                case '>':
	                    out += '&gt;';
	                    break;
	                default:
	                    if (ch <= ' ') {
	                        out += '&nbsp;';
	                    }
	                    else {
	                        out += ch;
	                    }
	                    break;
	            }
	            attr = data;
	        }
	        if (attr !== this.defAttr) {
	            out += '</span>';
	        }
	        this.children[y].innerHTML = out;
	    }
	    if (parent) {
	        this.element.appendChild(this.rowContainer);
	    }
	    this.emit('refresh', { element: this.element, start: start, end: end });
	};
	/**
	 * Display the cursor element
	 */
	Terminal.prototype.showCursor = function () {
	    if (!this.cursorState) {
	        this.cursorState = 1;
	        this.refresh(this.y, this.y);
	    }
	};
	/**
	 * Scroll the terminal
	 */
	Terminal.prototype.scroll = function () {
	    var row;
	    if (++this.ybase === this.scrollback) {
	        this.ybase = this.ybase / 2 | 0;
	        this.lines = this.lines.slice(-(this.ybase + this.rows) + 1);
	    }
	    if (!this.userScrolling) {
	        this.ydisp = this.ybase;
	    }
	    // last line
	    row = this.ybase + this.rows - 1;
	    // subtract the bottom scroll region
	    row -= this.rows - 1 - this.scrollBottom;
	    if (row === this.lines.length) {
	        // potential optimization:
	        // pushing is faster than splicing
	        // when they amount to the same
	        // behavior.
	        this.lines.push(this.blankLine());
	    }
	    else {
	        // add our new line
	        this.lines.splice(row, 0, this.blankLine());
	    }
	    if (this.scrollTop !== 0) {
	        if (this.ybase !== 0) {
	            this.ybase--;
	            if (!this.userScrolling) {
	                this.ydisp = this.ybase;
	            }
	        }
	        this.lines.splice(this.ybase + this.scrollTop, 1);
	    }
	    // this.maxRange();
	    this.updateRange(this.scrollTop);
	    this.updateRange(this.scrollBottom);
	    /**
	     * This event is emitted whenever the terminal is scrolled.
	     * The one parameter passed is the new y display position.
	     *
	     * @event scroll
	     */
	    this.emit('scroll', this.ydisp);
	};
	/**
	 * Scroll the display of the terminal
	 * @param {number} disp The number of lines to scroll down (negatives scroll up).
	 * @param {boolean} suppressScrollEvent Don't emit the scroll event as scrollDisp. This is used
	 * to avoid unwanted events being handled by the veiwport when the event was triggered from the
	 * viewport originally.
	 */
	Terminal.prototype.scrollDisp = function (disp, suppressScrollEvent) {
	    if (disp < 0) {
	        this.userScrolling = true;
	    }
	    else if (disp + this.ydisp >= this.ybase) {
	        this.userScrolling = false;
	    }
	    this.ydisp += disp;
	    if (this.ydisp > this.ybase) {
	        this.ydisp = this.ybase;
	    }
	    else if (this.ydisp < 0) {
	        this.ydisp = 0;
	    }
	    if (!suppressScrollEvent) {
	        this.emit('scroll', this.ydisp);
	    }
	    this.refresh(0, this.rows - 1);
	};
	/**
	 * Scroll the display of the terminal by a number of pages.
	 * @param {number} pageCount The number of pages to scroll (negative scrolls up).
	 */
	Terminal.prototype.scrollPages = function (pageCount) {
	    this.scrollDisp(pageCount * (this.rows - 1));
	};
	/**
	 * Scrolls the display of the terminal to the top.
	 */
	Terminal.prototype.scrollToTop = function () {
	    this.scrollDisp(-this.ydisp);
	};
	/**
	 * Scrolls the display of the terminal to the bottom.
	 */
	Terminal.prototype.scrollToBottom = function () {
	    this.scrollDisp(this.ybase - this.ydisp);
	};
	/**
	 * Writes text to the terminal.
	 * @param {string} text The text to write to the terminal.
	 */
	Terminal.prototype.write = function (data) {
	    var l = data.length, i = 0, j, cs, ch, code, low, ch_width, row;
	    this.refreshStart = this.y;
	    this.refreshEnd = this.y;
	    // apply leftover surrogate high from last write
	    if (this.surrogate_high) {
	        data = this.surrogate_high + data;
	        this.surrogate_high = '';
	    }
	    for (; i < l; i++) {
	        ch = data[i];
	        // FIXME: higher chars than 0xa0 are not allowed in escape sequences
	        //        --> maybe move to default
	        code = data.charCodeAt(i);
	        if (0xD800 <= code && code <= 0xDBFF) {
	            // we got a surrogate high
	            // get surrogate low (next 2 bytes)
	            low = data.charCodeAt(i + 1);
	            if (isNaN(low)) {
	                // end of data stream, save surrogate high
	                this.surrogate_high = ch;
	                continue;
	            }
	            code = ((code - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000;
	            ch += data.charAt(i + 1);
	        }
	        // surrogate low - already handled above
	        if (0xDC00 <= code && code <= 0xDFFF)
	            continue;
	        switch (this.state) {
	            case normal:
	                switch (ch) {
	                    case '\x07':
	                        this.bell();
	                        break;
	                    // '\n', '\v', '\f'
	                    case '\n':
	                    case '\x0b':
	                    case '\x0c':
	                        if (this.convertEol) {
	                            this.x = 0;
	                        }
	                        this.y++;
	                        if (this.y > this.scrollBottom) {
	                            this.y--;
	                            this.scroll();
	                        }
	                        break;
	                    // '\r'
	                    case '\r':
	                        this.x = 0;
	                        break;
	                    // '\b'
	                    case '\x08':
	                        if (this.x > 0) {
	                            this.x--;
	                        }
	                        break;
	                    // '\t'
	                    case '\t':
	                        this.x = this.nextStop();
	                        break;
	                    // shift out
	                    case '\x0e':
	                        this.setgLevel(1);
	                        break;
	                    // shift in
	                    case '\x0f':
	                        this.setgLevel(0);
	                        break;
	                    // '\e'
	                    case '\x1b':
	                        this.state = escaped;
	                        break;
	                    default:
	                        // ' '
	                        // calculate print space
	                        // expensive call, therefore we save width in line buffer
	                        ch_width = wcwidth(code);
	                        if (ch >= ' ') {
	                            if (this.charset && this.charset[ch]) {
	                                ch = this.charset[ch];
	                            }
	                            row = this.y + this.ybase;
	                            // insert combining char in last cell
	                            // FIXME: needs handling after cursor jumps
	                            if (!ch_width && this.x) {
	                                // dont overflow left
	                                if (this.lines[row][this.x - 1]) {
	                                    if (!this.lines[row][this.x - 1][2]) {
	                                        // found empty cell after fullwidth, need to go 2 cells back
	                                        if (this.lines[row][this.x - 2])
	                                            this.lines[row][this.x - 2][1] += ch;
	                                    }
	                                    else {
	                                        this.lines[row][this.x - 1][1] += ch;
	                                    }
	                                    this.updateRange(this.y);
	                                }
	                                break;
	                            }
	                            // goto next line if ch would overflow
	                            // TODO: needs a global min terminal width of 2
	                            if (this.x + ch_width - 1 >= this.cols) {
	                                // autowrap - DECAWM
	                                if (this.wraparoundMode) {
	                                    this.x = 0;
	                                    this.y++;
	                                    if (this.y > this.scrollBottom) {
	                                        this.y--;
	                                        this.scroll();
	                                    }
	                                }
	                                else {
	                                    this.x = this.cols - 1;
	                                    if (ch_width === 2)
	                                        continue;
	                                }
	                            }
	                            row = this.y + this.ybase;
	                            // insert mode: move characters to right
	                            if (this.insertMode) {
	                                // do this twice for a fullwidth char
	                                for (var moves = 0; moves < ch_width; ++moves) {
	                                    // remove last cell, if it's width is 0
	                                    // we have to adjust the second last cell as well
	                                    var removed = this.lines[this.y + this.ybase].pop();
	                                    if (removed[2] === 0
	                                        && this.lines[row][this.cols - 2]
	                                        && this.lines[row][this.cols - 2][2] === 2)
	                                        this.lines[row][this.cols - 2] = [this.curAttr, ' ', 1];
	                                    // insert empty cell at cursor
	                                    this.lines[row].splice(this.x, 0, [this.curAttr, ' ', 1]);
	                                }
	                            }
	                            this.lines[row][this.x] = [this.curAttr, ch, ch_width];
	                            this.x++;
	                            this.updateRange(this.y);
	                            // fullwidth char - set next cell width to zero and advance cursor
	                            if (ch_width === 2) {
	                                this.lines[row][this.x] = [this.curAttr, '', 0];
	                                this.x++;
	                            }
	                        }
	                        break;
	                }
	                break;
	            case escaped:
	                switch (ch) {
	                    // ESC [ Control Sequence Introducer ( CSI is 0x9b).
	                    case '[':
	                        this.params = [];
	                        this.currentParam = 0;
	                        this.state = csi;
	                        break;
	                    // ESC ] Operating System Command ( OSC is 0x9d).
	                    case ']':
	                        this.params = [];
	                        this.currentParam = 0;
	                        this.state = osc;
	                        break;
	                    // ESC P Device Control String ( DCS is 0x90).
	                    case 'P':
	                        this.params = [];
	                        this.currentParam = 0;
	                        this.state = dcs;
	                        break;
	                    // ESC _ Application Program Command ( APC is 0x9f).
	                    case '_':
	                        this.state = ignore;
	                        break;
	                    // ESC ^ Privacy Message ( PM is 0x9e).
	                    case '^':
	                        this.state = ignore;
	                        break;
	                    // ESC c Full Reset (RIS).
	                    case 'c':
	                        this.reset();
	                        break;
	                    // ESC E Next Line ( NEL is 0x85).
	                    // ESC D Index ( IND is 0x84).
	                    case 'E':
	                        this.x = 0;
	                        ;
	                    case 'D':
	                        this.index();
	                        break;
	                    // ESC M Reverse Index ( RI is 0x8d).
	                    case 'M':
	                        this.reverseIndex();
	                        break;
	                    // ESC % Select default/utf-8 character set.
	                    // @ = default, G = utf-8
	                    case '%':
	                        //this.charset = null;
	                        this.setgLevel(0);
	                        this.setgCharset(0, Terminal.charsets.US);
	                        this.state = normal;
	                        i++;
	                        break;
	                    // ESC (,),*,+,-,. Designate G0-G2 Character Set.
	                    case '(': // <-- this seems to get all the attention
	                    case ')':
	                    case '*':
	                    case '+':
	                    case '-':
	                    case '.':
	                        switch (ch) {
	                            case '(':
	                                this.gcharset = 0;
	                                break;
	                            case ')':
	                                this.gcharset = 1;
	                                break;
	                            case '*':
	                                this.gcharset = 2;
	                                break;
	                            case '+':
	                                this.gcharset = 3;
	                                break;
	                            case '-':
	                                this.gcharset = 1;
	                                break;
	                            case '.':
	                                this.gcharset = 2;
	                                break;
	                        }
	                        this.state = charset;
	                        break;
	                    // Designate G3 Character Set (VT300).
	                    // A = ISO Latin-1 Supplemental.
	                    // Not implemented.
	                    case '/':
	                        this.gcharset = 3;
	                        this.state = charset;
	                        i--;
	                        break;
	                    // ESC N
	                    // Single Shift Select of G2 Character Set
	                    // ( SS2 is 0x8e). This affects next character only.
	                    case 'N':
	                        break;
	                    // ESC O
	                    // Single Shift Select of G3 Character Set
	                    // ( SS3 is 0x8f). This affects next character only.
	                    case 'O':
	                        break;
	                    // ESC n
	                    // Invoke the G2 Character Set as GL (LS2).
	                    case 'n':
	                        this.setgLevel(2);
	                        break;
	                    // ESC o
	                    // Invoke the G3 Character Set as GL (LS3).
	                    case 'o':
	                        this.setgLevel(3);
	                        break;
	                    // ESC |
	                    // Invoke the G3 Character Set as GR (LS3R).
	                    case '|':
	                        this.setgLevel(3);
	                        break;
	                    // ESC }
	                    // Invoke the G2 Character Set as GR (LS2R).
	                    case '}':
	                        this.setgLevel(2);
	                        break;
	                    // ESC ~
	                    // Invoke the G1 Character Set as GR (LS1R).
	                    case '~':
	                        this.setgLevel(1);
	                        break;
	                    // ESC 7 Save Cursor (DECSC).
	                    case '7':
	                        this.saveCursor();
	                        this.state = normal;
	                        break;
	                    // ESC 8 Restore Cursor (DECRC).
	                    case '8':
	                        this.restoreCursor();
	                        this.state = normal;
	                        break;
	                    // ESC # 3 DEC line height/width
	                    case '#':
	                        this.state = normal;
	                        i++;
	                        break;
	                    // ESC H Tab Set (HTS is 0x88).
	                    case 'H':
	                        this.tabSet();
	                        break;
	                    // ESC = Application Keypad (DECKPAM).
	                    case '=':
	                        this.log('Serial port requested application keypad.');
	                        this.applicationKeypad = true;
	                        this.viewport.syncScrollArea();
	                        this.state = normal;
	                        break;
	                    // ESC > Normal Keypad (DECKPNM).
	                    case '>':
	                        this.log('Switching back to normal keypad.');
	                        this.applicationKeypad = false;
	                        this.viewport.syncScrollArea();
	                        this.state = normal;
	                        break;
	                    default:
	                        this.state = normal;
	                        this.error('Unknown ESC control: %s.', ch);
	                        break;
	                }
	                break;
	            case charset:
	                switch (ch) {
	                    case '0':
	                        cs = Terminal.charsets.SCLD;
	                        break;
	                    case 'A':
	                        cs = Terminal.charsets.UK;
	                        break;
	                    case 'B':
	                        cs = Terminal.charsets.US;
	                        break;
	                    case '4':
	                        cs = Terminal.charsets.Dutch;
	                        break;
	                    case 'C': // Finnish
	                    case '5':
	                        cs = Terminal.charsets.Finnish;
	                        break;
	                    case 'R':
	                        cs = Terminal.charsets.French;
	                        break;
	                    case 'Q':
	                        cs = Terminal.charsets.FrenchCanadian;
	                        break;
	                    case 'K':
	                        cs = Terminal.charsets.German;
	                        break;
	                    case 'Y':
	                        cs = Terminal.charsets.Italian;
	                        break;
	                    case 'E': // NorwegianDanish
	                    case '6':
	                        cs = Terminal.charsets.NorwegianDanish;
	                        break;
	                    case 'Z':
	                        cs = Terminal.charsets.Spanish;
	                        break;
	                    case 'H': // Swedish
	                    case '7':
	                        cs = Terminal.charsets.Swedish;
	                        break;
	                    case '=':
	                        cs = Terminal.charsets.Swiss;
	                        break;
	                    case '/':
	                        cs = Terminal.charsets.ISOLatin;
	                        i++;
	                        break;
	                    default:
	                        cs = Terminal.charsets.US;
	                        break;
	                }
	                this.setgCharset(this.gcharset, cs);
	                this.gcharset = null;
	                this.state = normal;
	                break;
	            case osc:
	                // OSC Ps ; Pt ST
	                // OSC Ps ; Pt BEL
	                //   Set Text Parameters.
	                if (ch === '\x1b' || ch === '\x07') {
	                    if (ch === '\x1b')
	                        i++;
	                    this.params.push(this.currentParam);
	                    switch (this.params[0]) {
	                        case 0:
	                        case 1:
	                        case 2:
	                            if (this.params[1]) {
	                                this.title = this.params[1];
	                                this.handleTitle(this.title);
	                            }
	                            break;
	                        case 3:
	                            // set X property
	                            break;
	                        case 4:
	                        case 5:
	                            // change dynamic colors
	                            break;
	                        case 10:
	                        case 11:
	                        case 12:
	                        case 13:
	                        case 14:
	                        case 15:
	                        case 16:
	                        case 17:
	                        case 18:
	                        case 19:
	                            // change dynamic ui colors
	                            break;
	                        case 46:
	                            // change log file
	                            break;
	                        case 50:
	                            // dynamic font
	                            break;
	                        case 51:
	                            // emacs shell
	                            break;
	                        case 52:
	                            // manipulate selection data
	                            break;
	                        case 104:
	                        case 105:
	                        case 110:
	                        case 111:
	                        case 112:
	                        case 113:
	                        case 114:
	                        case 115:
	                        case 116:
	                        case 117:
	                        case 118:
	                            // reset colors
	                            break;
	                    }
	                    this.params = [];
	                    this.currentParam = 0;
	                    this.state = normal;
	                }
	                else {
	                    if (!this.params.length) {
	                        if (ch >= '0' && ch <= '9') {
	                            this.currentParam =
	                                this.currentParam * 10 + ch.charCodeAt(0) - 48;
	                        }
	                        else if (ch === ';') {
	                            this.params.push(this.currentParam);
	                            this.currentParam = '';
	                        }
	                    }
	                    else {
	                        this.currentParam += ch;
	                    }
	                }
	                break;
	            case csi:
	                // '?', '>', '!'
	                if (ch === '?' || ch === '>' || ch === '!') {
	                    this.prefix = ch;
	                    break;
	                }
	                // 0 - 9
	                if (ch >= '0' && ch <= '9') {
	                    this.currentParam = this.currentParam * 10 + ch.charCodeAt(0) - 48;
	                    break;
	                }
	                // '$', '"', ' ', '\''
	                if (ch === '$' || ch === '"' || ch === ' ' || ch === '\'') {
	                    this.postfix = ch;
	                    break;
	                }
	                this.params.push(this.currentParam);
	                this.currentParam = 0;
	                // ';'
	                if (ch === ';')
	                    break;
	                this.state = normal;
	                switch (ch) {
	                    // CSI Ps A
	                    // Cursor Up Ps Times (default = 1) (CUU).
	                    case 'A':
	                        this.cursorUp(this.params);
	                        break;
	                    // CSI Ps B
	                    // Cursor Down Ps Times (default = 1) (CUD).
	                    case 'B':
	                        this.cursorDown(this.params);
	                        break;
	                    // CSI Ps C
	                    // Cursor Forward Ps Times (default = 1) (CUF).
	                    case 'C':
	                        this.cursorForward(this.params);
	                        break;
	                    // CSI Ps D
	                    // Cursor Backward Ps Times (default = 1) (CUB).
	                    case 'D':
	                        this.cursorBackward(this.params);
	                        break;
	                    // CSI Ps ; Ps H
	                    // Cursor Position [row;column] (default = [1,1]) (CUP).
	                    case 'H':
	                        this.cursorPos(this.params);
	                        break;
	                    // CSI Ps J  Erase in Display (ED).
	                    case 'J':
	                        this.eraseInDisplay(this.params);
	                        break;
	                    // CSI Ps K  Erase in Line (EL).
	                    case 'K':
	                        this.eraseInLine(this.params);
	                        break;
	                    // CSI Pm m  Character Attributes (SGR).
	                    case 'm':
	                        if (!this.prefix) {
	                            this.charAttributes(this.params);
	                        }
	                        break;
	                    // CSI Ps n  Device Status Report (DSR).
	                    case 'n':
	                        if (!this.prefix) {
	                            this.deviceStatus(this.params);
	                        }
	                        break;
	                    /**
	                     * Additions
	                     */
	                    // CSI Ps @
	                    // Insert Ps (Blank) Character(s) (default = 1) (ICH).
	                    case '@':
	                        this.insertChars(this.params);
	                        break;
	                    // CSI Ps E
	                    // Cursor Next Line Ps Times (default = 1) (CNL).
	                    case 'E':
	                        this.cursorNextLine(this.params);
	                        break;
	                    // CSI Ps F
	                    // Cursor Preceding Line Ps Times (default = 1) (CNL).
	                    case 'F':
	                        this.cursorPrecedingLine(this.params);
	                        break;
	                    // CSI Ps G
	                    // Cursor Character Absolute  [column] (default = [row,1]) (CHA).
	                    case 'G':
	                        this.cursorCharAbsolute(this.params);
	                        break;
	                    // CSI Ps L
	                    // Insert Ps Line(s) (default = 1) (IL).
	                    case 'L':
	                        this.insertLines(this.params);
	                        break;
	                    // CSI Ps M
	                    // Delete Ps Line(s) (default = 1) (DL).
	                    case 'M':
	                        this.deleteLines(this.params);
	                        break;
	                    // CSI Ps P
	                    // Delete Ps Character(s) (default = 1) (DCH).
	                    case 'P':
	                        this.deleteChars(this.params);
	                        break;
	                    // CSI Ps X
	                    // Erase Ps Character(s) (default = 1) (ECH).
	                    case 'X':
	                        this.eraseChars(this.params);
	                        break;
	                    // CSI Pm `  Character Position Absolute
	                    //   [column] (default = [row,1]) (HPA).
	                    case '`':
	                        this.charPosAbsolute(this.params);
	                        break;
	                    // 141 61 a * HPR -
	                    // Horizontal Position Relative
	                    case 'a':
	                        this.HPositionRelative(this.params);
	                        break;
	                    // CSI P s c
	                    // Send Device Attributes (Primary DA).
	                    // CSI > P s c
	                    // Send Device Attributes (Secondary DA)
	                    case 'c':
	                        this.sendDeviceAttributes(this.params);
	                        break;
	                    // CSI Pm d
	                    // Line Position Absolute  [row] (default = [1,column]) (VPA).
	                    case 'd':
	                        this.linePosAbsolute(this.params);
	                        break;
	                    // 145 65 e * VPR - Vertical Position Relative
	                    case 'e':
	                        this.VPositionRelative(this.params);
	                        break;
	                    // CSI Ps ; Ps f
	                    //   Horizontal and Vertical Position [row;column] (default =
	                    //   [1,1]) (HVP).
	                    case 'f':
	                        this.HVPosition(this.params);
	                        break;
	                    // CSI Pm h  Set Mode (SM).
	                    // CSI ? Pm h - mouse escape codes, cursor escape codes
	                    case 'h':
	                        this.setMode(this.params);
	                        break;
	                    // CSI Pm l  Reset Mode (RM).
	                    // CSI ? Pm l
	                    case 'l':
	                        this.resetMode(this.params);
	                        break;
	                    // CSI Ps ; Ps r
	                    //   Set Scrolling Region [top;bottom] (default = full size of win-
	                    //   dow) (DECSTBM).
	                    // CSI ? Pm r
	                    case 'r':
	                        this.setScrollRegion(this.params);
	                        break;
	                    // CSI s
	                    //   Save cursor (ANSI.SYS).
	                    case 's':
	                        this.saveCursor(this.params);
	                        break;
	                    // CSI u
	                    //   Restore cursor (ANSI.SYS).
	                    case 'u':
	                        this.restoreCursor(this.params);
	                        break;
	                    /**
	                     * Lesser Used
	                     */
	                    // CSI Ps I
	                    // Cursor Forward Tabulation Ps tab stops (default = 1) (CHT).
	                    case 'I':
	                        this.cursorForwardTab(this.params);
	                        break;
	                    // CSI Ps S  Scroll up Ps lines (default = 1) (SU).
	                    case 'S':
	                        this.scrollUp(this.params);
	                        break;
	                    // CSI Ps T  Scroll down Ps lines (default = 1) (SD).
	                    // CSI Ps ; Ps ; Ps ; Ps ; Ps T
	                    // CSI > Ps; Ps T
	                    case 'T':
	                        // if (this.prefix === '>') {
	                        //   this.resetTitleModes(this.params);
	                        //   break;
	                        // }
	                        // if (this.params.length > 2) {
	                        //   this.initMouseTracking(this.params);
	                        //   break;
	                        // }
	                        if (this.params.length < 2 && !this.prefix) {
	                            this.scrollDown(this.params);
	                        }
	                        break;
	                    // CSI Ps Z
	                    // Cursor Backward Tabulation Ps tab stops (default = 1) (CBT).
	                    case 'Z':
	                        this.cursorBackwardTab(this.params);
	                        break;
	                    // CSI Ps b  Repeat the preceding graphic character Ps times (REP).
	                    case 'b':
	                        this.repeatPrecedingCharacter(this.params);
	                        break;
	                    // CSI Ps g  Tab Clear (TBC).
	                    case 'g':
	                        this.tabClear(this.params);
	                        break;
	                    // CSI Pm i  Media Copy (MC).
	                    // CSI ? Pm i
	                    // case 'i':
	                    //   this.mediaCopy(this.params);
	                    //   break;
	                    // CSI Pm m  Character Attributes (SGR).
	                    // CSI > Ps; Ps m
	                    // case 'm': // duplicate
	                    //   if (this.prefix === '>') {
	                    //     this.setResources(this.params);
	                    //   } else {
	                    //     this.charAttributes(this.params);
	                    //   }
	                    //   break;
	                    // CSI Ps n  Device Status Report (DSR).
	                    // CSI > Ps n
	                    // case 'n': // duplicate
	                    //   if (this.prefix === '>') {
	                    //     this.disableModifiers(this.params);
	                    //   } else {
	                    //     this.deviceStatus(this.params);
	                    //   }
	                    //   break;
	                    // CSI > Ps p  Set pointer mode.
	                    // CSI ! p   Soft terminal reset (DECSTR).
	                    // CSI Ps$ p
	                    //   Request ANSI mode (DECRQM).
	                    // CSI ? Ps$ p
	                    //   Request DEC private mode (DECRQM).
	                    // CSI Ps ; Ps " p
	                    case 'p':
	                        switch (this.prefix) {
	                            // case '>':
	                            //   this.setPointerMode(this.params);
	                            //   break;
	                            case '!':
	                                this.softReset(this.params);
	                                break;
	                        }
	                        break;
	                    // CSI Ps q  Load LEDs (DECLL).
	                    // CSI Ps SP q
	                    // CSI Ps " q
	                    // case 'q':
	                    //   if (this.postfix === ' ') {
	                    //     this.setCursorStyle(this.params);
	                    //     break;
	                    //   }
	                    //   if (this.postfix === '"') {
	                    //     this.setCharProtectionAttr(this.params);
	                    //     break;
	                    //   }
	                    //   this.loadLEDs(this.params);
	                    //   break;
	                    // CSI Ps ; Ps r
	                    //   Set Scrolling Region [top;bottom] (default = full size of win-
	                    //   dow) (DECSTBM).
	                    // CSI ? Pm r
	                    // CSI Pt; Pl; Pb; Pr; Ps$ r
	                    // case 'r': // duplicate
	                    //   if (this.prefix === '?') {
	                    //     this.restorePrivateValues(this.params);
	                    //   } else if (this.postfix === '$') {
	                    //     this.setAttrInRectangle(this.params);
	                    //   } else {
	                    //     this.setScrollRegion(this.params);
	                    //   }
	                    //   break;
	                    // CSI s     Save cursor (ANSI.SYS).
	                    // CSI ? Pm s
	                    // case 's': // duplicate
	                    //   if (this.prefix === '?') {
	                    //     this.savePrivateValues(this.params);
	                    //   } else {
	                    //     this.saveCursor(this.params);
	                    //   }
	                    //   break;
	                    // CSI Ps ; Ps ; Ps t
	                    // CSI Pt; Pl; Pb; Pr; Ps$ t
	                    // CSI > Ps; Ps t
	                    // CSI Ps SP t
	                    // case 't':
	                    //   if (this.postfix === '$') {
	                    //     this.reverseAttrInRectangle(this.params);
	                    //   } else if (this.postfix === ' ') {
	                    //     this.setWarningBellVolume(this.params);
	                    //   } else {
	                    //     if (this.prefix === '>') {
	                    //       this.setTitleModeFeature(this.params);
	                    //     } else {
	                    //       this.manipulateWindow(this.params);
	                    //     }
	                    //   }
	                    //   break;
	                    // CSI u     Restore cursor (ANSI.SYS).
	                    // CSI Ps SP u
	                    // case 'u': // duplicate
	                    //   if (this.postfix === ' ') {
	                    //     this.setMarginBellVolume(this.params);
	                    //   } else {
	                    //     this.restoreCursor(this.params);
	                    //   }
	                    //   break;
	                    // CSI Pt; Pl; Pb; Pr; Pp; Pt; Pl; Pp$ v
	                    // case 'v':
	                    //   if (this.postfix === '$') {
	                    //     this.copyRectagle(this.params);
	                    //   }
	                    //   break;
	                    // CSI Pt ; Pl ; Pb ; Pr ' w
	                    // case 'w':
	                    //   if (this.postfix === '\'') {
	                    //     this.enableFilterRectangle(this.params);
	                    //   }
	                    //   break;
	                    // CSI Ps x  Request Terminal Parameters (DECREQTPARM).
	                    // CSI Ps x  Select Attribute Change Extent (DECSACE).
	                    // CSI Pc; Pt; Pl; Pb; Pr$ x
	                    // case 'x':
	                    //   if (this.postfix === '$') {
	                    //     this.fillRectangle(this.params);
	                    //   } else {
	                    //     this.requestParameters(this.params);
	                    //     //this.__(this.params);
	                    //   }
	                    //   break;
	                    // CSI Ps ; Pu ' z
	                    // CSI Pt; Pl; Pb; Pr$ z
	                    // case 'z':
	                    //   if (this.postfix === '\'') {
	                    //     this.enableLocatorReporting(this.params);
	                    //   } else if (this.postfix === '$') {
	                    //     this.eraseRectangle(this.params);
	                    //   }
	                    //   break;
	                    // CSI Pm ' {
	                    // CSI Pt; Pl; Pb; Pr$ {
	                    // case '{':
	                    //   if (this.postfix === '\'') {
	                    //     this.setLocatorEvents(this.params);
	                    //   } else if (this.postfix === '$') {
	                    //     this.selectiveEraseRectangle(this.params);
	                    //   }
	                    //   break;
	                    // CSI Ps ' |
	                    // case '|':
	                    //   if (this.postfix === '\'') {
	                    //     this.requestLocatorPosition(this.params);
	                    //   }
	                    //   break;
	                    // CSI P m SP }
	                    // Insert P s Column(s) (default = 1) (DECIC), VT420 and up.
	                    // case '}':
	                    //   if (this.postfix === ' ') {
	                    //     this.insertColumns(this.params);
	                    //   }
	                    //   break;
	                    // CSI P m SP ~
	                    // Delete P s Column(s) (default = 1) (DECDC), VT420 and up
	                    // case '~':
	                    //   if (this.postfix === ' ') {
	                    //     this.deleteColumns(this.params);
	                    //   }
	                    //   break;
	                    default:
	                        this.error('Unknown CSI code: %s.', ch);
	                        break;
	                }
	                this.prefix = '';
	                this.postfix = '';
	                break;
	            case dcs:
	                if (ch === '\x1b' || ch === '\x07') {
	                    if (ch === '\x1b')
	                        i++;
	                    switch (this.prefix) {
	                        // User-Defined Keys (DECUDK).
	                        case '':
	                            break;
	                        // Request Status String (DECRQSS).
	                        // test: echo -e '\eP$q"p\e\\'
	                        case '$q':
	                            var pt = this.currentParam, valid = false;
	                            switch (pt) {
	                                // DECSCA
	                                case '"q':
	                                    pt = '0"q';
	                                    break;
	                                // DECSCL
	                                case '"p':
	                                    pt = '61"p';
	                                    break;
	                                // DECSTBM
	                                case 'r':
	                                    pt = ''
	                                        + (this.scrollTop + 1)
	                                        + ';'
	                                        + (this.scrollBottom + 1)
	                                        + 'r';
	                                    break;
	                                // SGR
	                                case 'm':
	                                    pt = '0m';
	                                    break;
	                                default:
	                                    this.error('Unknown DCS Pt: %s.', pt);
	                                    pt = '';
	                                    break;
	                            }
	                            this.send('\x1bP' + +valid + '$r' + pt + '\x1b\\');
	                            break;
	                        // Set Termcap/Terminfo Data (xterm, experimental).
	                        case '+p':
	                            break;
	                        // Request Termcap/Terminfo String (xterm, experimental)
	                        // Regular xterm does not even respond to this sequence.
	                        // This can cause a small glitch in vim.
	                        // test: echo -ne '\eP+q6b64\e\\'
	                        case '+q':
	                            var pt = this.currentParam, valid = false;
	                            this.send('\x1bP' + +valid + '+r' + pt + '\x1b\\');
	                            break;
	                        default:
	                            this.error('Unknown DCS prefix: %s.', this.prefix);
	                            break;
	                    }
	                    this.currentParam = 0;
	                    this.prefix = '';
	                    this.state = normal;
	                }
	                else if (!this.currentParam) {
	                    if (!this.prefix && ch !== '$' && ch !== '+') {
	                        this.currentParam = ch;
	                    }
	                    else if (this.prefix.length === 2) {
	                        this.currentParam = ch;
	                    }
	                    else {
	                        this.prefix += ch;
	                    }
	                }
	                else {
	                    this.currentParam += ch;
	                }
	                break;
	            case ignore:
	                // For PM and APC.
	                if (ch === '\x1b' || ch === '\x07') {
	                    if (ch === '\x1b')
	                        i++;
	                    this.state = normal;
	                }
	                break;
	        }
	    }
	    this.updateRange(this.y);
	    this.refresh(this.refreshStart, this.refreshEnd);
	};
	/**
	 * Writes text to the terminal, followed by a break line character (\n).
	 * @param {string} text The text to write to the terminal.
	 */
	Terminal.prototype.writeln = function (data) {
	    this.write(data + '\r\n');
	};
	/**
	 * Attaches a custom keydown handler which is run before keys are processed, giving consumers of
	 * xterm.js ultimate control as to what keys should be processed by the terminal and what keys
	 * should not.
	 * @param {function} customKeydownHandler The custom KeyboardEvent handler to attach. This is a
	 *   function that takes a KeyboardEvent, allowing consumers to stop propogation and/or prevent
	 *   the default action. The function returns whether the event should be processed by xterm.js.
	 */
	Terminal.prototype.attachCustomKeydownHandler = function (customKeydownHandler) {
	    this.customKeydownHandler = customKeydownHandler;
	};
	/**
	 * Handle a keydown event
	 * Key Resources:
	 *   - https://developer.mozilla.org/en-US/docs/DOM/KeyboardEvent
	 * @param {KeyboardEvent} ev The keydown event to be handled.
	 */
	Terminal.prototype.keyDown = function (ev) {
	    if (this.customKeydownHandler && this.customKeydownHandler(ev) === false) {
	        return false;
	    }
	    if (!this.compositionHelper.keydown.bind(this.compositionHelper)(ev)) {
	        if (this.ybase !== this.ydisp) {
	            this.scrollToBottom();
	        }
	        return false;
	    }
	    var self = this;
	    var result = this.evaluateKeyEscapeSequence(ev);
	    if (result.scrollDisp) {
	        this.scrollDisp(result.scrollDisp);
	        return this.cancel(ev, true);
	    }
	    if (isThirdLevelShift(this, ev)) {
	        return true;
	    }
	    if (result.cancel) {
	        // The event is canceled at the end already, is this necessary?
	        this.cancel(ev, true);
	    }
	    if (!result.key) {
	        return true;
	    }
	    this.emit('keydown', ev);
	    this.emit('key', result.key, ev);
	    this.showCursor();
	    this.handler(result.key);
	    return this.cancel(ev, true);
	};
	/**
	 * Returns an object that determines how a KeyboardEvent should be handled. The key of the
	 * returned value is the new key code to pass to the PTY.
	 *
	 * Reference: http://invisible-island.net/xterm/ctlseqs/ctlseqs.html
	 * @param {KeyboardEvent} ev The keyboard event to be translated to key escape sequence.
	 */
	Terminal.prototype.evaluateKeyEscapeSequence = function (ev) {
	    var result = {
	        // Whether to cancel event propogation (NOTE: this may not be needed since the event is
	        // canceled at the end of keyDown
	        cancel: false,
	        // The new key even to emit
	        key: undefined,
	        // The number of characters to scroll, if this is defined it will cancel the event
	        scrollDisp: undefined
	    };
	    var modifiers = ev.shiftKey << 0 | ev.altKey << 1 | ev.ctrlKey << 2 | ev.metaKey << 3;
	    switch (ev.keyCode) {
	        case 8:
	            // backspace
	            if (ev.shiftKey) {
	                result.key = '\x08'; // ^H
	                break;
	            }
	            result.key = '\x7f'; // ^?
	            break;
	        case 9:
	            // tab
	            if (ev.shiftKey) {
	                result.key = '\x1b[Z';
	                break;
	            }
	            result.key = '\t';
	            result.cancel = true;
	            break;
	        case 13:
	            // return/enter
	            result.key = '\r';
	            result.cancel = true;
	            break;
	        case 27:
	            // escape
	            result.key = '\x1b';
	            result.cancel = true;
	            break;
	        case 37:
	            // left-arrow
	            if (modifiers) {
	                result.key = '\x1b[1;' + (modifiers + 1) + 'D';
	                // HACK: Make Alt + left-arrow behave like Ctrl + left-arrow: move one word backwards
	                // http://unix.stackexchange.com/a/108106
	                if (result.key == '\x1b[1;3D') {
	                    result.key = '\x1b[1;5D';
	                }
	            }
	            else if (this.applicationCursor) {
	                result.key = '\x1bOD';
	            }
	            else {
	                result.key = '\x1b[D';
	            }
	            break;
	        case 39:
	            // right-arrow
	            if (modifiers) {
	                result.key = '\x1b[1;' + (modifiers + 1) + 'C';
	                // HACK: Make Alt + right-arrow behave like Ctrl + right-arrow: move one word forward
	                // http://unix.stackexchange.com/a/108106
	                if (result.key == '\x1b[1;3C') {
	                    result.key = '\x1b[1;5C';
	                }
	            }
	            else if (this.applicationCursor) {
	                result.key = '\x1bOC';
	            }
	            else {
	                result.key = '\x1b[C';
	            }
	            break;
	        case 38:
	            // up-arrow
	            if (modifiers) {
	                result.key = '\x1b[1;' + (modifiers + 1) + 'A';
	                // HACK: Make Alt + up-arrow behave like Ctrl + up-arrow
	                // http://unix.stackexchange.com/a/108106
	                if (result.key == '\x1b[1;3A') {
	                    result.key = '\x1b[1;5A';
	                }
	            }
	            else if (this.applicationCursor) {
	                result.key = '\x1bOA';
	            }
	            else {
	                result.key = '\x1b[A';
	            }
	            break;
	        case 40:
	            // down-arrow
	            if (modifiers) {
	                result.key = '\x1b[1;' + (modifiers + 1) + 'B';
	                // HACK: Make Alt + down-arrow behave like Ctrl + down-arrow
	                // http://unix.stackexchange.com/a/108106
	                if (result.key == '\x1b[1;3B') {
	                    result.key = '\x1b[1;5B';
	                }
	            }
	            else if (this.applicationCursor) {
	                result.key = '\x1bOB';
	            }
	            else {
	                result.key = '\x1b[B';
	            }
	            break;
	        case 45:
	            // insert
	            if (!ev.shiftKey && !ev.ctrlKey) {
	                // <Ctrl> or <Shift> + <Insert> are used to
	                // copy-paste on some systems.
	                result.key = '\x1b[2~';
	            }
	            break;
	        case 46:
	            // delete
	            if (modifiers) {
	                result.key = '\x1b[3;' + (modifiers + 1) + '~';
	            }
	            else {
	                result.key = '\x1b[3~';
	            }
	            break;
	        case 36:
	            // home
	            if (modifiers)
	                result.key = '\x1b[1;' + (modifiers + 1) + 'H';
	            else if (this.applicationCursor)
	                result.key = '\x1bOH';
	            else
	                result.key = '\x1b[H';
	            break;
	        case 35:
	            // end
	            if (modifiers)
	                result.key = '\x1b[1;' + (modifiers + 1) + 'F';
	            else if (this.applicationCursor)
	                result.key = '\x1bOF';
	            else
	                result.key = '\x1b[F';
	            break;
	        case 33:
	            // page up
	            if (ev.shiftKey) {
	                result.scrollDisp = -(this.rows - 1);
	            }
	            else {
	                result.key = '\x1b[5~';
	            }
	            break;
	        case 34:
	            // page down
	            if (ev.shiftKey) {
	                result.scrollDisp = this.rows - 1;
	            }
	            else {
	                result.key = '\x1b[6~';
	            }
	            break;
	        case 112:
	            // F1-F12
	            if (modifiers) {
	                result.key = '\x1b[1;' + (modifiers + 1) + 'P';
	            }
	            else {
	                result.key = '\x1bOP';
	            }
	            break;
	        case 113:
	            if (modifiers) {
	                result.key = '\x1b[1;' + (modifiers + 1) + 'Q';
	            }
	            else {
	                result.key = '\x1bOQ';
	            }
	            break;
	        case 114:
	            if (modifiers) {
	                result.key = '\x1b[1;' + (modifiers + 1) + 'R';
	            }
	            else {
	                result.key = '\x1bOR';
	            }
	            break;
	        case 115:
	            if (modifiers) {
	                result.key = '\x1b[1;' + (modifiers + 1) + 'S';
	            }
	            else {
	                result.key = '\x1bOS';
	            }
	            break;
	        case 116:
	            if (modifiers) {
	                result.key = '\x1b[15;' + (modifiers + 1) + '~';
	            }
	            else {
	                result.key = '\x1b[15~';
	            }
	            break;
	        case 117:
	            if (modifiers) {
	                result.key = '\x1b[17;' + (modifiers + 1) + '~';
	            }
	            else {
	                result.key = '\x1b[17~';
	            }
	            break;
	        case 118:
	            if (modifiers) {
	                result.key = '\x1b[18;' + (modifiers + 1) + '~';
	            }
	            else {
	                result.key = '\x1b[18~';
	            }
	            break;
	        case 119:
	            if (modifiers) {
	                result.key = '\x1b[19;' + (modifiers + 1) + '~';
	            }
	            else {
	                result.key = '\x1b[19~';
	            }
	            break;
	        case 120:
	            if (modifiers) {
	                result.key = '\x1b[20;' + (modifiers + 1) + '~';
	            }
	            else {
	                result.key = '\x1b[20~';
	            }
	            break;
	        case 121:
	            if (modifiers) {
	                result.key = '\x1b[21;' + (modifiers + 1) + '~';
	            }
	            else {
	                result.key = '\x1b[21~';
	            }
	            break;
	        case 122:
	            if (modifiers) {
	                result.key = '\x1b[23;' + (modifiers + 1) + '~';
	            }
	            else {
	                result.key = '\x1b[23~';
	            }
	            break;
	        case 123:
	            if (modifiers) {
	                result.key = '\x1b[24;' + (modifiers + 1) + '~';
	            }
	            else {
	                result.key = '\x1b[24~';
	            }
	            break;
	        default:
	            // a-z and space
	            if (ev.ctrlKey && !ev.shiftKey && !ev.altKey && !ev.metaKey) {
	                if (ev.keyCode >= 65 && ev.keyCode <= 90) {
	                    result.key = String.fromCharCode(ev.keyCode - 64);
	                }
	                else if (ev.keyCode === 32) {
	                    // NUL
	                    result.key = String.fromCharCode(0);
	                }
	                else if (ev.keyCode >= 51 && ev.keyCode <= 55) {
	                    // escape, file sep, group sep, record sep, unit sep
	                    result.key = String.fromCharCode(ev.keyCode - 51 + 27);
	                }
	                else if (ev.keyCode === 56) {
	                    // delete
	                    result.key = String.fromCharCode(127);
	                }
	                else if (ev.keyCode === 219) {
	                    // ^[ - Control Sequence Introducer (CSI)
	                    result.key = String.fromCharCode(27);
	                }
	                else if (ev.keyCode === 220) {
	                    // ^\ - String Terminator (ST)
	                    result.key = String.fromCharCode(28);
	                }
	                else if (ev.keyCode === 221) {
	                    // ^] - Operating System Command (OSC)
	                    result.key = String.fromCharCode(29);
	                }
	            }
	            else if (!this.browser.isMac && ev.altKey && !ev.ctrlKey && !ev.metaKey) {
	                // On Mac this is a third level shift. Use <Esc> instead.
	                if (ev.keyCode >= 65 && ev.keyCode <= 90) {
	                    result.key = '\x1b' + String.fromCharCode(ev.keyCode + 32);
	                }
	                else if (ev.keyCode === 192) {
	                    result.key = '\x1b`';
	                }
	                else if (ev.keyCode >= 48 && ev.keyCode <= 57) {
	                    result.key = '\x1b' + (ev.keyCode - 48);
	                }
	            }
	            break;
	    }
	    return result;
	};
	/**
	 * Set the G level of the terminal
	 * @param g
	 */
	Terminal.prototype.setgLevel = function (g) {
	    this.glevel = g;
	    this.charset = this.charsets[g];
	};
	/**
	 * Set the charset for the given G level of the terminal
	 * @param g
	 * @param charset
	 */
	Terminal.prototype.setgCharset = function (g, charset) {
	    this.charsets[g] = charset;
	    if (this.glevel === g) {
	        this.charset = charset;
	    }
	};
	/**
	 * Handle a keypress event.
	 * Key Resources:
	 *   - https://developer.mozilla.org/en-US/docs/DOM/KeyboardEvent
	 * @param {KeyboardEvent} ev The keypress event to be handled.
	 */
	Terminal.prototype.keyPress = function (ev) {
	    var key;
	    this.cancel(ev);
	    if (ev.charCode) {
	        key = ev.charCode;
	    }
	    else if (ev.which == null) {
	        key = ev.keyCode;
	    }
	    else if (ev.which !== 0 && ev.charCode !== 0) {
	        key = ev.which;
	    }
	    else {
	        return false;
	    }
	    if (!key || ((ev.altKey || ev.ctrlKey || ev.metaKey) && !isThirdLevelShift(this, ev))) {
	        return false;
	    }
	    key = String.fromCharCode(key);
	    this.emit('keypress', key, ev);
	    this.emit('key', key, ev);
	    this.showCursor();
	    this.handler(key);
	    return false;
	};
	/**
	 * Send data for handling to the terminal
	 * @param {string} data
	 */
	Terminal.prototype.send = function (data) {
	    var self = this;
	    if (!this.queue) {
	        setTimeout(function () {
	            self.handler(self.queue);
	            self.queue = '';
	        }, 1);
	    }
	    this.queue += data;
	};
	/**
	 * Ring the bell.
	 * Note: We could do sweet things with webaudio here
	 */
	Terminal.prototype.bell = function () {
	    if (!this.visualBell)
	        return;
	    var self = this;
	    this.element.style.borderColor = 'white';
	    setTimeout(function () {
	        self.element.style.borderColor = '';
	    }, 10);
	    if (this.popOnBell)
	        this.focus();
	};
	/**
	 * Log the current state to the console.
	 */
	Terminal.prototype.log = function () {
	    if (!this.debug)
	        return;
	    if (!this.context.console || !this.context.console.log)
	        return;
	    var args = Array.prototype.slice.call(arguments);
	    this.context.console.log.apply(this.context.console, args);
	};
	/**
	 * Log the current state as error to the console.
	 */
	Terminal.prototype.error = function () {
	    if (!this.debug)
	        return;
	    if (!this.context.console || !this.context.console.error)
	        return;
	    var args = Array.prototype.slice.call(arguments);
	    this.context.console.error.apply(this.context.console, args);
	};
	/**
	 * Resizes the terminal.
	 *
	 * @param {number} x The number of columns to resize to.
	 * @param {number} y The number of rows to resize to.
	 */
	Terminal.prototype.resize = function (x, y) {
	    var line, el, i, j, ch, addToY;
	    if (x === this.cols && y === this.rows) {
	        return;
	    }
	    if (x < 1)
	        x = 1;
	    if (y < 1)
	        y = 1;
	    // resize cols
	    j = this.cols;
	    if (j < x) {
	        ch = [this.defAttr, ' ', 1]; // does xterm use the default attr?
	        i = this.lines.length;
	        while (i--) {
	            while (this.lines[i].length < x) {
	                this.lines[i].push(ch);
	            }
	        }
	    }
	    else {
	        i = this.lines.length;
	        while (i--) {
	            while (this.lines[i].length > x) {
	                this.lines[i].pop();
	            }
	        }
	    }
	    this.setupStops(j);
	    this.cols = x;
	    // resize rows
	    j = this.rows;
	    addToY = 0;
	    if (j < y) {
	        el = this.element;
	        while (j++ < y) {
	            // y is rows, not this.y
	            if (this.lines.length < y + this.ybase) {
	                if (this.ybase > 0 && this.lines.length <= this.ybase + this.y + addToY + 1) {
	                    // There is room above the buffer and there are no empty elements below the line,
	                    // scroll up
	                    this.ybase--;
	                    addToY++;
	                    if (this.ydisp > 0) {
	                        // Viewport is at the top of the buffer, must increase downwards
	                        this.ydisp--;
	                    }
	                }
	                else {
	                    // Add a blank line if there is no buffer left at the top to scroll to, or if there
	                    // are blank lines after the cursor
	                    this.lines.push(this.blankLine());
	                }
	            }
	            if (this.children.length < y) {
	                this.insertRow();
	            }
	        }
	    }
	    else {
	        while (j-- > y) {
	            if (this.lines.length > y + this.ybase) {
	                if (this.lines.length > this.ybase + this.y + 1) {
	                    // The line is a blank line below the cursor, remove it
	                    this.lines.pop();
	                }
	                else {
	                    // The line is the cursor, scroll down
	                    this.ybase++;
	                    this.ydisp++;
	                }
	            }
	            if (this.children.length > y) {
	                el = this.children.shift();
	                if (!el)
	                    continue;
	                el.parentNode.removeChild(el);
	            }
	        }
	    }
	    this.rows = y;
	    // Make sure that the cursor stays on screen
	    if (this.y >= y) {
	        this.y = y - 1;
	    }
	    if (addToY) {
	        this.y += addToY;
	    }
	    if (this.x >= x) {
	        this.x = x - 1;
	    }
	    this.scrollTop = 0;
	    this.scrollBottom = y - 1;
	    this.refresh(0, this.rows - 1);
	    this.normal = null;
	    this.geometry = [this.cols, this.rows];
	    this.emit('resize', { terminal: this, cols: x, rows: y });
	};
	/**
	 * Updates the range of rows to refresh
	 * @param {number} y The number of rows to refresh next.
	 */
	Terminal.prototype.updateRange = function (y) {
	    if (y < this.refreshStart)
	        this.refreshStart = y;
	    if (y > this.refreshEnd)
	        this.refreshEnd = y;
	    // if (y > this.refreshEnd) {
	    //   this.refreshEnd = y;
	    //   if (y > this.rows - 1) {
	    //     this.refreshEnd = this.rows - 1;
	    //   }
	    // }
	};
	/**
	 * Set the range of refreshing to the maximum value
	 */
	Terminal.prototype.maxRange = function () {
	    this.refreshStart = 0;
	    this.refreshEnd = this.rows - 1;
	};
	/**
	 * Setup the tab stops.
	 * @param {number} i
	 */
	Terminal.prototype.setupStops = function (i) {
	    if (i != null) {
	        if (!this.tabs[i]) {
	            i = this.prevStop(i);
	        }
	    }
	    else {
	        this.tabs = {};
	        i = 0;
	    }
	    for (; i < this.cols; i += 8) {
	        this.tabs[i] = true;
	    }
	};
	/**
	 * Move the cursor to the previous tab stop from the given position (default is current).
	 * @param {number} x The position to move the cursor to the previous tab stop.
	 */
	Terminal.prototype.prevStop = function (x) {
	    if (x == null)
	        x = this.x;
	    while (!this.tabs[--x] && x > 0)
	        ;
	    return x >= this.cols
	        ? this.cols - 1
	        : x < 0 ? 0 : x;
	};
	/**
	 * Move the cursor one tab stop forward from the given position (default is current).
	 * @param {number} x The position to move the cursor one tab stop forward.
	 */
	Terminal.prototype.nextStop = function (x) {
	    if (x == null)
	        x = this.x;
	    while (!this.tabs[++x] && x < this.cols)
	        ;
	    return x >= this.cols
	        ? this.cols - 1
	        : x < 0 ? 0 : x;
	};
	/**
	 * Erase in the identified line everything from "x" to the end of the line (right).
	 * @param {number} x The column from which to start erasing to the end of the line.
	 * @param {number} y The line in which to operate.
	 */
	Terminal.prototype.eraseRight = function (x, y) {
	    var line = this.lines[this.ybase + y], ch = [this.eraseAttr(), ' ', 1]; // xterm
	    for (; x < this.cols; x++) {
	        line[x] = ch;
	    }
	    this.updateRange(y);
	};
	/**
	 * Erase in the identified line everything from "x" to the start of the line (left).
	 * @param {number} x The column from which to start erasing to the start of the line.
	 * @param {number} y The line in which to operate.
	 */
	Terminal.prototype.eraseLeft = function (x, y) {
	    var line = this.lines[this.ybase + y], ch = [this.eraseAttr(), ' ', 1]; // xterm
	    x++;
	    while (x--)
	        line[x] = ch;
	    this.updateRange(y);
	};
	/**
	 * Clears the entire buffer, making the prompt line the new first line.
	 */
	Terminal.prototype.clear = function () {
	    if (this.ybase === 0 && this.y === 0) {
	        // Don't clear if it's already clear
	        return;
	    }
	    this.lines = [this.lines[this.ybase + this.y]];
	    this.ydisp = 0;
	    this.ybase = 0;
	    this.y = 0;
	    for (var i = 1; i < this.rows; i++) {
	        this.lines.push(this.blankLine());
	    }
	    this.refresh(0, this.rows - 1);
	    this.emit('scroll', this.ydisp);
	};
	/**
	 * Erase all content in the given line
	 * @param {number} y The line to erase all of its contents.
	 */
	Terminal.prototype.eraseLine = function (y) {
	    this.eraseRight(0, y);
	};
	/**
	 * Return the data array of a blank line/
	 * @param {number} cur First bunch of data for each "blank" character.
	 */
	Terminal.prototype.blankLine = function (cur) {
	    var attr = cur
	        ? this.eraseAttr()
	        : this.defAttr;
	    var ch = [attr, ' ', 1] // width defaults to 1 halfwidth character
	    , line = [], i = 0;
	    for (; i < this.cols; i++) {
	        line[i] = ch;
	    }
	    return line;
	};
	/**
	 * If cur return the back color xterm feature attribute. Else return defAttr.
	 * @param {object} cur
	 */
	Terminal.prototype.ch = function (cur) {
	    return cur
	        ? [this.eraseAttr(), ' ', 1]
	        : [this.defAttr, ' ', 1];
	};
	/**
	 * Evaluate if the current erminal is the given argument.
	 * @param {object} term The terminal to evaluate
	 */
	Terminal.prototype.is = function (term) {
	    var name = this.termName;
	    return (name + '').indexOf(term) === 0;
	};
	/**
	 * Emit the 'data' event and populate the given data.
	 * @param {string} data The data to populate in the event.
	 */
	Terminal.prototype.handler = function (data) {
	    // Input is being sent to the terminal, the terminal should focus the prompt.
	    if (this.ybase !== this.ydisp) {
	        this.scrollToBottom();
	    }
	    this.emit('data', data);
	};
	/**
	 * Emit the 'title' event and populate the given title.
	 * @param {string} title The title to populate in the event.
	 */
	Terminal.prototype.handleTitle = function (title) {
	    /**
	     * This event is emitted when the title of the terminal is changed
	     * from inside the terminal. The parameter is the new title.
	     *
	     * @event title
	     */
	    this.emit('title', title);
	};
	/**
	 * ESC
	 */
	/**
	 * ESC D Index (IND is 0x84).
	 */
	Terminal.prototype.index = function () {
	    this.y++;
	    if (this.y > this.scrollBottom) {
	        this.y--;
	        this.scroll();
	    }
	    this.state = normal;
	};
	/**
	 * ESC M Reverse Index (RI is 0x8d).
	 */
	Terminal.prototype.reverseIndex = function () {
	    var j;
	    this.y--;
	    if (this.y < this.scrollTop) {
	        this.y++;
	        // possibly move the code below to term.reverseScroll();
	        // test: echo -ne '\e[1;1H\e[44m\eM\e[0m'
	        // blankLine(true) is xterm/linux behavior
	        this.lines.splice(this.y + this.ybase, 0, this.blankLine(true));
	        j = this.rows - 1 - this.scrollBottom;
	        this.lines.splice(this.rows - 1 + this.ybase - j + 1, 1);
	        // this.maxRange();
	        this.updateRange(this.scrollTop);
	        this.updateRange(this.scrollBottom);
	    }
	    this.state = normal;
	};
	/**
	 * ESC c Full Reset (RIS).
	 */
	Terminal.prototype.reset = function () {
	    this.options.rows = this.rows;
	    this.options.cols = this.cols;
	    var customKeydownHandler = this.customKeydownHandler;
	    Terminal.call(this, this.options);
	    this.customKeydownHandler = customKeydownHandler;
	    this.refresh(0, this.rows - 1);
	    this.viewport.syncScrollArea();
	};
	/**
	 * ESC H Tab Set (HTS is 0x88).
	 */
	Terminal.prototype.tabSet = function () {
	    this.tabs[this.x] = true;
	    this.state = normal;
	};
	/**
	 * CSI
	 */
	/**
	 * CSI Ps A
	 * Cursor Up Ps Times (default = 1) (CUU).
	 */
	Terminal.prototype.cursorUp = function (params) {
	    var param = params[0];
	    if (param < 1)
	        param = 1;
	    this.y -= param;
	    if (this.y < 0)
	        this.y = 0;
	};
	/**
	 * CSI Ps B
	 * Cursor Down Ps Times (default = 1) (CUD).
	 */
	Terminal.prototype.cursorDown = function (params) {
	    var param = params[0];
	    if (param < 1)
	        param = 1;
	    this.y += param;
	    if (this.y >= this.rows) {
	        this.y = this.rows - 1;
	    }
	};
	/**
	 * CSI Ps C
	 * Cursor Forward Ps Times (default = 1) (CUF).
	 */
	Terminal.prototype.cursorForward = function (params) {
	    var param = params[0];
	    if (param < 1)
	        param = 1;
	    this.x += param;
	    if (this.x >= this.cols) {
	        this.x = this.cols - 1;
	    }
	};
	/**
	 * CSI Ps D
	 * Cursor Backward Ps Times (default = 1) (CUB).
	 */
	Terminal.prototype.cursorBackward = function (params) {
	    var param = params[0];
	    if (param < 1)
	        param = 1;
	    this.x -= param;
	    if (this.x < 0)
	        this.x = 0;
	};
	/**
	 * CSI Ps ; Ps H
	 * Cursor Position [row;column] (default = [1,1]) (CUP).
	 */
	Terminal.prototype.cursorPos = function (params) {
	    var row, col;
	    row = params[0] - 1;
	    if (params.length >= 2) {
	        col = params[1] - 1;
	    }
	    else {
	        col = 0;
	    }
	    if (row < 0) {
	        row = 0;
	    }
	    else if (row >= this.rows) {
	        row = this.rows - 1;
	    }
	    if (col < 0) {
	        col = 0;
	    }
	    else if (col >= this.cols) {
	        col = this.cols - 1;
	    }
	    this.x = col;
	    this.y = row;
	};
	/**
	 * CSI Ps J  Erase in Display (ED).
	 *     Ps = 0  -> Erase Below (default).
	 *     Ps = 1  -> Erase Above.
	 *     Ps = 2  -> Erase All.
	 *     Ps = 3  -> Erase Saved Lines (xterm).
	 * CSI ? Ps J
	 *   Erase in Display (DECSED).
	 *     Ps = 0  -> Selective Erase Below (default).
	 *     Ps = 1  -> Selective Erase Above.
	 *     Ps = 2  -> Selective Erase All.
	 */
	Terminal.prototype.eraseInDisplay = function (params) {
	    var j;
	    switch (params[0]) {
	        case 0:
	            this.eraseRight(this.x, this.y);
	            j = this.y + 1;
	            for (; j < this.rows; j++) {
	                this.eraseLine(j);
	            }
	            break;
	        case 1:
	            this.eraseLeft(this.x, this.y);
	            j = this.y;
	            while (j--) {
	                this.eraseLine(j);
	            }
	            break;
	        case 2:
	            j = this.rows;
	            while (j--)
	                this.eraseLine(j);
	            break;
	        case 3:
	            ; // no saved lines
	            break;
	    }
	};
	/**
	 * CSI Ps K  Erase in Line (EL).
	 *     Ps = 0  -> Erase to Right (default).
	 *     Ps = 1  -> Erase to Left.
	 *     Ps = 2  -> Erase All.
	 * CSI ? Ps K
	 *   Erase in Line (DECSEL).
	 *     Ps = 0  -> Selective Erase to Right (default).
	 *     Ps = 1  -> Selective Erase to Left.
	 *     Ps = 2  -> Selective Erase All.
	 */
	Terminal.prototype.eraseInLine = function (params) {
	    switch (params[0]) {
	        case 0:
	            this.eraseRight(this.x, this.y);
	            break;
	        case 1:
	            this.eraseLeft(this.x, this.y);
	            break;
	        case 2:
	            this.eraseLine(this.y);
	            break;
	    }
	};
	/**
	 * CSI Pm m  Character Attributes (SGR).
	 *     Ps = 0  -> Normal (default).
	 *     Ps = 1  -> Bold.
	 *     Ps = 4  -> Underlined.
	 *     Ps = 5  -> Blink (appears as Bold).
	 *     Ps = 7  -> Inverse.
	 *     Ps = 8  -> Invisible, i.e., hidden (VT300).
	 *     Ps = 2 2  -> Normal (neither bold nor faint).
	 *     Ps = 2 4  -> Not underlined.
	 *     Ps = 2 5  -> Steady (not blinking).
	 *     Ps = 2 7  -> Positive (not inverse).
	 *     Ps = 2 8  -> Visible, i.e., not hidden (VT300).
	 *     Ps = 3 0  -> Set foreground color to Black.
	 *     Ps = 3 1  -> Set foreground color to Red.
	 *     Ps = 3 2  -> Set foreground color to Green.
	 *     Ps = 3 3  -> Set foreground color to Yellow.
	 *     Ps = 3 4  -> Set foreground color to Blue.
	 *     Ps = 3 5  -> Set foreground color to Magenta.
	 *     Ps = 3 6  -> Set foreground color to Cyan.
	 *     Ps = 3 7  -> Set foreground color to White.
	 *     Ps = 3 9  -> Set foreground color to default (original).
	 *     Ps = 4 0  -> Set background color to Black.
	 *     Ps = 4 1  -> Set background color to Red.
	 *     Ps = 4 2  -> Set background color to Green.
	 *     Ps = 4 3  -> Set background color to Yellow.
	 *     Ps = 4 4  -> Set background color to Blue.
	 *     Ps = 4 5  -> Set background color to Magenta.
	 *     Ps = 4 6  -> Set background color to Cyan.
	 *     Ps = 4 7  -> Set background color to White.
	 *     Ps = 4 9  -> Set background color to default (original).
	 *
	 *   If 16-color support is compiled, the following apply.  Assume
	 *   that xterm's resources are set so that the ISO color codes are
	 *   the first 8 of a set of 16.  Then the aixterm colors are the
	 *   bright versions of the ISO colors:
	 *     Ps = 9 0  -> Set foreground color to Black.
	 *     Ps = 9 1  -> Set foreground color to Red.
	 *     Ps = 9 2  -> Set foreground color to Green.
	 *     Ps = 9 3  -> Set foreground color to Yellow.
	 *     Ps = 9 4  -> Set foreground color to Blue.
	 *     Ps = 9 5  -> Set foreground color to Magenta.
	 *     Ps = 9 6  -> Set foreground color to Cyan.
	 *     Ps = 9 7  -> Set foreground color to White.
	 *     Ps = 1 0 0  -> Set background color to Black.
	 *     Ps = 1 0 1  -> Set background color to Red.
	 *     Ps = 1 0 2  -> Set background color to Green.
	 *     Ps = 1 0 3  -> Set background color to Yellow.
	 *     Ps = 1 0 4  -> Set background color to Blue.
	 *     Ps = 1 0 5  -> Set background color to Magenta.
	 *     Ps = 1 0 6  -> Set background color to Cyan.
	 *     Ps = 1 0 7  -> Set background color to White.
	 *
	 *   If xterm is compiled with the 16-color support disabled, it
	 *   supports the following, from rxvt:
	 *     Ps = 1 0 0  -> Set foreground and background color to
	 *     default.
	 *
	 *   If 88- or 256-color support is compiled, the following apply.
	 *     Ps = 3 8  ; 5  ; Ps -> Set foreground color to the second
	 *     Ps.
	 *     Ps = 4 8  ; 5  ; Ps -> Set background color to the second
	 *     Ps.
	 */
	Terminal.prototype.charAttributes = function (params) {
	    // Optimize a single SGR0.
	    if (params.length === 1 && params[0] === 0) {
	        this.curAttr = this.defAttr;
	        return;
	    }
	    var l = params.length, i = 0, flags = this.curAttr >> 18, fg = (this.curAttr >> 9) & 0x1ff, bg = this.curAttr & 0x1ff, p;
	    for (; i < l; i++) {
	        p = params[i];
	        if (p >= 30 && p <= 37) {
	            // fg color 8
	            fg = p - 30;
	        }
	        else if (p >= 40 && p <= 47) {
	            // bg color 8
	            bg = p - 40;
	        }
	        else if (p >= 90 && p <= 97) {
	            // fg color 16
	            p += 8;
	            fg = p - 90;
	        }
	        else if (p >= 100 && p <= 107) {
	            // bg color 16
	            p += 8;
	            bg = p - 100;
	        }
	        else if (p === 0) {
	            // default
	            flags = this.defAttr >> 18;
	            fg = (this.defAttr >> 9) & 0x1ff;
	            bg = this.defAttr & 0x1ff;
	        }
	        else if (p === 1) {
	            // bold text
	            flags |= 1;
	        }
	        else if (p === 4) {
	            // underlined text
	            flags |= 2;
	        }
	        else if (p === 5) {
	            // blink
	            flags |= 4;
	        }
	        else if (p === 7) {
	            // inverse and positive
	            // test with: echo -e '\e[31m\e[42mhello\e[7mworld\e[27mhi\e[m'
	            flags |= 8;
	        }
	        else if (p === 8) {
	            // invisible
	            flags |= 16;
	        }
	        else if (p === 22) {
	            // not bold
	            flags &= ~1;
	        }
	        else if (p === 24) {
	            // not underlined
	            flags &= ~2;
	        }
	        else if (p === 25) {
	            // not blink
	            flags &= ~4;
	        }
	        else if (p === 27) {
	            // not inverse
	            flags &= ~8;
	        }
	        else if (p === 28) {
	            // not invisible
	            flags &= ~16;
	        }
	        else if (p === 39) {
	            // reset fg
	            fg = (this.defAttr >> 9) & 0x1ff;
	        }
	        else if (p === 49) {
	            // reset bg
	            bg = this.defAttr & 0x1ff;
	        }
	        else if (p === 38) {
	            // fg color 256
	            if (params[i + 1] === 2) {
	                i += 2;
	                fg = matchColor(params[i] & 0xff, params[i + 1] & 0xff, params[i + 2] & 0xff);
	                if (fg === -1)
	                    fg = 0x1ff;
	                i += 2;
	            }
	            else if (params[i + 1] === 5) {
	                i += 2;
	                p = params[i] & 0xff;
	                fg = p;
	            }
	        }
	        else if (p === 48) {
	            // bg color 256
	            if (params[i + 1] === 2) {
	                i += 2;
	                bg = matchColor(params[i] & 0xff, params[i + 1] & 0xff, params[i + 2] & 0xff);
	                if (bg === -1)
	                    bg = 0x1ff;
	                i += 2;
	            }
	            else if (params[i + 1] === 5) {
	                i += 2;
	                p = params[i] & 0xff;
	                bg = p;
	            }
	        }
	        else if (p === 100) {
	            // reset fg/bg
	            fg = (this.defAttr >> 9) & 0x1ff;
	            bg = this.defAttr & 0x1ff;
	        }
	        else {
	            this.error('Unknown SGR attribute: %d.', p);
	        }
	    }
	    this.curAttr = (flags << 18) | (fg << 9) | bg;
	};
	/**
	 * CSI Ps n  Device Status Report (DSR).
	 *     Ps = 5  -> Status Report.  Result (``OK'') is
	 *   CSI 0 n
	 *     Ps = 6  -> Report Cursor Position (CPR) [row;column].
	 *   Result is
	 *   CSI r ; c R
	 * CSI ? Ps n
	 *   Device Status Report (DSR, DEC-specific).
	 *     Ps = 6  -> Report Cursor Position (CPR) [row;column] as CSI
	 *     ? r ; c R (assumes page is zero).
	 *     Ps = 1 5  -> Report Printer status as CSI ? 1 0  n  (ready).
	 *     or CSI ? 1 1  n  (not ready).
	 *     Ps = 2 5  -> Report UDK status as CSI ? 2 0  n  (unlocked)
	 *     or CSI ? 2 1  n  (locked).
	 *     Ps = 2 6  -> Report Keyboard status as
	 *   CSI ? 2 7  ;  1  ;  0  ;  0  n  (North American).
	 *   The last two parameters apply to VT400 & up, and denote key-
	 *   board ready and LK01 respectively.
	 *     Ps = 5 3  -> Report Locator status as
	 *   CSI ? 5 3  n  Locator available, if compiled-in, or
	 *   CSI ? 5 0  n  No Locator, if not.
	 */
	Terminal.prototype.deviceStatus = function (params) {
	    if (!this.prefix) {
	        switch (params[0]) {
	            case 5:
	                // status report
	                this.send('\x1b[0n');
	                break;
	            case 6:
	                // cursor position
	                this.send('\x1b['
	                    + (this.y + 1)
	                    + ';'
	                    + (this.x + 1)
	                    + 'R');
	                break;
	        }
	    }
	    else if (this.prefix === '?') {
	        // modern xterm doesnt seem to
	        // respond to any of these except ?6, 6, and 5
	        switch (params[0]) {
	            case 6:
	                // cursor position
	                this.send('\x1b[?'
	                    + (this.y + 1)
	                    + ';'
	                    + (this.x + 1)
	                    + 'R');
	                break;
	            case 15:
	                // no printer
	                // this.send('\x1b[?11n');
	                break;
	            case 25:
	                // dont support user defined keys
	                // this.send('\x1b[?21n');
	                break;
	            case 26:
	                // north american keyboard
	                // this.send('\x1b[?27;1;0;0n');
	                break;
	            case 53:
	                // no dec locator/mouse
	                // this.send('\x1b[?50n');
	                break;
	        }
	    }
	};
	/**
	 * Additions
	 */
	/**
	 * CSI Ps @
	 * Insert Ps (Blank) Character(s) (default = 1) (ICH).
	 */
	Terminal.prototype.insertChars = function (params) {
	    var param, row, j, ch;
	    param = params[0];
	    if (param < 1)
	        param = 1;
	    row = this.y + this.ybase;
	    j = this.x;
	    ch = [this.eraseAttr(), ' ', 1]; // xterm
	    while (param-- && j < this.cols) {
	        this.lines[row].splice(j++, 0, ch);
	        this.lines[row].pop();
	    }
	};
	/**
	 * CSI Ps E
	 * Cursor Next Line Ps Times (default = 1) (CNL).
	 * same as CSI Ps B ?
	 */
	Terminal.prototype.cursorNextLine = function (params) {
	    var param = params[0];
	    if (param < 1)
	        param = 1;
	    this.y += param;
	    if (this.y >= this.rows) {
	        this.y = this.rows - 1;
	    }
	    this.x = 0;
	};
	/**
	 * CSI Ps F
	 * Cursor Preceding Line Ps Times (default = 1) (CNL).
	 * reuse CSI Ps A ?
	 */
	Terminal.prototype.cursorPrecedingLine = function (params) {
	    var param = params[0];
	    if (param < 1)
	        param = 1;
	    this.y -= param;
	    if (this.y < 0)
	        this.y = 0;
	    this.x = 0;
	};
	/**
	 * CSI Ps G
	 * Cursor Character Absolute  [column] (default = [row,1]) (CHA).
	 */
	Terminal.prototype.cursorCharAbsolute = function (params) {
	    var param = params[0];
	    if (param < 1)
	        param = 1;
	    this.x = param - 1;
	};
	/**
	 * CSI Ps L
	 * Insert Ps Line(s) (default = 1) (IL).
	 */
	Terminal.prototype.insertLines = function (params) {
	    var param, row, j;
	    param = params[0];
	    if (param < 1)
	        param = 1;
	    row = this.y + this.ybase;
	    j = this.rows - 1 - this.scrollBottom;
	    j = this.rows - 1 + this.ybase - j + 1;
	    while (param--) {
	        // test: echo -e '\e[44m\e[1L\e[0m'
	        // blankLine(true) - xterm/linux behavior
	        this.lines.splice(row, 0, this.blankLine(true));
	        this.lines.splice(j, 1);
	    }
	    // this.maxRange();
	    this.updateRange(this.y);
	    this.updateRange(this.scrollBottom);
	};
	/**
	 * CSI Ps M
	 * Delete Ps Line(s) (default = 1) (DL).
	 */
	Terminal.prototype.deleteLines = function (params) {
	    var param, row, j;
	    param = params[0];
	    if (param < 1)
	        param = 1;
	    row = this.y + this.ybase;
	    j = this.rows - 1 - this.scrollBottom;
	    j = this.rows - 1 + this.ybase - j;
	    while (param--) {
	        // test: echo -e '\e[44m\e[1M\e[0m'
	        // blankLine(true) - xterm/linux behavior
	        this.lines.splice(j + 1, 0, this.blankLine(true));
	        this.lines.splice(row, 1);
	    }
	    // this.maxRange();
	    this.updateRange(this.y);
	    this.updateRange(this.scrollBottom);
	};
	/**
	 * CSI Ps P
	 * Delete Ps Character(s) (default = 1) (DCH).
	 */
	Terminal.prototype.deleteChars = function (params) {
	    var param, row, ch;
	    param = params[0];
	    if (param < 1)
	        param = 1;
	    row = this.y + this.ybase;
	    ch = [this.eraseAttr(), ' ', 1]; // xterm
	    while (param--) {
	        this.lines[row].splice(this.x, 1);
	        this.lines[row].push(ch);
	    }
	};
	/**
	 * CSI Ps X
	 * Erase Ps Character(s) (default = 1) (ECH).
	 */
	Terminal.prototype.eraseChars = function (params) {
	    var param, row, j, ch;
	    param = params[0];
	    if (param < 1)
	        param = 1;
	    row = this.y + this.ybase;
	    j = this.x;
	    ch = [this.eraseAttr(), ' ', 1]; // xterm
	    while (param-- && j < this.cols) {
	        this.lines[row][j++] = ch;
	    }
	};
	/**
	 * CSI Pm `  Character Position Absolute
	 *   [column] (default = [row,1]) (HPA).
	 */
	Terminal.prototype.charPosAbsolute = function (params) {
	    var param = params[0];
	    if (param < 1)
	        param = 1;
	    this.x = param - 1;
	    if (this.x >= this.cols) {
	        this.x = this.cols - 1;
	    }
	};
	/**
	 * 141 61 a * HPR -
	 * Horizontal Position Relative
	 * reuse CSI Ps C ?
	 */
	Terminal.prototype.HPositionRelative = function (params) {
	    var param = params[0];
	    if (param < 1)
	        param = 1;
	    this.x += param;
	    if (this.x >= this.cols) {
	        this.x = this.cols - 1;
	    }
	};
	/**
	 * CSI Ps c  Send Device Attributes (Primary DA).
	 *     Ps = 0  or omitted -> request attributes from terminal.  The
	 *     response depends on the decTerminalID resource setting.
	 *     -> CSI ? 1 ; 2 c  (``VT100 with Advanced Video Option'')
	 *     -> CSI ? 1 ; 0 c  (``VT101 with No Options'')
	 *     -> CSI ? 6 c  (``VT102'')
	 *     -> CSI ? 6 0 ; 1 ; 2 ; 6 ; 8 ; 9 ; 1 5 ; c  (``VT220'')
	 *   The VT100-style response parameters do not mean anything by
	 *   themselves.  VT220 parameters do, telling the host what fea-
	 *   tures the terminal supports:
	 *     Ps = 1  -> 132-columns.
	 *     Ps = 2  -> Printer.
	 *     Ps = 6  -> Selective erase.
	 *     Ps = 8  -> User-defined keys.
	 *     Ps = 9  -> National replacement character sets.
	 *     Ps = 1 5  -> Technical characters.
	 *     Ps = 2 2  -> ANSI color, e.g., VT525.
	 *     Ps = 2 9  -> ANSI text locator (i.e., DEC Locator mode).
	 * CSI > Ps c
	 *   Send Device Attributes (Secondary DA).
	 *     Ps = 0  or omitted -> request the terminal's identification
	 *     code.  The response depends on the decTerminalID resource set-
	 *     ting.  It should apply only to VT220 and up, but xterm extends
	 *     this to VT100.
	 *     -> CSI  > Pp ; Pv ; Pc c
	 *   where Pp denotes the terminal type
	 *     Pp = 0  -> ``VT100''.
	 *     Pp = 1  -> ``VT220''.
	 *   and Pv is the firmware version (for xterm, this was originally
	 *   the XFree86 patch number, starting with 95).  In a DEC termi-
	 *   nal, Pc indicates the ROM cartridge registration number and is
	 *   always zero.
	 * More information:
	 *   xterm/charproc.c - line 2012, for more information.
	 *   vim responds with ^[[?0c or ^[[?1c after the terminal's response (?)
	 */
	Terminal.prototype.sendDeviceAttributes = function (params) {
	    if (params[0] > 0)
	        return;
	    if (!this.prefix) {
	        if (this.is('xterm')
	            || this.is('rxvt-unicode')
	            || this.is('screen')) {
	            this.send('\x1b[?1;2c');
	        }
	        else if (this.is('linux')) {
	            this.send('\x1b[?6c');
	        }
	    }
	    else if (this.prefix === '>') {
	        // xterm and urxvt
	        // seem to spit this
	        // out around ~370 times (?).
	        if (this.is('xterm')) {
	            this.send('\x1b[>0;276;0c');
	        }
	        else if (this.is('rxvt-unicode')) {
	            this.send('\x1b[>85;95;0c');
	        }
	        else if (this.is('linux')) {
	            // not supported by linux console.
	            // linux console echoes parameters.
	            this.send(params[0] + 'c');
	        }
	        else if (this.is('screen')) {
	            this.send('\x1b[>83;40003;0c');
	        }
	    }
	};
	/**
	 * CSI Pm d
	 * Line Position Absolute  [row] (default = [1,column]) (VPA).
	 */
	Terminal.prototype.linePosAbsolute = function (params) {
	    var param = params[0];
	    if (param < 1)
	        param = 1;
	    this.y = param - 1;
	    if (this.y >= this.rows) {
	        this.y = this.rows - 1;
	    }
	};
	/**
	 * 145 65 e * VPR - Vertical Position Relative
	 * reuse CSI Ps B ?
	 */
	Terminal.prototype.VPositionRelative = function (params) {
	    var param = params[0];
	    if (param < 1)
	        param = 1;
	    this.y += param;
	    if (this.y >= this.rows) {
	        this.y = this.rows - 1;
	    }
	};
	/**
	 * CSI Ps ; Ps f
	 *   Horizontal and Vertical Position [row;column] (default =
	 *   [1,1]) (HVP).
	 */
	Terminal.prototype.HVPosition = function (params) {
	    if (params[0] < 1)
	        params[0] = 1;
	    if (params[1] < 1)
	        params[1] = 1;
	    this.y = params[0] - 1;
	    if (this.y >= this.rows) {
	        this.y = this.rows - 1;
	    }
	    this.x = params[1] - 1;
	    if (this.x >= this.cols) {
	        this.x = this.cols - 1;
	    }
	};
	/**
	 * CSI Pm h  Set Mode (SM).
	 *     Ps = 2  -> Keyboard Action Mode (AM).
	 *     Ps = 4  -> Insert Mode (IRM).
	 *     Ps = 1 2  -> Send/receive (SRM).
	 *     Ps = 2 0  -> Automatic Newline (LNM).
	 * CSI ? Pm h
	 *   DEC Private Mode Set (DECSET).
	 *     Ps = 1  -> Application Cursor Keys (DECCKM).
	 *     Ps = 2  -> Designate USASCII for character sets G0-G3
	 *     (DECANM), and set VT100 mode.
	 *     Ps = 3  -> 132 Column Mode (DECCOLM).
	 *     Ps = 4  -> Smooth (Slow) Scroll (DECSCLM).
	 *     Ps = 5  -> Reverse Video (DECSCNM).
	 *     Ps = 6  -> Origin Mode (DECOM).
	 *     Ps = 7  -> Wraparound Mode (DECAWM).
	 *     Ps = 8  -> Auto-repeat Keys (DECARM).
	 *     Ps = 9  -> Send Mouse X & Y on button press.  See the sec-
	 *     tion Mouse Tracking.
	 *     Ps = 1 0  -> Show toolbar (rxvt).
	 *     Ps = 1 2  -> Start Blinking Cursor (att610).
	 *     Ps = 1 8  -> Print form feed (DECPFF).
	 *     Ps = 1 9  -> Set print extent to full screen (DECPEX).
	 *     Ps = 2 5  -> Show Cursor (DECTCEM).
	 *     Ps = 3 0  -> Show scrollbar (rxvt).
	 *     Ps = 3 5  -> Enable font-shifting functions (rxvt).
	 *     Ps = 3 8  -> Enter Tektronix Mode (DECTEK).
	 *     Ps = 4 0  -> Allow 80 -> 132 Mode.
	 *     Ps = 4 1  -> more(1) fix (see curses resource).
	 *     Ps = 4 2  -> Enable Nation Replacement Character sets (DECN-
	 *     RCM).
	 *     Ps = 4 4  -> Turn On Margin Bell.
	 *     Ps = 4 5  -> Reverse-wraparound Mode.
	 *     Ps = 4 6  -> Start Logging.  This is normally disabled by a
	 *     compile-time option.
	 *     Ps = 4 7  -> Use Alternate Screen Buffer.  (This may be dis-
	 *     abled by the titeInhibit resource).
	 *     Ps = 6 6  -> Application keypad (DECNKM).
	 *     Ps = 6 7  -> Backarrow key sends backspace (DECBKM).
	 *     Ps = 1 0 0 0  -> Send Mouse X & Y on button press and
	 *     release.  See the section Mouse Tracking.
	 *     Ps = 1 0 0 1  -> Use Hilite Mouse Tracking.
	 *     Ps = 1 0 0 2  -> Use Cell Motion Mouse Tracking.
	 *     Ps = 1 0 0 3  -> Use All Motion Mouse Tracking.
	 *     Ps = 1 0 0 4  -> Send FocusIn/FocusOut events.
	 *     Ps = 1 0 0 5  -> Enable Extended Mouse Mode.
	 *     Ps = 1 0 1 0  -> Scroll to bottom on tty output (rxvt).
	 *     Ps = 1 0 1 1  -> Scroll to bottom on key press (rxvt).
	 *     Ps = 1 0 3 4  -> Interpret "meta" key, sets eighth bit.
	 *     (enables the eightBitInput resource).
	 *     Ps = 1 0 3 5  -> Enable special modifiers for Alt and Num-
	 *     Lock keys.  (This enables the numLock resource).
	 *     Ps = 1 0 3 6  -> Send ESC   when Meta modifies a key.  (This
	 *     enables the metaSendsEscape resource).
	 *     Ps = 1 0 3 7  -> Send DEL from the editing-keypad Delete
	 *     key.
	 *     Ps = 1 0 3 9  -> Send ESC  when Alt modifies a key.  (This
	 *     enables the altSendsEscape resource).
	 *     Ps = 1 0 4 0  -> Keep selection even if not highlighted.
	 *     (This enables the keepSelection resource).
	 *     Ps = 1 0 4 1  -> Use the CLIPBOARD selection.  (This enables
	 *     the selectToClipboard resource).
	 *     Ps = 1 0 4 2  -> Enable Urgency window manager hint when
	 *     Control-G is received.  (This enables the bellIsUrgent
	 *     resource).
	 *     Ps = 1 0 4 3  -> Enable raising of the window when Control-G
	 *     is received.  (enables the popOnBell resource).
	 *     Ps = 1 0 4 7  -> Use Alternate Screen Buffer.  (This may be
	 *     disabled by the titeInhibit resource).
	 *     Ps = 1 0 4 8  -> Save cursor as in DECSC.  (This may be dis-
	 *     abled by the titeInhibit resource).
	 *     Ps = 1 0 4 9  -> Save cursor as in DECSC and use Alternate
	 *     Screen Buffer, clearing it first.  (This may be disabled by
	 *     the titeInhibit resource).  This combines the effects of the 1
	 *     0 4 7  and 1 0 4 8  modes.  Use this with terminfo-based
	 *     applications rather than the 4 7  mode.
	 *     Ps = 1 0 5 0  -> Set terminfo/termcap function-key mode.
	 *     Ps = 1 0 5 1  -> Set Sun function-key mode.
	 *     Ps = 1 0 5 2  -> Set HP function-key mode.
	 *     Ps = 1 0 5 3  -> Set SCO function-key mode.
	 *     Ps = 1 0 6 0  -> Set legacy keyboard emulation (X11R6).
	 *     Ps = 1 0 6 1  -> Set VT220 keyboard emulation.
	 *     Ps = 2 0 0 4  -> Set bracketed paste mode.
	 * Modes:
	 *   http: *vt100.net/docs/vt220-rm/chapter4.html
	 */
	Terminal.prototype.setMode = function (params) {
	    if (typeof params === 'object') {
	        var l = params.length, i = 0;
	        for (; i < l; i++) {
	            this.setMode(params[i]);
	        }
	        return;
	    }
	    if (!this.prefix) {
	        switch (params) {
	            case 4:
	                this.insertMode = true;
	                break;
	            case 20:
	                //this.convertEol = true;
	                break;
	        }
	    }
	    else if (this.prefix === '?') {
	        switch (params) {
	            case 1:
	                this.applicationCursor = true;
	                break;
	            case 2:
	                this.setgCharset(0, Terminal.charsets.US);
	                this.setgCharset(1, Terminal.charsets.US);
	                this.setgCharset(2, Terminal.charsets.US);
	                this.setgCharset(3, Terminal.charsets.US);
	                // set VT100 mode here
	                break;
	            case 3:
	                this.savedCols = this.cols;
	                this.resize(132, this.rows);
	                break;
	            case 6:
	                this.originMode = true;
	                break;
	            case 7:
	                this.wraparoundMode = true;
	                break;
	            case 12:
	                // this.cursorBlink = true;
	                break;
	            case 66:
	                this.log('Serial port requested application keypad.');
	                this.applicationKeypad = true;
	                this.viewport.syncScrollArea();
	                break;
	            case 9: // X10 Mouse
	            // no release, no motion, no wheel, no modifiers.
	            case 1000: // vt200 mouse
	            // no motion.
	            // no modifiers, except control on the wheel.
	            case 1002: // button event mouse
	            case 1003:
	                // any event - sends motion events,
	                // even if there is no button held down.
	                this.x10Mouse = params === 9;
	                this.vt200Mouse = params === 1000;
	                this.normalMouse = params > 1000;
	                this.mouseEvents = true;
	                this.element.style.cursor = 'default';
	                this.log('Binding to mouse events.');
	                break;
	            case 1004:
	                // focusin: ^[[I
	                // focusout: ^[[O
	                this.sendFocus = true;
	                break;
	            case 1005:
	                this.utfMouse = true;
	                // for wide terminals
	                // simply encodes large values as utf8 characters
	                break;
	            case 1006:
	                this.sgrMouse = true;
	                // for wide terminals
	                // does not add 32 to fields
	                // press: ^[[<b;x;yM
	                // release: ^[[<b;x;ym
	                break;
	            case 1015:
	                this.urxvtMouse = true;
	                // for wide terminals
	                // numbers for fields
	                // press: ^[[b;x;yM
	                // motion: ^[[b;x;yT
	                break;
	            case 25:
	                this.cursorHidden = false;
	                break;
	            case 1049:
	                //this.saveCursor();
	                ; // FALL-THROUGH
	            case 47: // alt screen buffer
	            case 1047:
	                if (!this.normal) {
	                    var normal = {
	                        lines: this.lines,
	                        ybase: this.ybase,
	                        ydisp: this.ydisp,
	                        x: this.x,
	                        y: this.y,
	                        scrollTop: this.scrollTop,
	                        scrollBottom: this.scrollBottom,
	                        tabs: this.tabs
	                    };
	                    this.reset();
	                    this.normal = normal;
	                    this.showCursor();
	                }
	                break;
	        }
	    }
	};
	/**
	 * CSI Pm l  Reset Mode (RM).
	 *     Ps = 2  -> Keyboard Action Mode (AM).
	 *     Ps = 4  -> Replace Mode (IRM).
	 *     Ps = 1 2  -> Send/receive (SRM).
	 *     Ps = 2 0  -> Normal Linefeed (LNM).
	 * CSI ? Pm l
	 *   DEC Private Mode Reset (DECRST).
	 *     Ps = 1  -> Normal Cursor Keys (DECCKM).
	 *     Ps = 2  -> Designate VT52 mode (DECANM).
	 *     Ps = 3  -> 80 Column Mode (DECCOLM).
	 *     Ps = 4  -> Jump (Fast) Scroll (DECSCLM).
	 *     Ps = 5  -> Normal Video (DECSCNM).
	 *     Ps = 6  -> Normal Cursor Mode (DECOM).
	 *     Ps = 7  -> No Wraparound Mode (DECAWM).
	 *     Ps = 8  -> No Auto-repeat Keys (DECARM).
	 *     Ps = 9  -> Don't send Mouse X & Y on button press.
	 *     Ps = 1 0  -> Hide toolbar (rxvt).
	 *     Ps = 1 2  -> Stop Blinking Cursor (att610).
	 *     Ps = 1 8  -> Don't print form feed (DECPFF).
	 *     Ps = 1 9  -> Limit print to scrolling region (DECPEX).
	 *     Ps = 2 5  -> Hide Cursor (DECTCEM).
	 *     Ps = 3 0  -> Don't show scrollbar (rxvt).
	 *     Ps = 3 5  -> Disable font-shifting functions (rxvt).
	 *     Ps = 4 0  -> Disallow 80 -> 132 Mode.
	 *     Ps = 4 1  -> No more(1) fix (see curses resource).
	 *     Ps = 4 2  -> Disable Nation Replacement Character sets (DEC-
	 *     NRCM).
	 *     Ps = 4 4  -> Turn Off Margin Bell.
	 *     Ps = 4 5  -> No Reverse-wraparound Mode.
	 *     Ps = 4 6  -> Stop Logging.  (This is normally disabled by a
	 *     compile-time option).
	 *     Ps = 4 7  -> Use Normal Screen Buffer.
	 *     Ps = 6 6  -> Numeric keypad (DECNKM).
	 *     Ps = 6 7  -> Backarrow key sends delete (DECBKM).
	 *     Ps = 1 0 0 0  -> Don't send Mouse X & Y on button press and
	 *     release.  See the section Mouse Tracking.
	 *     Ps = 1 0 0 1  -> Don't use Hilite Mouse Tracking.
	 *     Ps = 1 0 0 2  -> Don't use Cell Motion Mouse Tracking.
	 *     Ps = 1 0 0 3  -> Don't use All Motion Mouse Tracking.
	 *     Ps = 1 0 0 4  -> Don't send FocusIn/FocusOut events.
	 *     Ps = 1 0 0 5  -> Disable Extended Mouse Mode.
	 *     Ps = 1 0 1 0  -> Don't scroll to bottom on tty output
	 *     (rxvt).
	 *     Ps = 1 0 1 1  -> Don't scroll to bottom on key press (rxvt).
	 *     Ps = 1 0 3 4  -> Don't interpret "meta" key.  (This disables
	 *     the eightBitInput resource).
	 *     Ps = 1 0 3 5  -> Disable special modifiers for Alt and Num-
	 *     Lock keys.  (This disables the numLock resource).
	 *     Ps = 1 0 3 6  -> Don't send ESC  when Meta modifies a key.
	 *     (This disables the metaSendsEscape resource).
	 *     Ps = 1 0 3 7  -> Send VT220 Remove from the editing-keypad
	 *     Delete key.
	 *     Ps = 1 0 3 9  -> Don't send ESC  when Alt modifies a key.
	 *     (This disables the altSendsEscape resource).
	 *     Ps = 1 0 4 0  -> Do not keep selection when not highlighted.
	 *     (This disables the keepSelection resource).
	 *     Ps = 1 0 4 1  -> Use the PRIMARY selection.  (This disables
	 *     the selectToClipboard resource).
	 *     Ps = 1 0 4 2  -> Disable Urgency window manager hint when
	 *     Control-G is received.  (This disables the bellIsUrgent
	 *     resource).
	 *     Ps = 1 0 4 3  -> Disable raising of the window when Control-
	 *     G is received.  (This disables the popOnBell resource).
	 *     Ps = 1 0 4 7  -> Use Normal Screen Buffer, clearing screen
	 *     first if in the Alternate Screen.  (This may be disabled by
	 *     the titeInhibit resource).
	 *     Ps = 1 0 4 8  -> Restore cursor as in DECRC.  (This may be
	 *     disabled by the titeInhibit resource).
	 *     Ps = 1 0 4 9  -> Use Normal Screen Buffer and restore cursor
	 *     as in DECRC.  (This may be disabled by the titeInhibit
	 *     resource).  This combines the effects of the 1 0 4 7  and 1 0
	 *     4 8  modes.  Use this with terminfo-based applications rather
	 *     than the 4 7  mode.
	 *     Ps = 1 0 5 0  -> Reset terminfo/termcap function-key mode.
	 *     Ps = 1 0 5 1  -> Reset Sun function-key mode.
	 *     Ps = 1 0 5 2  -> Reset HP function-key mode.
	 *     Ps = 1 0 5 3  -> Reset SCO function-key mode.
	 *     Ps = 1 0 6 0  -> Reset legacy keyboard emulation (X11R6).
	 *     Ps = 1 0 6 1  -> Reset keyboard emulation to Sun/PC style.
	 *     Ps = 2 0 0 4  -> Reset bracketed paste mode.
	 */
	Terminal.prototype.resetMode = function (params) {
	    if (typeof params === 'object') {
	        var l = params.length, i = 0;
	        for (; i < l; i++) {
	            this.resetMode(params[i]);
	        }
	        return;
	    }
	    if (!this.prefix) {
	        switch (params) {
	            case 4:
	                this.insertMode = false;
	                break;
	            case 20:
	                //this.convertEol = false;
	                break;
	        }
	    }
	    else if (this.prefix === '?') {
	        switch (params) {
	            case 1:
	                this.applicationCursor = false;
	                break;
	            case 3:
	                if (this.cols === 132 && this.savedCols) {
	                    this.resize(this.savedCols, this.rows);
	                }
	                delete this.savedCols;
	                break;
	            case 6:
	                this.originMode = false;
	                break;
	            case 7:
	                this.wraparoundMode = false;
	                break;
	            case 12:
	                // this.cursorBlink = false;
	                break;
	            case 66:
	                this.log('Switching back to normal keypad.');
	                this.applicationKeypad = false;
	                this.viewport.syncScrollArea();
	                break;
	            case 9: // X10 Mouse
	            case 1000: // vt200 mouse
	            case 1002: // button event mouse
	            case 1003:
	                this.x10Mouse = false;
	                this.vt200Mouse = false;
	                this.normalMouse = false;
	                this.mouseEvents = false;
	                this.element.style.cursor = '';
	                break;
	            case 1004:
	                this.sendFocus = false;
	                break;
	            case 1005:
	                this.utfMouse = false;
	                break;
	            case 1006:
	                this.sgrMouse = false;
	                break;
	            case 1015:
	                this.urxvtMouse = false;
	                break;
	            case 25:
	                this.cursorHidden = true;
	                break;
	            case 1049:
	                ; // FALL-THROUGH
	            case 47: // normal screen buffer
	            case 1047:
	                if (this.normal) {
	                    this.lines = this.normal.lines;
	                    this.ybase = this.normal.ybase;
	                    this.ydisp = this.normal.ydisp;
	                    this.x = this.normal.x;
	                    this.y = this.normal.y;
	                    this.scrollTop = this.normal.scrollTop;
	                    this.scrollBottom = this.normal.scrollBottom;
	                    this.tabs = this.normal.tabs;
	                    this.normal = null;
	                    // if (params === 1049) {
	                    //   this.x = this.savedX;
	                    //   this.y = this.savedY;
	                    // }
	                    this.refresh(0, this.rows - 1);
	                    this.showCursor();
	                }
	                break;
	        }
	    }
	};
	/**
	 * CSI Ps ; Ps r
	 *   Set Scrolling Region [top;bottom] (default = full size of win-
	 *   dow) (DECSTBM).
	 * CSI ? Pm r
	 */
	Terminal.prototype.setScrollRegion = function (params) {
	    if (this.prefix)
	        return;
	    this.scrollTop = (params[0] || 1) - 1;
	    this.scrollBottom = (params[1] || this.rows) - 1;
	    this.x = 0;
	    this.y = 0;
	};
	/**
	 * CSI s
	 *   Save cursor (ANSI.SYS).
	 */
	Terminal.prototype.saveCursor = function (params) {
	    this.savedX = this.x;
	    this.savedY = this.y;
	};
	/**
	 * CSI u
	 *   Restore cursor (ANSI.SYS).
	 */
	Terminal.prototype.restoreCursor = function (params) {
	    this.x = this.savedX || 0;
	    this.y = this.savedY || 0;
	};
	/**
	 * Lesser Used
	 */
	/**
	 * CSI Ps I
	 *   Cursor Forward Tabulation Ps tab stops (default = 1) (CHT).
	 */
	Terminal.prototype.cursorForwardTab = function (params) {
	    var param = params[0] || 1;
	    while (param--) {
	        this.x = this.nextStop();
	    }
	};
	/**
	 * CSI Ps S  Scroll up Ps lines (default = 1) (SU).
	 */
	Terminal.prototype.scrollUp = function (params) {
	    var param = params[0] || 1;
	    while (param--) {
	        this.lines.splice(this.ybase + this.scrollTop, 1);
	        this.lines.splice(this.ybase + this.scrollBottom, 0, this.blankLine());
	    }
	    // this.maxRange();
	    this.updateRange(this.scrollTop);
	    this.updateRange(this.scrollBottom);
	};
	/**
	 * CSI Ps T  Scroll down Ps lines (default = 1) (SD).
	 */
	Terminal.prototype.scrollDown = function (params) {
	    var param = params[0] || 1;
	    while (param--) {
	        this.lines.splice(this.ybase + this.scrollBottom, 1);
	        this.lines.splice(this.ybase + this.scrollTop, 0, this.blankLine());
	    }
	    // this.maxRange();
	    this.updateRange(this.scrollTop);
	    this.updateRange(this.scrollBottom);
	};
	/**
	 * CSI Ps ; Ps ; Ps ; Ps ; Ps T
	 *   Initiate highlight mouse tracking.  Parameters are
	 *   [func;startx;starty;firstrow;lastrow].  See the section Mouse
	 *   Tracking.
	 */
	Terminal.prototype.initMouseTracking = function (params) {
	    // Relevant: DECSET 1001
	};
	/**
	 * CSI > Ps; Ps T
	 *   Reset one or more features of the title modes to the default
	 *   value.  Normally, "reset" disables the feature.  It is possi-
	 *   ble to disable the ability to reset features by compiling a
	 *   different default for the title modes into xterm.
	 *     Ps = 0  -> Do not set window/icon labels using hexadecimal.
	 *     Ps = 1  -> Do not query window/icon labels using hexadeci-
	 *     mal.
	 *     Ps = 2  -> Do not set window/icon labels using UTF-8.
	 *     Ps = 3  -> Do not query window/icon labels using UTF-8.
	 *   (See discussion of "Title Modes").
	 */
	Terminal.prototype.resetTitleModes = function (params) {
	    ;
	};
	/**
	 * CSI Ps Z  Cursor Backward Tabulation Ps tab stops (default = 1) (CBT).
	 */
	Terminal.prototype.cursorBackwardTab = function (params) {
	    var param = params[0] || 1;
	    while (param--) {
	        this.x = this.prevStop();
	    }
	};
	/**
	 * CSI Ps b  Repeat the preceding graphic character Ps times (REP).
	 */
	Terminal.prototype.repeatPrecedingCharacter = function (params) {
	    var param = params[0] || 1, line = this.lines[this.ybase + this.y], ch = line[this.x - 1] || [this.defAttr, ' ', 1];
	    while (param--)
	        line[this.x++] = ch;
	};
	/**
	 * CSI Ps g  Tab Clear (TBC).
	 *     Ps = 0  -> Clear Current Column (default).
	 *     Ps = 3  -> Clear All.
	 * Potentially:
	 *   Ps = 2  -> Clear Stops on Line.
	 *   http://vt100.net/annarbor/aaa-ug/section6.html
	 */
	Terminal.prototype.tabClear = function (params) {
	    var param = params[0];
	    if (param <= 0) {
	        delete this.tabs[this.x];
	    }
	    else if (param === 3) {
	        this.tabs = {};
	    }
	};
	/**
	 * CSI Pm i  Media Copy (MC).
	 *     Ps = 0  -> Print screen (default).
	 *     Ps = 4  -> Turn off printer controller mode.
	 *     Ps = 5  -> Turn on printer controller mode.
	 * CSI ? Pm i
	 *   Media Copy (MC, DEC-specific).
	 *     Ps = 1  -> Print line containing cursor.
	 *     Ps = 4  -> Turn off autoprint mode.
	 *     Ps = 5  -> Turn on autoprint mode.
	 *     Ps = 1  0  -> Print composed display, ignores DECPEX.
	 *     Ps = 1  1  -> Print all pages.
	 */
	Terminal.prototype.mediaCopy = function (params) {
	    ;
	};
	/**
	 * CSI > Ps; Ps m
	 *   Set or reset resource-values used by xterm to decide whether
	 *   to construct escape sequences holding information about the
	 *   modifiers pressed with a given key.  The first parameter iden-
	 *   tifies the resource to set/reset.  The second parameter is the
	 *   value to assign to the resource.  If the second parameter is
	 *   omitted, the resource is reset to its initial value.
	 *     Ps = 1  -> modifyCursorKeys.
	 *     Ps = 2  -> modifyFunctionKeys.
	 *     Ps = 4  -> modifyOtherKeys.
	 *   If no parameters are given, all resources are reset to their
	 *   initial values.
	 */
	Terminal.prototype.setResources = function (params) {
	    ;
	};
	/**
	 * CSI > Ps n
	 *   Disable modifiers which may be enabled via the CSI > Ps; Ps m
	 *   sequence.  This corresponds to a resource value of "-1", which
	 *   cannot be set with the other sequence.  The parameter identi-
	 *   fies the resource to be disabled:
	 *     Ps = 1  -> modifyCursorKeys.
	 *     Ps = 2  -> modifyFunctionKeys.
	 *     Ps = 4  -> modifyOtherKeys.
	 *   If the parameter is omitted, modifyFunctionKeys is disabled.
	 *   When modifyFunctionKeys is disabled, xterm uses the modifier
	 *   keys to make an extended sequence of functions rather than
	 *   adding a parameter to each function key to denote the modi-
	 *   fiers.
	 */
	Terminal.prototype.disableModifiers = function (params) {
	    ;
	};
	/**
	 * CSI > Ps p
	 *   Set resource value pointerMode.  This is used by xterm to
	 *   decide whether to hide the pointer cursor as the user types.
	 *   Valid values for the parameter:
	 *     Ps = 0  -> never hide the pointer.
	 *     Ps = 1  -> hide if the mouse tracking mode is not enabled.
	 *     Ps = 2  -> always hide the pointer.  If no parameter is
	 *     given, xterm uses the default, which is 1 .
	 */
	Terminal.prototype.setPointerMode = function (params) {
	    ;
	};
	/**
	 * CSI ! p   Soft terminal reset (DECSTR).
	 * http://vt100.net/docs/vt220-rm/table4-10.html
	 */
	Terminal.prototype.softReset = function (params) {
	    this.cursorHidden = false;
	    this.insertMode = false;
	    this.originMode = false;
	    this.wraparoundMode = false; // autowrap
	    this.applicationKeypad = false; // ?
	    this.viewport.syncScrollArea();
	    this.applicationCursor = false;
	    this.scrollTop = 0;
	    this.scrollBottom = this.rows - 1;
	    this.curAttr = this.defAttr;
	    this.x = this.y = 0; // ?
	    this.charset = null;
	    this.glevel = 0; // ??
	    this.charsets = [null]; // ??
	};
	/**
	 * CSI Ps$ p
	 *   Request ANSI mode (DECRQM).  For VT300 and up, reply is
	 *     CSI Ps; Pm$ y
	 *   where Ps is the mode number as in RM, and Pm is the mode
	 *   value:
	 *     0 - not recognized
	 *     1 - set
	 *     2 - reset
	 *     3 - permanently set
	 *     4 - permanently reset
	 */
	Terminal.prototype.requestAnsiMode = function (params) {
	    ;
	};
	/**
	 * CSI ? Ps$ p
	 *   Request DEC private mode (DECRQM).  For VT300 and up, reply is
	 *     CSI ? Ps; Pm$ p
	 *   where Ps is the mode number as in DECSET, Pm is the mode value
	 *   as in the ANSI DECRQM.
	 */
	Terminal.prototype.requestPrivateMode = function (params) {
	    ;
	};
	/**
	 * CSI Ps ; Ps " p
	 *   Set conformance level (DECSCL).  Valid values for the first
	 *   parameter:
	 *     Ps = 6 1  -> VT100.
	 *     Ps = 6 2  -> VT200.
	 *     Ps = 6 3  -> VT300.
	 *   Valid values for the second parameter:
	 *     Ps = 0  -> 8-bit controls.
	 *     Ps = 1  -> 7-bit controls (always set for VT100).
	 *     Ps = 2  -> 8-bit controls.
	 */
	Terminal.prototype.setConformanceLevel = function (params) {
	    ;
	};
	/**
	 * CSI Ps q  Load LEDs (DECLL).
	 *     Ps = 0  -> Clear all LEDS (default).
	 *     Ps = 1  -> Light Num Lock.
	 *     Ps = 2  -> Light Caps Lock.
	 *     Ps = 3  -> Light Scroll Lock.
	 *     Ps = 2  1  -> Extinguish Num Lock.
	 *     Ps = 2  2  -> Extinguish Caps Lock.
	 *     Ps = 2  3  -> Extinguish Scroll Lock.
	 */
	Terminal.prototype.loadLEDs = function (params) {
	    ;
	};
	/**
	 * CSI Ps SP q
	 *   Set cursor style (DECSCUSR, VT520).
	 *     Ps = 0  -> blinking block.
	 *     Ps = 1  -> blinking block (default).
	 *     Ps = 2  -> steady block.
	 *     Ps = 3  -> blinking underline.
	 *     Ps = 4  -> steady underline.
	 */
	Terminal.prototype.setCursorStyle = function (params) {
	    ;
	};
	/**
	 * CSI Ps " q
	 *   Select character protection attribute (DECSCA).  Valid values
	 *   for the parameter:
	 *     Ps = 0  -> DECSED and DECSEL can erase (default).
	 *     Ps = 1  -> DECSED and DECSEL cannot erase.
	 *     Ps = 2  -> DECSED and DECSEL can erase.
	 */
	Terminal.prototype.setCharProtectionAttr = function (params) {
	    ;
	};
	/**
	 * CSI ? Pm r
	 *   Restore DEC Private Mode Values.  The value of Ps previously
	 *   saved is restored.  Ps values are the same as for DECSET.
	 */
	Terminal.prototype.restorePrivateValues = function (params) {
	    ;
	};
	/**
	 * CSI Pt; Pl; Pb; Pr; Ps$ r
	 *   Change Attributes in Rectangular Area (DECCARA), VT400 and up.
	 *     Pt; Pl; Pb; Pr denotes the rectangle.
	 *     Ps denotes the SGR attributes to change: 0, 1, 4, 5, 7.
	 * NOTE: xterm doesn't enable this code by default.
	 */
	Terminal.prototype.setAttrInRectangle = function (params) {
	    var t = params[0], l = params[1], b = params[2], r = params[3], attr = params[4];
	    var line, i;
	    for (; t < b + 1; t++) {
	        line = this.lines[this.ybase + t];
	        for (i = l; i < r; i++) {
	            line[i] = [attr, line[i][1]];
	        }
	    }
	    // this.maxRange();
	    this.updateRange(params[0]);
	    this.updateRange(params[2]);
	};
	/**
	 * CSI Pc; Pt; Pl; Pb; Pr$ x
	 *   Fill Rectangular Area (DECFRA), VT420 and up.
	 *     Pc is the character to use.
	 *     Pt; Pl; Pb; Pr denotes the rectangle.
	 * NOTE: xterm doesn't enable this code by default.
	 */
	Terminal.prototype.fillRectangle = function (params) {
	    var ch = params[0], t = params[1], l = params[2], b = params[3], r = params[4];
	    var line, i;
	    for (; t < b + 1; t++) {
	        line = this.lines[this.ybase + t];
	        for (i = l; i < r; i++) {
	            line[i] = [line[i][0], String.fromCharCode(ch)];
	        }
	    }
	    // this.maxRange();
	    this.updateRange(params[1]);
	    this.updateRange(params[3]);
	};
	/**
	 * CSI Ps ; Pu ' z
	 *   Enable Locator Reporting (DECELR).
	 *   Valid values for the first parameter:
	 *     Ps = 0  -> Locator disabled (default).
	 *     Ps = 1  -> Locator enabled.
	 *     Ps = 2  -> Locator enabled for one report, then disabled.
	 *   The second parameter specifies the coordinate unit for locator
	 *   reports.
	 *   Valid values for the second parameter:
	 *     Pu = 0  <- or omitted -> default to character cells.
	 *     Pu = 1  <- device physical pixels.
	 *     Pu = 2  <- character cells.
	 */
	Terminal.prototype.enableLocatorReporting = function (params) {
	    var val = params[0] > 0;
	    //this.mouseEvents = val;
	    //this.decLocator = val;
	};
	/**
	 * CSI Pt; Pl; Pb; Pr$ z
	 *   Erase Rectangular Area (DECERA), VT400 and up.
	 *     Pt; Pl; Pb; Pr denotes the rectangle.
	 * NOTE: xterm doesn't enable this code by default.
	 */
	Terminal.prototype.eraseRectangle = function (params) {
	    var t = params[0], l = params[1], b = params[2], r = params[3];
	    var line, i, ch;
	    ch = [this.eraseAttr(), ' ', 1]; // xterm?
	    for (; t < b + 1; t++) {
	        line = this.lines[this.ybase + t];
	        for (i = l; i < r; i++) {
	            line[i] = ch;
	        }
	    }
	    // this.maxRange();
	    this.updateRange(params[0]);
	    this.updateRange(params[2]);
	};
	/**
	 * CSI P m SP }
	 * Insert P s Column(s) (default = 1) (DECIC), VT420 and up.
	 * NOTE: xterm doesn't enable this code by default.
	 */
	Terminal.prototype.insertColumns = function () {
	    var param = params[0], l = this.ybase + this.rows, ch = [this.eraseAttr(), ' ', 1] // xterm?
	    , i;
	    while (param--) {
	        for (i = this.ybase; i < l; i++) {
	            this.lines[i].splice(this.x + 1, 0, ch);
	            this.lines[i].pop();
	        }
	    }
	    this.maxRange();
	};
	/**
	 * CSI P m SP ~
	 * Delete P s Column(s) (default = 1) (DECDC), VT420 and up
	 * NOTE: xterm doesn't enable this code by default.
	 */
	Terminal.prototype.deleteColumns = function () {
	    var param = params[0], l = this.ybase + this.rows, ch = [this.eraseAttr(), ' ', 1] // xterm?
	    , i;
	    while (param--) {
	        for (i = this.ybase; i < l; i++) {
	            this.lines[i].splice(this.x, 1);
	            this.lines[i].push(ch);
	        }
	    }
	    this.maxRange();
	};
	/**
	 * Character Sets
	 */
	Terminal.charsets = {};
	// DEC Special Character and Line Drawing Set.
	// http://vt100.net/docs/vt102-ug/table5-13.html
	// A lot of curses apps use this if they see TERM=xterm.
	// testing: echo -e '\e(0a\e(B'
	// The xterm output sometimes seems to conflict with the
	// reference above. xterm seems in line with the reference
	// when running vttest however.
	// The table below now uses xterm's output from vttest.
	Terminal.charsets.SCLD = {
	    '`': '\u25c6',
	    'a': '\u2592',
	    'b': '\u0009',
	    'c': '\u000c',
	    'd': '\u000d',
	    'e': '\u000a',
	    'f': '\u00b0',
	    'g': '\u00b1',
	    'h': '\u2424',
	    'i': '\u000b',
	    'j': '\u2518',
	    'k': '\u2510',
	    'l': '\u250c',
	    'm': '\u2514',
	    'n': '\u253c',
	    'o': '\u23ba',
	    'p': '\u23bb',
	    'q': '\u2500',
	    'r': '\u23bc',
	    's': '\u23bd',
	    't': '\u251c',
	    'u': '\u2524',
	    'v': '\u2534',
	    'w': '\u252c',
	    'x': '\u2502',
	    'y': '\u2264',
	    'z': '\u2265',
	    '{': '\u03c0',
	    '|': '\u2260',
	    '}': '\u00a3',
	    '~': '\u00b7' // ''
	};
	Terminal.charsets.UK = null; // (A
	Terminal.charsets.US = null; // (B (USASCII)
	Terminal.charsets.Dutch = null; // (4
	Terminal.charsets.Finnish = null; // (C or (5
	Terminal.charsets.French = null; // (R
	Terminal.charsets.FrenchCanadian = null; // (Q
	Terminal.charsets.German = null; // (K
	Terminal.charsets.Italian = null; // (Y
	Terminal.charsets.NorwegianDanish = null; // (E or (6
	Terminal.charsets.Spanish = null; // (Z
	Terminal.charsets.Swedish = null; // (H or (7
	Terminal.charsets.Swiss = null; // (=
	Terminal.charsets.ISOLatin = null; // /A
	/**
	 * Helpers
	 */
	function on(el, type, handler, capture) {
	    if (!Array.isArray(el)) {
	        el = [el];
	    }
	    el.forEach(function (element) {
	        element.addEventListener(type, handler, capture || false);
	    });
	}
	function off(el, type, handler, capture) {
	    el.removeEventListener(type, handler, capture || false);
	}
	function cancel(ev, force) {
	    if (!this.cancelEvents && !force) {
	        return;
	    }
	    ev.preventDefault();
	    ev.stopPropagation();
	    return false;
	}
	function inherits(child, parent) {
	    function f() {
	        this.constructor = child;
	    }
	    f.prototype = parent.prototype;
	    child.prototype = new f;
	}
	// if bold is broken, we can't
	// use it in the terminal.
	function isBoldBroken(document) {
	    var body = document.getElementsByTagName('body')[0];
	    var el = document.createElement('span');
	    el.innerHTML = 'hello world';
	    body.appendChild(el);
	    var w1 = el.scrollWidth;
	    el.style.fontWeight = 'bold';
	    var w2 = el.scrollWidth;
	    body.removeChild(el);
	    return w1 !== w2;
	}
	function indexOf(obj, el) {
	    var i = obj.length;
	    while (i--) {
	        if (obj[i] === el)
	            return i;
	    }
	    return -1;
	}
	function isThirdLevelShift(term, ev) {
	    var thirdLevelKey = (term.browser.isMac && ev.altKey && !ev.ctrlKey && !ev.metaKey) ||
	        (term.browser.isMSWindows && ev.altKey && ev.ctrlKey && !ev.metaKey);
	    if (ev.type == 'keypress') {
	        return thirdLevelKey;
	    }
	    // Don't invoke for arrows, pageDown, home, backspace, etc. (on non-keypress events)
	    return thirdLevelKey && (!ev.keyCode || ev.keyCode > 47);
	}
	function matchColor(r1, g1, b1) {
	    var hash = (r1 << 16) | (g1 << 8) | b1;
	    if (matchColor._cache[hash] != null) {
	        return matchColor._cache[hash];
	    }
	    var ldiff = Infinity, li = -1, i = 0, c, r2, g2, b2, diff;
	    for (; i < Terminal.vcolors.length; i++) {
	        c = Terminal.vcolors[i];
	        r2 = c[0];
	        g2 = c[1];
	        b2 = c[2];
	        diff = matchColor.distance(r1, g1, b1, r2, g2, b2);
	        if (diff === 0) {
	            li = i;
	            break;
	        }
	        if (diff < ldiff) {
	            ldiff = diff;
	            li = i;
	        }
	    }
	    return matchColor._cache[hash] = li;
	}
	matchColor._cache = {};
	// http://stackoverflow.com/questions/1633828
	matchColor.distance = function (r1, g1, b1, r2, g2, b2) {
	    return Math.pow(30 * (r1 - r2), 2)
	        + Math.pow(59 * (g1 - g2), 2)
	        + Math.pow(11 * (b1 - b2), 2);
	};
	function each(obj, iter, con) {
	    if (obj.forEach)
	        return obj.forEach(iter, con);
	    for (var i = 0; i < obj.length; i++) {
	        iter.call(con, obj[i], i, obj);
	    }
	}
	function keys(obj) {
	    if (Object.keys)
	        return Object.keys(obj);
	    var key, keys = [];
	    for (key in obj) {
	        if (Object.prototype.hasOwnProperty.call(obj, key)) {
	            keys.push(key);
	        }
	    }
	    return keys;
	}
	var wcwidth = (function (opts) {
	    // extracted from https://www.cl.cam.ac.uk/%7Emgk25/ucs/wcwidth.c
	    // combining characters
	    var COMBINING = [
	        [0x0300, 0x036F], [0x0483, 0x0486], [0x0488, 0x0489],
	        [0x0591, 0x05BD], [0x05BF, 0x05BF], [0x05C1, 0x05C2],
	        [0x05C4, 0x05C5], [0x05C7, 0x05C7], [0x0600, 0x0603],
	        [0x0610, 0x0615], [0x064B, 0x065E], [0x0670, 0x0670],
	        [0x06D6, 0x06E4], [0x06E7, 0x06E8], [0x06EA, 0x06ED],
	        [0x070F, 0x070F], [0x0711, 0x0711], [0x0730, 0x074A],
	        [0x07A6, 0x07B0], [0x07EB, 0x07F3], [0x0901, 0x0902],
	        [0x093C, 0x093C], [0x0941, 0x0948], [0x094D, 0x094D],
	        [0x0951, 0x0954], [0x0962, 0x0963], [0x0981, 0x0981],
	        [0x09BC, 0x09BC], [0x09C1, 0x09C4], [0x09CD, 0x09CD],
	        [0x09E2, 0x09E3], [0x0A01, 0x0A02], [0x0A3C, 0x0A3C],
	        [0x0A41, 0x0A42], [0x0A47, 0x0A48], [0x0A4B, 0x0A4D],
	        [0x0A70, 0x0A71], [0x0A81, 0x0A82], [0x0ABC, 0x0ABC],
	        [0x0AC1, 0x0AC5], [0x0AC7, 0x0AC8], [0x0ACD, 0x0ACD],
	        [0x0AE2, 0x0AE3], [0x0B01, 0x0B01], [0x0B3C, 0x0B3C],
	        [0x0B3F, 0x0B3F], [0x0B41, 0x0B43], [0x0B4D, 0x0B4D],
	        [0x0B56, 0x0B56], [0x0B82, 0x0B82], [0x0BC0, 0x0BC0],
	        [0x0BCD, 0x0BCD], [0x0C3E, 0x0C40], [0x0C46, 0x0C48],
	        [0x0C4A, 0x0C4D], [0x0C55, 0x0C56], [0x0CBC, 0x0CBC],
	        [0x0CBF, 0x0CBF], [0x0CC6, 0x0CC6], [0x0CCC, 0x0CCD],
	        [0x0CE2, 0x0CE3], [0x0D41, 0x0D43], [0x0D4D, 0x0D4D],
	        [0x0DCA, 0x0DCA], [0x0DD2, 0x0DD4], [0x0DD6, 0x0DD6],
	        [0x0E31, 0x0E31], [0x0E34, 0x0E3A], [0x0E47, 0x0E4E],
	        [0x0EB1, 0x0EB1], [0x0EB4, 0x0EB9], [0x0EBB, 0x0EBC],
	        [0x0EC8, 0x0ECD], [0x0F18, 0x0F19], [0x0F35, 0x0F35],
	        [0x0F37, 0x0F37], [0x0F39, 0x0F39], [0x0F71, 0x0F7E],
	        [0x0F80, 0x0F84], [0x0F86, 0x0F87], [0x0F90, 0x0F97],
	        [0x0F99, 0x0FBC], [0x0FC6, 0x0FC6], [0x102D, 0x1030],
	        [0x1032, 0x1032], [0x1036, 0x1037], [0x1039, 0x1039],
	        [0x1058, 0x1059], [0x1160, 0x11FF], [0x135F, 0x135F],
	        [0x1712, 0x1714], [0x1732, 0x1734], [0x1752, 0x1753],
	        [0x1772, 0x1773], [0x17B4, 0x17B5], [0x17B7, 0x17BD],
	        [0x17C6, 0x17C6], [0x17C9, 0x17D3], [0x17DD, 0x17DD],
	        [0x180B, 0x180D], [0x18A9, 0x18A9], [0x1920, 0x1922],
	        [0x1927, 0x1928], [0x1932, 0x1932], [0x1939, 0x193B],
	        [0x1A17, 0x1A18], [0x1B00, 0x1B03], [0x1B34, 0x1B34],
	        [0x1B36, 0x1B3A], [0x1B3C, 0x1B3C], [0x1B42, 0x1B42],
	        [0x1B6B, 0x1B73], [0x1DC0, 0x1DCA], [0x1DFE, 0x1DFF],
	        [0x200B, 0x200F], [0x202A, 0x202E], [0x2060, 0x2063],
	        [0x206A, 0x206F], [0x20D0, 0x20EF], [0x302A, 0x302F],
	        [0x3099, 0x309A], [0xA806, 0xA806], [0xA80B, 0xA80B],
	        [0xA825, 0xA826], [0xFB1E, 0xFB1E], [0xFE00, 0xFE0F],
	        [0xFE20, 0xFE23], [0xFEFF, 0xFEFF], [0xFFF9, 0xFFFB],
	        [0x10A01, 0x10A03], [0x10A05, 0x10A06], [0x10A0C, 0x10A0F],
	        [0x10A38, 0x10A3A], [0x10A3F, 0x10A3F], [0x1D167, 0x1D169],
	        [0x1D173, 0x1D182], [0x1D185, 0x1D18B], [0x1D1AA, 0x1D1AD],
	        [0x1D242, 0x1D244], [0xE0001, 0xE0001], [0xE0020, 0xE007F],
	        [0xE0100, 0xE01EF]
	    ];
	    // binary search
	    function bisearch(ucs) {
	        var min = 0;
	        var max = COMBINING.length - 1;
	        var mid;
	        if (ucs < COMBINING[0][0] || ucs > COMBINING[max][1])
	            return false;
	        while (max >= min) {
	            mid = Math.floor((min + max) / 2);
	            if (ucs > COMBINING[mid][1])
	                min = mid + 1;
	            else if (ucs < COMBINING[mid][0])
	                max = mid - 1;
	            else
	                return true;
	        }
	        return false;
	    }
	    function wcwidth(ucs) {
	        // test for 8-bit control characters
	        if (ucs === 0)
	            return opts.nul;
	        if (ucs < 32 || (ucs >= 0x7f && ucs < 0xa0))
	            return opts.control;
	        // binary search in table of non-spacing characters
	        if (bisearch(ucs))
	            return 0;
	        // if we arrive here, ucs is not a combining or C0/C1 control character
	        return 1 +
	            (ucs >= 0x1100 &&
	                (ucs <= 0x115f ||
	                    ucs == 0x2329 ||
	                    ucs == 0x232a ||
	                    (ucs >= 0x2e80 && ucs <= 0xa4cf && ucs != 0x303f) ||
	                    (ucs >= 0xac00 && ucs <= 0xd7a3) ||
	                    (ucs >= 0xf900 && ucs <= 0xfaff) ||
	                    (ucs >= 0xfe10 && ucs <= 0xfe19) ||
	                    (ucs >= 0xfe30 && ucs <= 0xfe6f) ||
	                    (ucs >= 0xff00 && ucs <= 0xff60) ||
	                    (ucs >= 0xffe0 && ucs <= 0xffe6) ||
	                    (ucs >= 0x20000 && ucs <= 0x2fffd) ||
	                    (ucs >= 0x30000 && ucs <= 0x3fffd)));
	    }
	    return wcwidth;
	})({ nul: 0, control: 0 }); // configurable options
	/**
	 * Expose
	 */
	Terminal.EventEmitter = EventEmitter_js_1.EventEmitter;
	Terminal.inherits = inherits;
	/**
	 * Adds an event listener to the terminal.
	 *
	 * @param {string} event The name of the event. TODO: Document all event types
	 * @param {function} callback The function to call when the event is triggered.
	 */
	Terminal.on = on;
	Terminal.off = off;
	Terminal.cancel = cancel;
	module.exports = Terminal;
	//# sourceMappingURL=xterm.js.map

/***/ },
/* 2 */
/***/ function(module, exports) {

	/**
	 * @license MIT
	 */
	"use strict";
	/**
	 * Encapsulates the logic for handling compositionstart, compositionupdate and compositionend
	 * events, displaying the in-progress composition to the UI and forwarding the final composition
	 * to the handler.
	 */
	var CompositionHelper = (function () {
	    /**
	     * Creates a new CompositionHelper.
	     * @param textarea The textarea that xterm uses for input.
	     * @param compositionView The element to display the in-progress composition in.
	     * @param terminal The Terminal to forward the finished composition to.
	     */
	    function CompositionHelper(textarea, compositionView, terminal) {
	        this.textarea = textarea;
	        this.compositionView = compositionView;
	        this.terminal = terminal;
	        this.isComposing = false;
	        this.isSendingComposition = false;
	        this.compositionPosition = { start: null, end: null };
	    }
	    ;
	    /**
	     * Handles the compositionstart event, activating the composition view.
	     */
	    CompositionHelper.prototype.compositionstart = function () {
	        this.isComposing = true;
	        this.compositionPosition.start = this.textarea.value.length;
	        this.compositionView.textContent = '';
	        this.compositionView.classList.add('active');
	    };
	    /**
	     * Handles the compositionupdate event, updating the composition view.
	     * @param {CompositionEvent} ev The event.
	     */
	    CompositionHelper.prototype.compositionupdate = function (ev) {
	        this.compositionView.textContent = ev.data;
	        this.updateCompositionElements();
	        var self = this;
	        setTimeout(function () {
	            self.compositionPosition.end = self.textarea.value.length;
	        }, 0);
	    };
	    /**
	     * Handles the compositionend event, hiding the composition view and sending the composition to
	     * the handler.
	     */
	    CompositionHelper.prototype.compositionend = function () {
	        this.finalizeComposition(true);
	    };
	    /**
	     * Handles the keydown event, routing any necessary events to the CompositionHelper functions.
	     * @param ev The keydown event.
	     * @return Whether the Terminal should continue processing the keydown event.
	     */
	    CompositionHelper.prototype.keydown = function (ev) {
	        if (this.isComposing || this.isSendingComposition) {
	            if (ev.keyCode === 229) {
	                // Continue composing if the keyCode is the "composition character"
	                return false;
	            }
	            else if (ev.keyCode === 16 || ev.keyCode === 17 || ev.keyCode === 18) {
	                // Continue composing if the keyCode is a modifier key
	                return false;
	            }
	            else {
	                // Finish composition immediately. This is mainly here for the case where enter is
	                // pressed and the handler needs to be triggered before the command is executed.
	                this.finalizeComposition(false);
	            }
	        }
	        if (ev.keyCode === 229) {
	            // If the "composition character" is used but gets to this point it means a non-composition
	            // character (eg. numbers and punctuation) was pressed when the IME was active.
	            this.handleAnyTextareaChanges();
	            return false;
	        }
	        return true;
	    };
	    /**
	     * Finalizes the composition, resuming regular input actions. This is called when a composition
	     * is ending.
	     * @param waitForPropogation Whether to wait for events to propogate before sending
	     *   the input. This should be false if a non-composition keystroke is entered before the
	     *   compositionend event is triggered, such as enter, so that the composition is send before
	     *   the command is executed.
	     */
	    CompositionHelper.prototype.finalizeComposition = function (waitForPropogation) {
	        this.compositionView.classList.remove('active');
	        this.isComposing = false;
	        this.clearTextareaPosition();
	        if (!waitForPropogation) {
	            // Cancel any delayed composition send requests and send the input immediately.
	            this.isSendingComposition = false;
	            var input = this.textarea.value.substring(this.compositionPosition.start, this.compositionPosition.end);
	            this.terminal.handler(input);
	        }
	        else {
	            // Make a deep copy of the composition position here as a new compositionstart event may
	            // fire before the setTimeout executes.
	            var currentCompositionPosition = {
	                start: this.compositionPosition.start,
	                end: this.compositionPosition.end,
	            };
	            // Since composition* events happen before the changes take place in the textarea on most
	            // browsers, use a setTimeout with 0ms time to allow the native compositionend event to
	            // complete. This ensures the correct character is retrieved, this solution was used
	            // because:
	            // - The compositionend event's data property is unreliable, at least on Chromium
	            // - The last compositionupdate event's data property does not always accurately describe
	            //   the character, a counter example being Korean where an ending consonsant can move to
	            //   the following character if the following input is a vowel.
	            var self = this;
	            this.isSendingComposition = true;
	            setTimeout(function () {
	                // Ensure that the input has not already been sent
	                if (self.isSendingComposition) {
	                    self.isSendingComposition = false;
	                    var input;
	                    if (self.isComposing) {
	                        // Use the end position to get the string if a new composition has started.
	                        input = self.textarea.value.substring(currentCompositionPosition.start, currentCompositionPosition.end);
	                    }
	                    else {
	                        // Don't use the end position here in order to pick up any characters after the
	                        // composition has finished, for example when typing a non-composition character
	                        // (eg. 2) after a composition character.
	                        input = self.textarea.value.substring(currentCompositionPosition.start);
	                    }
	                    self.terminal.handler(input);
	                }
	            }, 0);
	        }
	    };
	    /**
	     * Apply any changes made to the textarea after the current event chain is allowed to complete.
	     * This should be called when not currently composing but a keydown event with the "composition
	     * character" (229) is triggered, in order to allow non-composition text to be entered when an
	     * IME is active.
	     */
	    CompositionHelper.prototype.handleAnyTextareaChanges = function () {
	        var oldValue = this.textarea.value;
	        var self = this;
	        setTimeout(function () {
	            // Ignore if a composition has started since the timeout
	            if (!self.isComposing) {
	                var newValue = self.textarea.value;
	                var diff = newValue.replace(oldValue, '');
	                if (diff.length > 0) {
	                    self.terminal.handler(diff);
	                }
	            }
	        }, 0);
	    };
	    /**
	     * Positions the composition view on top of the cursor and the textarea just below it (so the
	     * IME helper dialog is positioned correctly).
	     * @param dontRecurse Whether to use setTimeout to recursively trigger another update, this is
	     *   necessary as the IME events across browsers are not consistently triggered.
	     */
	    CompositionHelper.prototype.updateCompositionElements = function (dontRecurse) {
	        if (!this.isComposing) {
	            return;
	        }
	        var cursor = this.terminal.element.querySelector('.terminal-cursor');
	        if (cursor) {
	            // Take .xterm-rows offsetTop into account as well in case it's positioned absolutely within
	            // the .xterm element.
	            var xtermRows = this.terminal.element.querySelector('.xterm-rows');
	            var cursorTop = xtermRows.offsetTop + cursor.offsetTop;
	            this.compositionView.style.left = cursor.offsetLeft + 'px';
	            this.compositionView.style.top = cursorTop + 'px';
	            this.compositionView.style.height = cursor.offsetHeight + 'px';
	            this.compositionView.style.lineHeight = cursor.offsetHeight + 'px';
	            // Sync the textarea to the exact position of the composition view so the IME knows where the
	            // text is.
	            var compositionViewBounds = this.compositionView.getBoundingClientRect();
	            this.textarea.style.left = cursor.offsetLeft + 'px';
	            this.textarea.style.top = cursorTop + 'px';
	            this.textarea.style.width = compositionViewBounds.width + 'px';
	            this.textarea.style.height = compositionViewBounds.height + 'px';
	            this.textarea.style.lineHeight = compositionViewBounds.height + 'px';
	        }
	        if (!dontRecurse) {
	            setTimeout(this.updateCompositionElements.bind(this, true), 0);
	        }
	    };
	    ;
	    /**
	     * Clears the textarea's position so that the cursor does not blink on IE.
	     * @private
	     */
	    CompositionHelper.prototype.clearTextareaPosition = function () {
	        this.textarea.style.left = '';
	        this.textarea.style.top = '';
	    };
	    ;
	    return CompositionHelper;
	}());
	exports.CompositionHelper = CompositionHelper;
	//# sourceMappingURL=CompositionHelper.js.map

/***/ },
/* 3 */
/***/ function(module, exports) {

	/**
	 * @license MIT
	 */
	"use strict";
	function EventEmitter() {
	    this._events = this._events || {};
	}
	exports.EventEmitter = EventEmitter;
	EventEmitter.prototype.addListener = function (type, listener) {
	    this._events[type] = this._events[type] || [];
	    this._events[type].push(listener);
	};
	EventEmitter.prototype.on = EventEmitter.prototype.addListener;
	EventEmitter.prototype.removeListener = function (type, listener) {
	    if (!this._events[type])
	        return;
	    var obj = this._events[type], i = obj.length;
	    while (i--) {
	        if (obj[i] === listener || obj[i].listener === listener) {
	            obj.splice(i, 1);
	            return;
	        }
	    }
	};
	EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
	EventEmitter.prototype.removeAllListeners = function (type) {
	    if (this._events[type])
	        delete this._events[type];
	};
	EventEmitter.prototype.once = function (type, listener) {
	    var self = this;
	    function on() {
	        var args = Array.prototype.slice.call(arguments);
	        this.removeListener(type, on);
	        return listener.apply(this, args);
	    }
	    on.listener = listener;
	    return this.on(type, on);
	};
	EventEmitter.prototype.emit = function (type) {
	    if (!this._events[type])
	        return;
	    var args = Array.prototype.slice.call(arguments, 1), obj = this._events[type], l = obj.length, i = 0;
	    for (; i < l; i++) {
	        obj[i].apply(this, args);
	    }
	};
	EventEmitter.prototype.listeners = function (type) {
	    return this._events[type] = this._events[type] || [];
	};
	//# sourceMappingURL=EventEmitter.js.map

/***/ },
/* 4 */
/***/ function(module, exports) {

	/**
	 * @license MIT
	 */
	"use strict";
	/**
	 * Represents the viewport of a terminal, the visible area within the larger buffer of output.
	 * Logic for the virtual scroll bar is included in this object.
	 */
	var Viewport = (function () {
	    /**
	     * Creates a new Viewport.
	     * @param terminal The terminal this viewport belongs to.
	     * @param viewportElement The DOM element acting as the viewport.
	     * @param scrollArea The DOM element acting as the scroll area.
	     * @param charMeasureElement A DOM element used to measure the character size of. the terminal.
	     */
	    function Viewport(terminal, viewportElement, scrollArea, charMeasureElement) {
	        this.terminal = terminal;
	        this.viewportElement = viewportElement;
	        this.scrollArea = scrollArea;
	        this.charMeasureElement = charMeasureElement;
	        this.currentRowHeight = 0;
	        this.lastRecordedBufferLength = 0;
	        this.lastRecordedViewportHeight = 0;
	        this.terminal.on('scroll', this.syncScrollArea.bind(this));
	        this.terminal.on('resize', this.syncScrollArea.bind(this));
	        this.viewportElement.addEventListener('scroll', this.onScroll.bind(this));
	        this.syncScrollArea();
	    }
	    /**
	     * Refreshes row height, setting line-height, viewport height and scroll area height if
	     * necessary.
	     * @param charSize A character size measurement bounding rect object, if it doesn't exist it will
	     *   be created.
	     */
	    Viewport.prototype.refresh = function (charSize) {
	        var size = charSize || this.charMeasureElement.getBoundingClientRect();
	        if (size.height > 0) {
	            var rowHeightChanged = size.height !== this.currentRowHeight;
	            if (rowHeightChanged) {
	                this.currentRowHeight = size.height;
	                this.viewportElement.style.lineHeight = size.height + 'px';
	                this.terminal.rowContainer.style.lineHeight = size.height + 'px';
	            }
	            var viewportHeightChanged = this.lastRecordedViewportHeight !== this.terminal.rows;
	            if (rowHeightChanged || viewportHeightChanged) {
	                this.lastRecordedViewportHeight = this.terminal.rows;
	                this.viewportElement.style.height = size.height * this.terminal.rows + 'px';
	            }
	            this.scrollArea.style.height = (size.height * this.lastRecordedBufferLength) + 'px';
	        }
	    };
	    /**
	     * Updates dimensions and synchronizes the scroll area if necessary.
	     */
	    Viewport.prototype.syncScrollArea = function () {
	        if (this.lastRecordedBufferLength !== this.terminal.lines.length) {
	            // If buffer height changed
	            this.lastRecordedBufferLength = this.terminal.lines.length;
	            this.refresh();
	        }
	        else if (this.lastRecordedViewportHeight !== this.terminal.rows) {
	            // If viewport height changed
	            this.refresh();
	        }
	        else {
	            // If size has changed, refresh viewport
	            var size = this.charMeasureElement.getBoundingClientRect();
	            if (size.height !== this.currentRowHeight) {
	                this.refresh(size);
	            }
	        }
	        // Sync scrollTop
	        var scrollTop = this.terminal.ydisp * this.currentRowHeight;
	        if (this.viewportElement.scrollTop !== scrollTop) {
	            this.viewportElement.scrollTop = scrollTop;
	        }
	    };
	    /**
	     * Handles scroll events on the viewport, calculating the new viewport and requesting the
	     * terminal to scroll to it.
	     * @param ev The scroll event.
	     */
	    Viewport.prototype.onScroll = function (ev) {
	        var newRow = Math.round(this.viewportElement.scrollTop / this.currentRowHeight);
	        var diff = newRow - this.terminal.ydisp;
	        this.terminal.scrollDisp(diff, true);
	    };
	    /**
	     * Handles mouse wheel events by adjusting the viewport's scrollTop and delegating the actual
	     * scrolling to `onScroll`, this event needs to be attached manually by the consumer of
	     * `Viewport`.
	     * @param ev The mouse wheel event.
	     */
	    Viewport.prototype.onWheel = function (ev) {
	        if (ev.deltaY === 0) {
	            // Do nothing if it's not a vertical scroll event
	            return;
	        }
	        // Fallback to WheelEvent.DOM_DELTA_PIXEL
	        var multiplier = 1;
	        if (ev.deltaMode === WheelEvent.DOM_DELTA_LINE) {
	            multiplier = this.currentRowHeight;
	        }
	        else if (ev.deltaMode === WheelEvent.DOM_DELTA_PAGE) {
	            multiplier = this.currentRowHeight * this.terminal.rows;
	        }
	        this.viewportElement.scrollTop += ev.deltaY * multiplier;
	        // Prevent the page from scrolling when the terminal scrolls
	        ev.preventDefault();
	    };
	    ;
	    return Viewport;
	}());
	exports.Viewport = Viewport;
	//# sourceMappingURL=Viewport.js.map

/***/ },
/* 5 */
/***/ function(module, exports) {

	/**
	 * Clipboard handler module: exports methods for handling all clipboard-related events in the
	 * terminal.
	 * @module xterm/handlers/Clipboard
	 * @license MIT
	 */
	"use strict";
	/**
	 * Prepares text copied from terminal selection, to be saved in the clipboard by:
	 *   1. stripping all trailing white spaces
	 *   2. converting all non-breaking spaces to regular spaces
	 * @param {string} text The copied text that needs processing for storing in clipboard
	 * @returns {string}
	 */
	function prepareTextForClipboard(text) {
	    var space = String.fromCharCode(32), nonBreakingSpace = String.fromCharCode(160), allNonBreakingSpaces = new RegExp(nonBreakingSpace, 'g'), processedText = text.split('\n').map(function (line) {
	        // Strip all trailing white spaces and convert all non-breaking spaces
	        // to regular spaces.
	        var processedLine = line.replace(/\s+$/g, '').replace(allNonBreakingSpaces, space);
	        return processedLine;
	    }).join('\n');
	    return processedText;
	}
	exports.prepareTextForClipboard = prepareTextForClipboard;
	/**
	 * Binds copy functionality to the given terminal.
	 * @param {ClipboardEvent} ev The original copy event to be handled
	 */
	function copyHandler(ev, term) {
	    // We cast `window` to `any` type, because TypeScript has not declared the `clipboardData`
	    // property that we use below for Internet Explorer.
	    var copiedText = window.getSelection().toString(), text = prepareTextForClipboard(copiedText);
	    if (term.browser.isMSIE) {
	        window.clipboardData.setData('Text', text);
	    }
	    else {
	        ev.clipboardData.setData('text/plain', text);
	    }
	    ev.preventDefault(); // Prevent or the original text will be copied.
	}
	exports.copyHandler = copyHandler;
	/**
	 * Redirect the clipboard's data to the terminal's input handler.
	 * @param {ClipboardEvent} ev The original paste event to be handled
	 * @param {Terminal} term The terminal on which to apply the handled paste event
	 */
	function pasteHandler(ev, term) {
	    ev.stopPropagation();
	    var text;
	    var dispatchPaste = function (text) {
	        term.handler(text);
	        term.textarea.value = '';
	        return term.cancel(ev);
	    };
	    if (term.browser.isMSIE) {
	        if (window.clipboardData) {
	            text = window.clipboardData.getData('Text');
	            dispatchPaste(text);
	        }
	    }
	    else {
	        if (ev.clipboardData) {
	            text = ev.clipboardData.getData('text/plain');
	            dispatchPaste(text);
	        }
	    }
	}
	exports.pasteHandler = pasteHandler;
	/**
	 * Bind to right-click event and allow right-click copy and paste.
	 *
	 * **Logic**
	 * If text is selected and right-click happens on selected text, then
	 * do nothing to allow seamless copying.
	 * If no text is selected or right-click is outside of the selection
	 * area, then bring the terminal's input below the cursor, in order to
	 * trigger the event on the textarea and allow-right click paste, without
	 * caring about disappearing selection.
	 * @param {MouseEvent} ev The original right click event to be handled
	 * @param {Terminal} term The terminal on which to apply the handled paste event
	 */
	function rightClickHandler(ev, term) {
	    var s = document.getSelection(), selectedText = prepareTextForClipboard(s.toString()), clickIsOnSelection = false, x = ev.clientX, y = ev.clientY;
	    if (s.rangeCount) {
	        var r = s.getRangeAt(0), cr = r.getClientRects();
	        for (var i = 0; i < cr.length; i++) {
	            var rect = cr[i];
	            clickIsOnSelection = ((x > rect.left) && (x < rect.right) &&
	                (y > rect.top) && (y < rect.bottom));
	            if (clickIsOnSelection) {
	                break;
	            }
	        }
	        // If we clicked on selection and selection is not a single space,
	        // then mark the right click as copy-only. We check for the single
	        // space selection, as this can happen when clicking on an &nbsp;
	        // and there is not much pointing in copying a single space.
	        if (selectedText.match(/^\s$/) || !selectedText.length) {
	            clickIsOnSelection = false;
	        }
	    }
	    // Bring textarea at the cursor position
	    if (!clickIsOnSelection) {
	        term.textarea.style.position = 'fixed';
	        term.textarea.style.width = '20px';
	        term.textarea.style.height = '20px';
	        term.textarea.style.left = (x - 10) + 'px';
	        term.textarea.style.top = (y - 10) + 'px';
	        term.textarea.style.zIndex = '1000';
	        term.textarea.focus();
	        // Reset the terminal textarea's styling
	        setTimeout(function () {
	            term.textarea.style.position = null;
	            term.textarea.style.width = null;
	            term.textarea.style.height = null;
	            term.textarea.style.left = null;
	            term.textarea.style.top = null;
	            term.textarea.style.zIndex = null;
	        }, 4);
	    }
	}
	exports.rightClickHandler = rightClickHandler;
	//# sourceMappingURL=Clipboard.js.map

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Attributes and methods to help with identifying the current browser and platform.
	 * @module xterm/utils/Browser
	 * @license MIT
	 */
	"use strict";
	var Generic_js_1 = __webpack_require__(7);
	var isNode = (typeof navigator == 'undefined') ? true : false;
	var userAgent = (isNode) ? 'node' : navigator.userAgent;
	var platform = (isNode) ? 'node' : navigator.platform;
	exports.isFirefox = !!~userAgent.indexOf('Firefox');
	exports.isMSIE = !!~userAgent.indexOf('MSIE') || !!~userAgent.indexOf('Trident');
	// Find the users platform. We use this to interpret the meta key
	// and ISO third level shifts.
	// http://stackoverflow.com/q/19877924/577598
	exports.isMac = Generic_js_1.contains(['Macintosh', 'MacIntel', 'MacPPC', 'Mac68K'], platform);
	exports.isIpad = platform === 'iPad';
	exports.isIphone = platform === 'iPhone';
	exports.isMSWindows = Generic_js_1.contains(['Windows', 'Win16', 'Win32', 'WinCE'], platform);
	//# sourceMappingURL=Browser.js.map

/***/ },
/* 7 */
/***/ function(module, exports) {

	/**
	 * Generic utilities module with methods that can be helpful at different parts of the code base.
	 * @module xterm/utils/Generic
	 * @license MIT
	 */
	"use strict";
	/**
	 * Return if the given array contains the given element
	 * @param {Array} array The array to search for the given element.
	 * @param {Object} el The element to look for into the array
	 */
	exports.contains = function (arr, el) {
	    return arr.indexOf(el) >= 0;
	};
	//# sourceMappingURL=Generic.js.map

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./attach/attach": 9,
		"./attach/attach.js": 9,
		"./fit/fit": 10,
		"./fit/fit.js": 10,
		"./fullscreen/fullscreen": 11,
		"./fullscreen/fullscreen.js": 11,
		"./linkify/linkify": 12,
		"./linkify/linkify.js": 12,
		"./terminado/terminado": 13,
		"./terminado/terminado.js": 13
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 8;


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Implements the attach method, that attaches the terminal to a WebSocket stream.
	 * @module xterm/addons/attach/attach
	 * @license MIT
	 */
	(function (attach) {
	    if (true) {
	        /*
	         * CommonJS environment
	         */
	        module.exports = attach(__webpack_require__(1));
	    }
	    else if (typeof define == 'function') {
	        /*
	         * Require.js is available
	         */
	        define(['../../xterm'], attach);
	    }
	    else {
	        /*
	         * Plain browser environment
	         */
	        attach(window.Terminal);
	    }
	})(function (Xterm) {
	    'use strict';
	    var exports = {};
	    /**
	     * Attaches the given terminal to the given socket.
	     *
	     * @param {Xterm} term - The terminal to be attached to the given socket.
	     * @param {WebSocket} socket - The socket to attach the current terminal.
	     * @param {boolean} bidirectional - Whether the terminal should send data
	     *                                  to the socket as well.
	     * @param {boolean} buffered - Whether the rendering of incoming data
	     *                             should happen instantly or at a maximum
	     *                             frequency of 1 rendering per 10ms.
	     */
	    exports.attach = function (term, socket, bidirectional, buffered) {
	        bidirectional = (typeof bidirectional == 'undefined') ? true : bidirectional;
	        term.socket = socket;
	        term._flushBuffer = function () {
	            term.write(term._attachSocketBuffer);
	            term._attachSocketBuffer = null;
	            clearTimeout(term._attachSocketBufferTimer);
	            term._attachSocketBufferTimer = null;
	        };
	        term._pushToBuffer = function (data) {
	            if (term._attachSocketBuffer) {
	                term._attachSocketBuffer += data;
	            }
	            else {
	                term._attachSocketBuffer = data;
	                setTimeout(term._flushBuffer, 10);
	            }
	        };
	        term._getMessage = function (ev) {
	            if (buffered) {
	                term._pushToBuffer(ev.data);
	            }
	            else {
	                term.write(ev.data);
	            }
	        };
	        term._sendData = function (data) {
	            socket.send(data);
	        };
	        socket.addEventListener('message', term._getMessage);
	        if (bidirectional) {
	            term.on('data', term._sendData);
	        }
	        socket.addEventListener('close', term.detach.bind(term, socket));
	        socket.addEventListener('error', term.detach.bind(term, socket));
	    };
	    /**
	     * Detaches the given terminal from the given socket
	     *
	     * @param {Xterm} term - The terminal to be detached from the given socket.
	     * @param {WebSocket} socket - The socket from which to detach the current
	     *                             terminal.
	     */
	    exports.detach = function (term, socket) {
	        term.off('data', term._sendData);
	        socket = (typeof socket == 'undefined') ? term.socket : socket;
	        if (socket) {
	            socket.removeEventListener('message', term._getMessage);
	        }
	        delete term.socket;
	    };
	    /**
	     * Attaches the current terminal to the given socket
	     *
	     * @param {WebSocket} socket - The socket to attach the current terminal.
	     * @param {boolean} bidirectional - Whether the terminal should send data
	     *                                  to the socket as well.
	     * @param {boolean} buffered - Whether the rendering of incoming data
	     *                             should happen instantly or at a maximum
	     *                             frequency of 1 rendering per 10ms.
	     */
	    Xterm.prototype.attach = function (socket, bidirectional, buffered) {
	        return exports.attach(this, socket, bidirectional, buffered);
	    };
	    /**
	     * Detaches the current terminal from the given socket.
	     *
	     * @param {WebSocket} socket - The socket from which to detach the current
	     *                             terminal.
	     */
	    Xterm.prototype.detach = function (socket) {
	        return exports.detach(this, socket);
	    };
	    return exports;
	});
	//# sourceMappingURL=attach.js.map

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Fit terminal columns and rows to the dimensions of its DOM element.
	 *
	 * ## Approach
	 * - Rows: Truncate the division of the terminal parent element height by the terminal row height.
	 *
	 * - Columns: Truncate the division of the terminal parent element width by the terminal character
	 * width (apply display: inline at the terminal row and truncate its width with the current
	 * number of columns).
	 * @module xterm/addons/fit/fit
	 * @license MIT
	 */
	(function (fit) {
	    if (true) {
	        /*
	         * CommonJS environment
	         */
	        module.exports = fit(__webpack_require__(1));
	    }
	    else if (typeof define == 'function') {
	        /*
	         * Require.js is available
	         */
	        define(['../../xterm'], fit);
	    }
	    else {
	        /*
	         * Plain browser environment
	         */
	        fit(window.Terminal);
	    }
	})(function (Xterm) {
	    var exports = {};
	    exports.proposeGeometry = function (term) {
	        var parentElementStyle = window.getComputedStyle(term.element.parentElement), parentElementHeight = parseInt(parentElementStyle.getPropertyValue('height')), parentElementWidth = Math.max(0, parseInt(parentElementStyle.getPropertyValue('width')) - 17), elementStyle = window.getComputedStyle(term.element), elementPaddingVer = parseInt(elementStyle.getPropertyValue('padding-top')) + parseInt(elementStyle.getPropertyValue('padding-bottom')), elementPaddingHor = parseInt(elementStyle.getPropertyValue('padding-right')) + parseInt(elementStyle.getPropertyValue('padding-left')), availableHeight = parentElementHeight - elementPaddingVer, availableWidth = parentElementWidth - elementPaddingHor, container = term.rowContainer, subjectRow = term.rowContainer.firstElementChild, contentBuffer = subjectRow.innerHTML, characterHeight, rows, characterWidth, cols, geometry;
	        subjectRow.style.display = 'inline';
	        subjectRow.innerHTML = 'W'; // Common character for measuring width, although on monospace
	        characterWidth = subjectRow.getBoundingClientRect().width;
	        subjectRow.style.display = ''; // Revert style before calculating height, since they differ.
	        characterHeight = parseInt(subjectRow.offsetHeight);
	        subjectRow.innerHTML = contentBuffer;
	        rows = parseInt(availableHeight / characterHeight);
	        cols = parseInt(availableWidth / characterWidth);
	        geometry = { cols: cols, rows: rows };
	        return geometry;
	    };
	    exports.fit = function (term) {
	        var geometry = exports.proposeGeometry(term);
	        term.resize(geometry.cols, geometry.rows);
	    };
	    Xterm.prototype.proposeGeometry = function () {
	        return exports.proposeGeometry(this);
	    };
	    Xterm.prototype.fit = function () {
	        return exports.fit(this);
	    };
	    return exports;
	});
	//# sourceMappingURL=fit.js.map

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Fullscreen addon for xterm.js
	 * @module xterm/addons/fullscreen/fullscreen
	 * @license MIT
	 */
	(function (fullscreen) {
	    if (true) {
	        /*
	         * CommonJS environment
	         */
	        module.exports = fullscreen(__webpack_require__(1));
	    }
	    else if (typeof define == 'function') {
	        /*
	         * Require.js is available
	         */
	        define(['../../xterm'], fullscreen);
	    }
	    else {
	        /*
	         * Plain browser environment
	         */
	        fullscreen(window.Terminal);
	    }
	})(function (Xterm) {
	    var exports = {};
	    /**
	     * Toggle the given terminal's fullscreen mode.
	     * @param {Xterm} term - The terminal to toggle full screen mode
	     * @param {boolean} fullscreen - Toggle fullscreen on (true) or off (false)
	     */
	    exports.toggleFullScreen = function (term, fullscreen) {
	        var fn;
	        if (typeof fullscreen == 'undefined') {
	            fn = (term.element.classList.contains('fullscreen')) ? 'remove' : 'add';
	        }
	        else if (!fullscreen) {
	            fn = 'remove';
	        }
	        else {
	            fn = 'add';
	        }
	        term.element.classList[fn]('fullscreen');
	    };
	    Xterm.prototype.toggleFullscreen = function (fullscreen) {
	        exports.toggleFullScreen(this, fullscreen);
	    };
	    return exports;
	});
	//# sourceMappingURL=fullscreen.js.map

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Methods for turning URL subscrings in the terminal's content into links (`a` DOM elements).
	 * @module xterm/addons/linkify/linkify
	 * @license MIT
	 */
	(function (linkify) {
	    if (true) {
	        /*
	         * CommonJS environment
	         */
	        module.exports = linkify(__webpack_require__(1));
	    }
	    else if (typeof define == 'function') {
	        /*
	         * Require.js is available
	         */
	        define(['../../xterm'], linkify);
	    }
	    else {
	        /*
	         * Plain browser environment
	         */
	        linkify(window.Terminal);
	    }
	})(function (Xterm) {
	    'use strict';
	    var exports = {}, protocolClause = '(https?:\\/\\/)', domainCharacterSet = '[\\da-z\\.-]+', negatedDomainCharacterSet = '[^\\da-z\\.-]+', domainBodyClause = '(' + domainCharacterSet + ')', tldClause = '([a-z\\.]{2,6})', ipClause = '((\\d{1,3}\\.){3}\\d{1,3})', portClause = '(:\\d{1,5})', hostClause = '((' + domainBodyClause + '\\.' + tldClause + ')|' + ipClause + ')' + portClause + '?', pathClause = '(\\/[\\/\\w\\.-]*)*', negatedPathCharacterSet = '[^\\/\\w\\.-]+', bodyClause = hostClause + pathClause, start = '(?:^|' + negatedDomainCharacterSet + ')(', end = ')($|' + negatedPathCharacterSet + ')', lenientUrlClause = start + protocolClause + '?' + bodyClause + end, strictUrlClause = start + protocolClause + bodyClause + end, lenientUrlRegex = new RegExp(lenientUrlClause), strictUrlRegex = new RegExp(strictUrlClause);
	    /**
	     * Converts all valid URLs found in the given terminal line into
	     * hyperlinks. The terminal line can be either the HTML element itself
	     * or the index of the termina line in the children of the terminal
	     * rows container.
	     *
	     * @param {Xterm} terminal - The terminal that owns the given line.
	     * @param {number|HTMLDivElement} line - The terminal line that should get
	     *								  		 "linkified".
	     * @param {boolean} lenient - The regex type that will be used to identify links. If lenient is
	     *                            false, the regex requires a protocol clause. Defaults to true.
	     * @param {string} target -  Sets target="" attribute with value provided to links.
	     *                           Default doesn't set target attribute
	     * @emits linkify
	     * @emits linkify:line
	     */
	    exports.linkifyTerminalLine = function (terminal, line, lenient, target) {
	        if (typeof line == 'number') {
	            line = terminal.rowContainer.children[line];
	        }
	        else if (!(line instanceof HTMLDivElement)) {
	            var message = 'The "line" argument should be either a number';
	            message += ' or an HTMLDivElement';
	            throw new TypeError(message);
	        }
	        if (typeof target === 'undefined') {
	            target = '';
	        }
	        else {
	            target = 'target="' + target + '"';
	        }
	        var buffer = document.createElement('span'), nodes = line.childNodes;
	        for (var j = 0; j < nodes.length; j++) {
	            var node = nodes[j], match;
	            /**
	             * Since we cannot access the TextNode's HTML representation
	             * from the instance itself, we assign its data as textContent
	             * to a dummy buffer span, in order to retrieve the TextNode's
	             * HTML representation from the buffer's innerHTML.
	             */
	            buffer.textContent = node.data;
	            var nodeHTML = buffer.innerHTML;
	            /**
	             * Apply function only on TextNodes
	             */
	            if (node.nodeType != node.TEXT_NODE) {
	                continue;
	            }
	            var url = exports.findLinkMatch(node.data, lenient);
	            if (!url) {
	                continue;
	            }
	            var startsWithProtocol = new RegExp('^' + protocolClause), urlHasProtocol = url.match(startsWithProtocol), href = (urlHasProtocol) ? url : 'http://' + url, link = '<a href="' + href + '" ' + target + '>' + url + '</a>', newHTML = nodeHTML.replace(url, link);
	            line.innerHTML = line.innerHTML.replace(nodeHTML, newHTML);
	        }
	        /**
	         * This event gets emitted when conversion of all URL susbtrings
	         * to HTML anchor elements (links) has finished, for a specific
	         * line of the current Xterm instance.
	         *
	         * @event linkify:line
	         */
	        terminal.emit('linkify:line', line);
	    };
	    /**
	     * Finds a link within a block of text.
	     *
	     * @param {string} text - The text to search .
	     * @param {boolean} lenient - Whether to use the lenient search.
	     * @return {string} A URL.
	     */
	    exports.findLinkMatch = function (text, lenient) {
	        var match = text.match(lenient ? lenientUrlRegex : strictUrlRegex);
	        if (!match || match.length === 0) {
	            return null;
	        }
	        return match[1];
	    };
	    /**
	     * Converts all valid URLs found in the terminal view into hyperlinks.
	     *
	     * @param {Xterm} terminal - The terminal that should get "linkified".
	     * @param {boolean} lenient - The regex type that will be used to identify links. If lenient is
	     *                            false, the regex requires a protocol clause. Defaults to true.
	     * @param {string} target -  Sets target="" attribute with value provided to links.
	     *                           Default doesn't set target attribute
	     * @emits linkify
	     * @emits linkify:line
	     */
	    exports.linkify = function (terminal, lenient, target) {
	        var rows = terminal.rowContainer.children;
	        lenient = (typeof lenient == "boolean") ? lenient : true;
	        for (var i = 0; i < rows.length; i++) {
	            var line = rows[i];
	            exports.linkifyTerminalLine(terminal, line, lenient, target);
	        }
	        /**
	         * This event gets emitted when conversion of  all URL substrings to
	         * HTML anchor elements (links) has finished for the current Xterm
	         * instance's view.
	         *
	         * @event linkify
	         */
	        terminal.emit('linkify');
	    };
	    /**
	     * Extend Xterm prototype.
	     */
	    /**
	     * Converts all valid URLs found in the current terminal linte into
	     * hyperlinks.
	     *
	     * @memberof Xterm
	     * @param {number|HTMLDivElement} line - The terminal line that should get
	     *								  		 "linkified".
	     * @param {boolean} lenient - The regex type that will be used to identify links. If lenient is
	     *                            false, the regex requires a protocol clause. Defaults to true.
	     * @param {string} target -  Sets target="" attribute with value provided to links.
	     *                           Default doesn't set target attribute
	     */
	    Xterm.prototype.linkifyTerminalLine = function (line, lenient, target) {
	        return exports.linkifyTerminalLine(this, line, lenient, target);
	    };
	    /**
	     * Converts all valid URLs found in the current terminal into hyperlinks.
	     *
	     * @memberof Xterm
	     * @param {boolean} lenient - The regex type that will be used to identify links. If lenient is
	     *                            false, the regex requires a protocol clause. Defaults to true.
	     * @param {string} target -  Sets target="" attribute with value provided to links.
	     *                           Default doesn't set target attribute
	     */
	    Xterm.prototype.linkify = function (lenient, target) {
	        return exports.linkify(this, lenient, target);
	    };
	    return exports;
	});
	//# sourceMappingURL=linkify.js.map

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * This module provides methods for attaching a terminal to a terminado WebSocket stream.
	 *
	 * @module xterm/addons/terminado/terminado
	 * @license MIT
	 */
	(function (attach) {
	    if (true) {
	        /*
	         * CommonJS environment
	         */
	        module.exports = attach(__webpack_require__(1));
	    }
	    else if (typeof define == 'function') {
	        /*
	         * Require.js is available
	         */
	        define(['../../xterm'], attach);
	    }
	    else {
	        /*
	         * Plain browser environment
	         */
	        attach(window.Terminal);
	    }
	})(function (Xterm) {
	    'use strict';
	    var exports = {};
	    /**
	     * Attaches the given terminal to the given socket.
	     *
	     * @param {Xterm} term - The terminal to be attached to the given socket.
	     * @param {WebSocket} socket - The socket to attach the current terminal.
	     * @param {boolean} bidirectional - Whether the terminal should send data
	     *                                  to the socket as well.
	     * @param {boolean} buffered - Whether the rendering of incoming data
	     *                             should happen instantly or at a maximum
	     *                             frequency of 1 rendering per 10ms.
	     */
	    exports.terminadoAttach = function (term, socket, bidirectional, buffered) {
	        bidirectional = (typeof bidirectional == 'undefined') ? true : bidirectional;
	        term.socket = socket;
	        term._flushBuffer = function () {
	            term.write(term._attachSocketBuffer);
	            term._attachSocketBuffer = null;
	            clearTimeout(term._attachSocketBufferTimer);
	            term._attachSocketBufferTimer = null;
	        };
	        term._pushToBuffer = function (data) {
	            if (term._attachSocketBuffer) {
	                term._attachSocketBuffer += data;
	            }
	            else {
	                term._attachSocketBuffer = data;
	                setTimeout(term._flushBuffer, 10);
	            }
	        };
	        term._getMessage = function (ev) {
	            var data = JSON.parse(ev.data);
	            if (data[0] == "stdout") {
	                if (buffered) {
	                    term._pushToBuffer(data[1]);
	                }
	                else {
	                    term.write(data[1]);
	                }
	            }
	        };
	        term._sendData = function (data) {
	            socket.send(JSON.stringify(['stdin', data]));
	        };
	        term._setSize = function (size) {
	            socket.send(JSON.stringify(['set_size', size.rows, size.cols]));
	        };
	        socket.addEventListener('message', term._getMessage);
	        if (bidirectional) {
	            term.on('data', term._sendData);
	        }
	        term.on('resize', term._setSize);
	        socket.addEventListener('close', term.terminadoDetach.bind(term, socket));
	        socket.addEventListener('error', term.terminadoDetach.bind(term, socket));
	    };
	    /**
	     * Detaches the given terminal from the given socket
	     *
	     * @param {Xterm} term - The terminal to be detached from the given socket.
	     * @param {WebSocket} socket - The socket from which to detach the current
	     *                             terminal.
	     */
	    exports.terminadoDetach = function (term, socket) {
	        term.off('data', term._sendData);
	        socket = (typeof socket == 'undefined') ? term.socket : socket;
	        if (socket) {
	            socket.removeEventListener('message', term._getMessage);
	        }
	        delete term.socket;
	    };
	    /**
	     * Attaches the current terminal to the given socket
	     *
	     * @param {WebSocket} socket - The socket to attach the current terminal.
	     * @param {boolean} bidirectional - Whether the terminal should send data
	     *                                  to the socket as well.
	     * @param {boolean} buffered - Whether the rendering of incoming data
	     *                             should happen instantly or at a maximum
	     *                             frequency of 1 rendering per 10ms.
	     */
	    Xterm.prototype.terminadoAttach = function (socket, bidirectional, buffered) {
	        return exports.terminadoAttach(this, socket, bidirectional, buffered);
	    };
	    /**
	     * Detaches the current terminal from the given socket.
	     *
	     * @param {WebSocket} socket - The socket from which to detach the current
	     *                             terminal.
	     */
	    Xterm.prototype.terminadoDetach = function (socket) {
	        return exports.terminadoDetach(this, socket);
	    };
	    return exports;
	});
	//# sourceMappingURL=terminado.js.map

/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgMTRiOGNmMzUzMDUxNmRlODgxN2YiLCJ3ZWJwYWNrOi8vLy4vc3JjL3B1YmxpYy90ZXJtaW5hbC5qcyIsIndlYnBhY2s6Ly8vLi9+L3h0ZXJtL2xpYi94dGVybS5qcyIsIndlYnBhY2s6Ly8vLi9+L3h0ZXJtL2xpYi9Db21wb3NpdGlvbkhlbHBlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3h0ZXJtL2xpYi9FdmVudEVtaXR0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi94dGVybS9saWIvVmlld3BvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi94dGVybS9saWIvaGFuZGxlcnMvQ2xpcGJvYXJkLmpzIiwid2VicGFjazovLy8uL34veHRlcm0vbGliL3V0aWxzL0Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi94dGVybS9saWIvdXRpbHMvR2VuZXJpYy5qcyIsIndlYnBhY2s6Ly8vLi9+L3h0ZXJtL2xpYi9hZGRvbnMgXlxcLlxcLy4qJCIsIndlYnBhY2s6Ly8vLi9+L3h0ZXJtL2xpYi9hZGRvbnMvYXR0YWNoL2F0dGFjaC5qcyIsIndlYnBhY2s6Ly8vLi9+L3h0ZXJtL2xpYi9hZGRvbnMvZml0L2ZpdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3h0ZXJtL2xpYi9hZGRvbnMvZnVsbHNjcmVlbi9mdWxsc2NyZWVuLmpzIiwid2VicGFjazovLy8uL34veHRlcm0vbGliL2FkZG9ucy9saW5raWZ5L2xpbmtpZnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi94dGVybS9saWIvYWRkb25zL3Rlcm1pbmFkby90ZXJtaW5hZG8uanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUN0Q0E7Ozs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVLFNBQVM7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVLFFBQVE7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxXQUFVLFNBQVM7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTRCLGlCQUFpQjtBQUM3QyxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUEyQixpQkFBaUI7QUFDNUMsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLFlBQVk7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxZQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTRCLGlCQUFpQjtBQUM3QyxNQUFLO0FBQ0w7QUFDQSw0QkFBMkIsaUJBQWlCO0FBQzVDLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVLGVBQWU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUFzQixLQUFLO0FBQzNCLHFCQUFvQixLQUFLO0FBQ3pCO0FBQ0EsMEJBQXlCLE1BQU0sTUFBTSxNQUFNO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQW9CO0FBQ3BCO0FBQ0EscUJBQW9CO0FBQ3BCO0FBQ0EscUJBQW9CO0FBQ3BCO0FBQ0EscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUEyQyxjQUFjO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQW9CO0FBQ3BCO0FBQ0EscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBZ0M7QUFDaEMsK0JBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsWUFBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVSxVQUFVO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYyxXQUFXO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFpQztBQUNqQztBQUNBO0FBQ0EsaUNBQWdDO0FBQ2hDO0FBQ0E7QUFDQSxpQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsdUNBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTBCLGdEQUFnRDtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVSxPQUFPO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBbUQsa0JBQWtCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBMkI7QUFDM0IsNEJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckIsOEJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBK0I7QUFDL0IsNkNBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBK0I7QUFDL0IsZ0VBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBK0I7QUFDL0Isb0RBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQStCLEtBQUssS0FBSyxLQUFLO0FBQzlDLGlDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLDJCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBK0I7QUFDL0Isb0RBQW1EO0FBQ25EO0FBQ0E7QUFDQSwrQkFBOEIsSUFBSSxJQUFJLElBQUk7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsMkJBQTBCO0FBQzFCO0FBQ0EsMkJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsZ0NBQStCLEtBQUs7QUFDcEMsK0JBQThCLElBQUksSUFBSSxJQUFJO0FBQzFDLGlDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEwQjtBQUMxQjtBQUNBLDJCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsNkJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSwrQkFBOEIsSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJLElBQUk7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUErQixLQUFLLEtBQUs7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBOEIsSUFBSSxJQUFJLElBQUk7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsMkJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQStCO0FBQy9CLCtCQUE4QixJQUFJLElBQUk7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsMkJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQThCLElBQUksSUFBSTtBQUN0QywrQkFBOEI7QUFDOUI7QUFDQTtBQUNBLDJCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxjQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLGNBQWM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBb0M7QUFDcEM7QUFDQTtBQUNBLGlDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXFDO0FBQ3JDO0FBQ0E7QUFDQSwyQ0FBMEM7QUFDMUMsMENBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFxQztBQUNyQztBQUNBO0FBQ0EsMkNBQTBDO0FBQzFDLDBDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBcUM7QUFDckM7QUFDQTtBQUNBLDJDQUEwQztBQUMxQywwQ0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXFDO0FBQ3JDO0FBQ0E7QUFDQSwyQ0FBMEM7QUFDMUMsMENBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxjQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBeUIsbUNBQW1DO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVSxlQUFlO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBLDRFQUEyRTtBQUMzRSxXQUFVLGVBQWU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0EsNEVBQTJFO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsZUFBZTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVLGVBQWU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1gseUJBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCLGVBQWU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQixLQUFLO0FBQ3ZCO0FBQ0EsbUJBQWtCLEtBQUs7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVSxPQUFPO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBb0Q7QUFDcEQ7QUFDQSxhQUFZO0FBQ1o7QUFDQTtBQUNBLHFEQUFvRDtBQUNwRCxhQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQixNQUFNLE1BQU07QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF1QyxFQUFFLEVBQUU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CO0FBQ25CLG9CQUFtQjtBQUNuQjtBQUNBLHNCQUFxQixJQUFJLElBQUksSUFBSSxJQUFJLElBQUksTUFBTTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCLEtBQUs7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQStCLElBQUk7QUFDbkM7QUFDQTtBQUNBLGlDQUFnQyxHQUFHO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWdDLE1BQU07QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYLDRDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFnQyxFQUFFO0FBQ2xDLG1DQUFrQyxFQUFFO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBK0IsRUFBRTtBQUNqQyxpQ0FBZ0MsRUFBRTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1gsZ0NBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxLQUFLLEtBQUssS0FBSztBQUMxQjtBQUNBLFlBQVcsT0FBTyxPQUFPLFNBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBZ0M7QUFDaEMsb0NBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBd0I7QUFDeEI7QUFDQSxxQkFBb0I7QUFDcEIsNEJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVLElBQUksSUFBSSxJQUFJO0FBQ3RCO0FBQ0EsV0FBVSxJQUFJLElBQUk7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVSxXQUFXO0FBQ3JCO0FBQ0Esb0JBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVUsSUFBSSxJQUFJLElBQUk7QUFDdEI7QUFDQTtBQUNBLFdBQVUsSUFBSSxJQUFJO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVLFdBQVc7QUFDckI7QUFDQSxvQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVUsSUFBSSxJQUFJO0FBQ2xCO0FBQ0EsV0FBVSxJQUFJLElBQUk7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFvQztBQUNwQyxXQUFVLFdBQVc7QUFDckI7QUFDQSxvQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQSw2QkFBNEI7QUFDNUIsNkJBQTRCO0FBQzVCLGdDQUErQjtBQUMvQixrQ0FBaUM7QUFDakMsaUNBQWdDO0FBQ2hDLHlDQUF3QztBQUN4QyxpQ0FBZ0M7QUFDaEMsa0NBQWlDO0FBQ2pDLDBDQUF5QztBQUN6QyxrQ0FBaUM7QUFDakMsa0NBQWlDO0FBQ2pDLGdDQUErQjtBQUMvQixtQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVSw2QkFBNkI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQyxHQUFHLHFCQUFxQixFQUFFO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQzs7Ozs7O0FDNWdKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0EsOEM7Ozs7OztBQzNNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Qzs7Ozs7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQSxxQzs7Ozs7O0FDbkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLGVBQWU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsZUFBZTtBQUMxQixZQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxXQUFXO0FBQ3RCLFlBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCLGVBQWU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxzQzs7Ozs7O0FDMUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0M7Ozs7OztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxNQUFNO0FBQ2pCLFlBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DOzs7Ozs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFpQyx1REFBdUQ7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxNQUFNO0FBQ3JCLGdCQUFlLFVBQVU7QUFDekIsZ0JBQWUsUUFBUTtBQUN2QjtBQUNBLGdCQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsTUFBTTtBQUNyQixnQkFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsVUFBVTtBQUN6QixnQkFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZ0JBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRCxtQzs7Ozs7O0FDakhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW1DO0FBQ25DO0FBQ0EsdUNBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNELGdDOzs7Ozs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE1BQU07QUFDckIsZ0JBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0QsdUM7Ozs7OztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQSxxQkFBb0Isb01BQW9NLElBQUksc0JBQXNCLElBQUksS0FBSyxFQUFFLElBQUksSUFBSSx3QkFBd0IsSUFBSTtBQUNqUztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxNQUFNO0FBQ3JCLGdCQUFlLHNCQUFzQjtBQUNyQztBQUNBLGdCQUFlLFFBQVE7QUFDdkI7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsa0JBQWtCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxRQUFRO0FBQ3ZCLGlCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxNQUFNO0FBQ3JCLGdCQUFlLFFBQVE7QUFDdkI7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCLGlCQUFpQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsc0JBQXNCO0FBQ3JDO0FBQ0EsZ0JBQWUsUUFBUTtBQUN2QjtBQUNBLGdCQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsUUFBUTtBQUN2QjtBQUNBLGdCQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNELG9DOzs7Ozs7QUNwS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE1BQU07QUFDckIsZ0JBQWUsVUFBVTtBQUN6QixnQkFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZ0JBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE1BQU07QUFDckIsZ0JBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLFVBQVU7QUFDekIsZ0JBQWUsUUFBUTtBQUN2QjtBQUNBLGdCQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Qsc0MiLCJmaWxlIjoidGVybWluYWwubWluLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGV4cG9ydHM6IHt9LFxuIFx0XHRcdGlkOiBtb2R1bGVJZCxcbiBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiB3ZWJwYWNrL2Jvb3RzdHJhcCAxNGI4Y2YzNTMwNTE2ZGU4ODE3ZlxuICoqLyIsIndpbmRvdy5UZXJtaW5hbCA9IHJlcXVpcmUoJ3h0ZXJtJyk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL3B1YmxpYy90ZXJtaW5hbC5qc1xuICoqIG1vZHVsZSBpZCA9IDBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogeHRlcm0uanM6IHh0ZXJtLCBpbiB0aGUgYnJvd3NlclxuICogT3JpZ2luYWxseSBmb3JrZWQgZnJvbSAod2l0aCB0aGUgYXV0aG9yJ3MgcGVybWlzc2lvbik6XG4gKiAgIEZhYnJpY2UgQmVsbGFyZCdzIGphdmFzY3JpcHQgdnQxMDAgZm9yIGpzbGludXg6XG4gKiAgIGh0dHA6Ly9iZWxsYXJkLm9yZy9qc2xpbnV4L1xuICogICBDb3B5cmlnaHQgKGMpIDIwMTEgRmFicmljZSBCZWxsYXJkXG4gKiAgIFRoZSBvcmlnaW5hbCBkZXNpZ24gcmVtYWlucy4gVGhlIHRlcm1pbmFsIGl0c2VsZlxuICogICBoYXMgYmVlbiBleHRlbmRlZCB0byBpbmNsdWRlIHh0ZXJtIENTSSBjb2RlcywgYW1vbmdcbiAqICAgb3RoZXIgZmVhdHVyZXMuXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgQ29tcG9zaXRpb25IZWxwZXJfanNfMSA9IHJlcXVpcmUoXCIuL0NvbXBvc2l0aW9uSGVscGVyLmpzXCIpO1xudmFyIEV2ZW50RW1pdHRlcl9qc18xID0gcmVxdWlyZShcIi4vRXZlbnRFbWl0dGVyLmpzXCIpO1xudmFyIFZpZXdwb3J0X2pzXzEgPSByZXF1aXJlKFwiLi9WaWV3cG9ydC5qc1wiKTtcbnZhciBDbGlwYm9hcmRfanNfMSA9IHJlcXVpcmUoXCIuL2hhbmRsZXJzL0NsaXBib2FyZC5qc1wiKTtcbnZhciBCcm93c2VyID0gcmVxdWlyZShcIi4vdXRpbHMvQnJvd3NlclwiKTtcbi8qKlxuICogVGVybWluYWwgRW11bGF0aW9uIFJlZmVyZW5jZXM6XG4gKiAgIGh0dHA6Ly92dDEwMC5uZXQvXG4gKiAgIGh0dHA6Ly9pbnZpc2libGUtaXNsYW5kLm5ldC94dGVybS9jdGxzZXFzL2N0bHNlcXMudHh0XG4gKiAgIGh0dHA6Ly9pbnZpc2libGUtaXNsYW5kLm5ldC94dGVybS9jdGxzZXFzL2N0bHNlcXMuaHRtbFxuICogICBodHRwOi8vaW52aXNpYmxlLWlzbGFuZC5uZXQvdnR0ZXN0L1xuICogICBodHRwOi8vd3d3Lmlud2FwLmNvbS9wZHAxMC9hbnNpY29kZS50eHRcbiAqICAgaHR0cDovL2xpbnV4LmRpZS5uZXQvbWFuLzQvY29uc29sZV9jb2Rlc1xuICogICBodHRwOi8vbGludXguZGllLm5ldC9tYW4vNy91cnh2dFxuICovXG4vLyBMZXQgaXQgd29yayBpbnNpZGUgTm9kZS5qcyBmb3IgYXV0b21hdGVkIHRlc3RpbmcgcHVycG9zZXMuXG52YXIgZG9jdW1lbnQgPSAodHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJykgPyB3aW5kb3cuZG9jdW1lbnQgOiBudWxsO1xuLyoqXG4gKiBTdGF0ZXNcbiAqL1xudmFyIG5vcm1hbCA9IDAsIGVzY2FwZWQgPSAxLCBjc2kgPSAyLCBvc2MgPSAzLCBjaGFyc2V0ID0gNCwgZGNzID0gNSwgaWdub3JlID0gNjtcbi8qKlxuICogVGVybWluYWxcbiAqL1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGBUZXJtaW5hbGAgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIEFuIG9iamVjdCBjb250YWluaW5nIGEgc2V0IG9mIG9wdGlvbnMsIHRoZSBhdmFpbGFibGUgb3B0aW9ucyBhcmU6XG4gKiAgIC0gYGN1cnNvckJsaW5rYCAoYm9vbGVhbik6IFdoZXRoZXIgdGhlIHRlcm1pbmFsIGN1cnNvciBibGlua3NcbiAqICAgLSBgY29sc2AgKG51bWJlcik6IFRoZSBudW1iZXIgb2YgY29sdW1ucyBvZiB0aGUgdGVybWluYWwgKGhvcml6b250YWwgc2l6ZSlcbiAqICAgLSBgcm93c2AgKG51bWJlcik6IFRoZSBudW1iZXIgb2Ygcm93cyBvZiB0aGUgdGVybWluYWwgKHZlcnRpY2FsIHNpemUpXG4gKlxuICogQHB1YmxpY1xuICogQGNsYXNzIFh0ZXJtIFh0ZXJtXG4gKiBAYWxpYXMgbW9kdWxlOnh0ZXJtL3NyYy94dGVybVxuICovXG5mdW5jdGlvbiBUZXJtaW5hbChvcHRpb25zKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUZXJtaW5hbCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUZXJtaW5hbChhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICB9XG4gICAgc2VsZi5icm93c2VyID0gQnJvd3NlcjtcbiAgICBzZWxmLmNhbmNlbCA9IFRlcm1pbmFsLmNhbmNlbDtcbiAgICBFdmVudEVtaXR0ZXJfanNfMS5FdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdudW1iZXInKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBjb2xzOiBhcmd1bWVudHNbMF0sXG4gICAgICAgICAgICByb3dzOiBhcmd1bWVudHNbMV0sXG4gICAgICAgICAgICBoYW5kbGVyOiBhcmd1bWVudHNbMl1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgT2JqZWN0LmtleXMoVGVybWluYWwuZGVmYXVsdHMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAob3B0aW9uc1trZXldID09IG51bGwpIHtcbiAgICAgICAgICAgIG9wdGlvbnNba2V5XSA9IFRlcm1pbmFsLm9wdGlvbnNba2V5XTtcbiAgICAgICAgICAgIGlmIChUZXJtaW5hbFtrZXldICE9PSBUZXJtaW5hbC5kZWZhdWx0c1trZXldKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uc1trZXldID0gVGVybWluYWxba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzZWxmW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgfSk7XG4gICAgaWYgKG9wdGlvbnMuY29sb3JzLmxlbmd0aCA9PT0gOCkge1xuICAgICAgICBvcHRpb25zLmNvbG9ycyA9IG9wdGlvbnMuY29sb3JzLmNvbmNhdChUZXJtaW5hbC5fY29sb3JzLnNsaWNlKDgpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAob3B0aW9ucy5jb2xvcnMubGVuZ3RoID09PSAxNikge1xuICAgICAgICBvcHRpb25zLmNvbG9ycyA9IG9wdGlvbnMuY29sb3JzLmNvbmNhdChUZXJtaW5hbC5fY29sb3JzLnNsaWNlKDE2KSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG9wdGlvbnMuY29sb3JzLmxlbmd0aCA9PT0gMTApIHtcbiAgICAgICAgb3B0aW9ucy5jb2xvcnMgPSBvcHRpb25zLmNvbG9ycy5zbGljZSgwLCAtMikuY29uY2F0KFRlcm1pbmFsLl9jb2xvcnMuc2xpY2UoOCwgLTIpLCBvcHRpb25zLmNvbG9ycy5zbGljZSgtMikpO1xuICAgIH1cbiAgICBlbHNlIGlmIChvcHRpb25zLmNvbG9ycy5sZW5ndGggPT09IDE4KSB7XG4gICAgICAgIG9wdGlvbnMuY29sb3JzID0gb3B0aW9ucy5jb2xvcnMuY29uY2F0KFRlcm1pbmFsLl9jb2xvcnMuc2xpY2UoMTYsIC0yKSwgb3B0aW9ucy5jb2xvcnMuc2xpY2UoLTIpKTtcbiAgICB9XG4gICAgdGhpcy5jb2xvcnMgPSBvcHRpb25zLmNvbG9ycztcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIC8vIHRoaXMuY29udGV4dCA9IG9wdGlvbnMuY29udGV4dCB8fCB3aW5kb3c7XG4gICAgLy8gdGhpcy5kb2N1bWVudCA9IG9wdGlvbnMuZG9jdW1lbnQgfHwgZG9jdW1lbnQ7XG4gICAgdGhpcy5wYXJlbnQgPSBvcHRpb25zLmJvZHkgfHwgb3B0aW9ucy5wYXJlbnQgfHwgKGRvY3VtZW50ID8gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2JvZHknKVswXSA6IG51bGwpO1xuICAgIHRoaXMuY29scyA9IG9wdGlvbnMuY29scyB8fCBvcHRpb25zLmdlb21ldHJ5WzBdO1xuICAgIHRoaXMucm93cyA9IG9wdGlvbnMucm93cyB8fCBvcHRpb25zLmdlb21ldHJ5WzFdO1xuICAgIHRoaXMuZ2VvbWV0cnkgPSBbdGhpcy5jb2xzLCB0aGlzLnJvd3NdO1xuICAgIGlmIChvcHRpb25zLmhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5vbignZGF0YScsIG9wdGlvbnMuaGFuZGxlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBzY3JvbGwgcG9zaXRpb24gb2YgdGhlIHkgY3Vyc29yLCBpZS4geWJhc2UgKyB5ID0gdGhlIHkgcG9zaXRpb24gd2l0aGluIHRoZSBlbnRpcmVcbiAgICAgKiBidWZmZXJcbiAgICAgKi9cbiAgICB0aGlzLnliYXNlID0gMDtcbiAgICAvKipcbiAgICAgKiBUaGUgc2Nyb2xsIHBvc2l0aW9uIG9mIHRoZSB2aWV3cG9ydFxuICAgICAqL1xuICAgIHRoaXMueWRpc3AgPSAwO1xuICAgIC8qKlxuICAgICAqIFRoZSBjdXJzb3IncyB4IHBvc2l0aW9uIGFmdGVyIHliYXNlXG4gICAgICovXG4gICAgdGhpcy54ID0gMDtcbiAgICAvKipcbiAgICAgKiBUaGUgY3Vyc29yJ3MgeSBwb3NpdGlvbiBhZnRlciB5YmFzZVxuICAgICAqL1xuICAgIHRoaXMueSA9IDA7XG4gICAgLyoqXG4gICAgICogVXNlZCB0byBkZWJvdW5jZSB0aGUgcmVmcmVzaCBmdW5jdGlvblxuICAgICAqL1xuICAgIHRoaXMuaXNSZWZyZXNoaW5nID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGVyZSBpcyBhIGZ1bGwgdGVybWluYWwgcmVmcmVzaCBxdWV1ZWRcbiAgICAgKi9cbiAgICB0aGlzLmN1cnNvclN0YXRlID0gMDtcbiAgICB0aGlzLmN1cnNvckhpZGRlbiA9IGZhbHNlO1xuICAgIHRoaXMuY29udmVydEVvbDtcbiAgICB0aGlzLnN0YXRlID0gMDtcbiAgICB0aGlzLnF1ZXVlID0gJyc7XG4gICAgdGhpcy5zY3JvbGxUb3AgPSAwO1xuICAgIHRoaXMuc2Nyb2xsQm90dG9tID0gdGhpcy5yb3dzIC0gMTtcbiAgICB0aGlzLmN1c3RvbUtleWRvd25IYW5kbGVyID0gbnVsbDtcbiAgICAvLyBtb2Rlc1xuICAgIHRoaXMuYXBwbGljYXRpb25LZXlwYWQgPSBmYWxzZTtcbiAgICB0aGlzLmFwcGxpY2F0aW9uQ3Vyc29yID0gZmFsc2U7XG4gICAgdGhpcy5vcmlnaW5Nb2RlID0gZmFsc2U7XG4gICAgdGhpcy5pbnNlcnRNb2RlID0gZmFsc2U7XG4gICAgdGhpcy53cmFwYXJvdW5kTW9kZSA9IHRydWU7IC8vIGRlZmF1bHRzOiB4dGVybSAtIHRydWUsIHZ0MTAwIC0gZmFsc2VcbiAgICB0aGlzLm5vcm1hbCA9IG51bGw7XG4gICAgLy8gY2hhcnNldFxuICAgIHRoaXMuY2hhcnNldCA9IG51bGw7XG4gICAgdGhpcy5nY2hhcnNldCA9IG51bGw7XG4gICAgdGhpcy5nbGV2ZWwgPSAwO1xuICAgIHRoaXMuY2hhcnNldHMgPSBbbnVsbF07XG4gICAgLy8gbW91c2UgcHJvcGVydGllc1xuICAgIHRoaXMuZGVjTG9jYXRvcjtcbiAgICB0aGlzLngxME1vdXNlO1xuICAgIHRoaXMudnQyMDBNb3VzZTtcbiAgICB0aGlzLnZ0MzAwTW91c2U7XG4gICAgdGhpcy5ub3JtYWxNb3VzZTtcbiAgICB0aGlzLm1vdXNlRXZlbnRzO1xuICAgIHRoaXMuc2VuZEZvY3VzO1xuICAgIHRoaXMudXRmTW91c2U7XG4gICAgdGhpcy5zZ3JNb3VzZTtcbiAgICB0aGlzLnVyeHZ0TW91c2U7XG4gICAgLy8gbWlzY1xuICAgIHRoaXMuZWxlbWVudDtcbiAgICB0aGlzLmNoaWxkcmVuO1xuICAgIHRoaXMucmVmcmVzaFN0YXJ0O1xuICAgIHRoaXMucmVmcmVzaEVuZDtcbiAgICB0aGlzLnNhdmVkWDtcbiAgICB0aGlzLnNhdmVkWTtcbiAgICB0aGlzLnNhdmVkQ29scztcbiAgICAvLyBzdHJlYW1cbiAgICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTtcbiAgICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcbiAgICB0aGlzLmRlZkF0dHIgPSAoMCA8PCAxOCkgfCAoMjU3IDw8IDkpIHwgKDI1NiA8PCAwKTtcbiAgICB0aGlzLmN1ckF0dHIgPSB0aGlzLmRlZkF0dHI7XG4gICAgdGhpcy5wYXJhbXMgPSBbXTtcbiAgICB0aGlzLmN1cnJlbnRQYXJhbSA9IDA7XG4gICAgdGhpcy5wcmVmaXggPSAnJztcbiAgICB0aGlzLnBvc3RmaXggPSAnJztcbiAgICAvLyBsZWZ0b3ZlciBzdXJyb2dhdGUgaGlnaCBmcm9tIHByZXZpb3VzIHdyaXRlIGludm9jYXRpb25cbiAgICB0aGlzLnN1cnJvZ2F0ZV9oaWdoID0gJyc7XG4gICAgLyoqXG4gICAgICogQW4gYXJyYXkgb2YgYWxsIGxpbmVzIGluIHRoZSBlbnRpcmUgYnVmZmVyLCBpbmNsdWRpbmcgdGhlIHByb21wdC4gVGhlIGxpbmVzIGFyZSBhcnJheSBvZlxuICAgICAqIGNoYXJhY3RlcnMgd2hpY2ggYXJlIDItbGVuZ3RoIGFycmF5cyB3aGVyZSBbMF0gaXMgYW4gYXR0cmlidXRlIGFuZCBbMV0gaXMgdGhlIGNoYXJhY3Rlci5cbiAgICAgKi9cbiAgICB0aGlzLmxpbmVzID0gW107XG4gICAgdmFyIGkgPSB0aGlzLnJvd3M7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgICB0aGlzLmxpbmVzLnB1c2godGhpcy5ibGFua0xpbmUoKSk7XG4gICAgfVxuICAgIHRoaXMudGFicztcbiAgICB0aGlzLnNldHVwU3RvcHMoKTtcbiAgICAvLyBTdG9yZSBpZiB1c2VyIHdlbnQgYnJvd3NpbmcgaGlzdG9yeSBpbiBzY3JvbGxiYWNrXG4gICAgdGhpcy51c2VyU2Nyb2xsaW5nID0gZmFsc2U7XG59XG5pbmhlcml0cyhUZXJtaW5hbCwgRXZlbnRFbWl0dGVyX2pzXzEuRXZlbnRFbWl0dGVyKTtcbi8qKlxuICogYmFja19jb2xvcl9lcmFzZSBmZWF0dXJlIGZvciB4dGVybS5cbiAqL1xuVGVybWluYWwucHJvdG90eXBlLmVyYXNlQXR0ciA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBpZiAodGhpcy5pcygnc2NyZWVuJykpIHJldHVybiB0aGlzLmRlZkF0dHI7XG4gICAgcmV0dXJuICh0aGlzLmRlZkF0dHIgJiB+MHgxZmYpIHwgKHRoaXMuY3VyQXR0ciAmIDB4MWZmKTtcbn07XG4vKipcbiAqIENvbG9yc1xuICovXG4vLyBDb2xvcnMgMC0xNVxuVGVybWluYWwudGFuZ29Db2xvcnMgPSBbXG4gICAgLy8gZGFyazpcbiAgICAnIzJlMzQzNicsXG4gICAgJyNjYzAwMDAnLFxuICAgICcjNGU5YTA2JyxcbiAgICAnI2M0YTAwMCcsXG4gICAgJyMzNDY1YTQnLFxuICAgICcjNzU1MDdiJyxcbiAgICAnIzA2OTg5YScsXG4gICAgJyNkM2Q3Y2YnLFxuICAgIC8vIGJyaWdodDpcbiAgICAnIzU1NTc1MycsXG4gICAgJyNlZjI5MjknLFxuICAgICcjOGFlMjM0JyxcbiAgICAnI2ZjZTk0ZicsXG4gICAgJyM3MjlmY2YnLFxuICAgICcjYWQ3ZmE4JyxcbiAgICAnIzM0ZTJlMicsXG4gICAgJyNlZWVlZWMnXG5dO1xuLy8gQ29sb3JzIDAtMTUgKyAxNi0yNTVcbi8vIE11Y2ggdGhhbmtzIHRvIFRvb1RhbGxOYXRlIGZvciB3cml0aW5nIHRoaXMuXG5UZXJtaW5hbC5jb2xvcnMgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBjb2xvcnMgPSBUZXJtaW5hbC50YW5nb0NvbG9ycy5zbGljZSgpLCByID0gWzB4MDAsIDB4NWYsIDB4ODcsIDB4YWYsIDB4ZDcsIDB4ZmZdLCBpO1xuICAgIC8vIDE2LTIzMVxuICAgIGkgPSAwO1xuICAgIGZvciAoOyBpIDwgMjE2OyBpKyspIHtcbiAgICAgICAgb3V0KHJbKGkgLyAzNikgJSA2IHwgMF0sIHJbKGkgLyA2KSAlIDYgfCAwXSwgcltpICUgNl0pO1xuICAgIH1cbiAgICAvLyAyMzItMjU1IChncmV5KVxuICAgIGkgPSAwO1xuICAgIGZvciAoOyBpIDwgMjQ7IGkrKykge1xuICAgICAgICByID0gOCArIGkgKiAxMDtcbiAgICAgICAgb3V0KHIsIHIsIHIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvdXQociwgZywgYikge1xuICAgICAgICBjb2xvcnMucHVzaCgnIycgKyBoZXgocikgKyBoZXgoZykgKyBoZXgoYikpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoZXgoYykge1xuICAgICAgICBjID0gYy50b1N0cmluZygxNik7XG4gICAgICAgIHJldHVybiBjLmxlbmd0aCA8IDIgPyAnMCcgKyBjIDogYztcbiAgICB9XG4gICAgcmV0dXJuIGNvbG9ycztcbn0pKCk7XG5UZXJtaW5hbC5fY29sb3JzID0gVGVybWluYWwuY29sb3JzLnNsaWNlKCk7XG5UZXJtaW5hbC52Y29sb3JzID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3V0ID0gW10sIGNvbG9ycyA9IFRlcm1pbmFsLmNvbG9ycywgaSA9IDAsIGNvbG9yO1xuICAgIGZvciAoOyBpIDwgMjU2OyBpKyspIHtcbiAgICAgICAgY29sb3IgPSBwYXJzZUludChjb2xvcnNbaV0uc3Vic3RyaW5nKDEpLCAxNik7XG4gICAgICAgIG91dC5wdXNoKFtcbiAgICAgICAgICAgIChjb2xvciA+PiAxNikgJiAweGZmLFxuICAgICAgICAgICAgKGNvbG9yID4+IDgpICYgMHhmZixcbiAgICAgICAgICAgIGNvbG9yICYgMHhmZlxuICAgICAgICBdKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn0pKCk7XG4vKipcbiAqIE9wdGlvbnNcbiAqL1xuVGVybWluYWwuZGVmYXVsdHMgPSB7XG4gICAgY29sb3JzOiBUZXJtaW5hbC5jb2xvcnMsXG4gICAgdGhlbWU6ICdkZWZhdWx0JyxcbiAgICBjb252ZXJ0RW9sOiBmYWxzZSxcbiAgICB0ZXJtTmFtZTogJ3h0ZXJtJyxcbiAgICBnZW9tZXRyeTogWzgwLCAyNF0sXG4gICAgY3Vyc29yQmxpbms6IGZhbHNlLFxuICAgIHZpc3VhbEJlbGw6IGZhbHNlLFxuICAgIHBvcE9uQmVsbDogZmFsc2UsXG4gICAgc2Nyb2xsYmFjazogMTAwMCxcbiAgICBzY3JlZW5LZXlzOiBmYWxzZSxcbiAgICBkZWJ1ZzogZmFsc2UsXG4gICAgY2FuY2VsRXZlbnRzOiBmYWxzZVxufTtcblRlcm1pbmFsLm9wdGlvbnMgPSB7fTtcblRlcm1pbmFsLmZvY3VzID0gbnVsbDtcbmVhY2goa2V5cyhUZXJtaW5hbC5kZWZhdWx0cyksIGZ1bmN0aW9uIChrZXkpIHtcbiAgICBUZXJtaW5hbFtrZXldID0gVGVybWluYWwuZGVmYXVsdHNba2V5XTtcbiAgICBUZXJtaW5hbC5vcHRpb25zW2tleV0gPSBUZXJtaW5hbC5kZWZhdWx0c1trZXldO1xufSk7XG4vKipcbiAqIEZvY3VzIHRoZSB0ZXJtaW5hbC4gRGVsZWdhdGVzIGZvY3VzIGhhbmRsaW5nIHRvIHRoZSB0ZXJtaW5hbCdzIERPTSBlbGVtZW50LlxuICovXG5UZXJtaW5hbC5wcm90b3R5cGUuZm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudGV4dGFyZWEuZm9jdXMoKTtcbn07XG4vKipcbiAqIFJldHJpZXZlcyBhbiBvcHRpb24ncyB2YWx1ZSBmcm9tIHRoZSB0ZXJtaW5hbC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIG9wdGlvbiBrZXkuXG4gKi9cblRlcm1pbmFsLnByb3RvdHlwZS5nZXRPcHRpb24gPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIGlmICghKGtleSBpbiBUZXJtaW5hbC5kZWZhdWx0cykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBvcHRpb24gd2l0aCBrZXkgXCInICsga2V5ICsgJ1wiJyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zW2tleV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNba2V5XTtcbn07XG4vKipcbiAqIFNldHMgYW4gb3B0aW9uIG9uIHRoZSB0ZXJtaW5hbC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIG9wdGlvbiBrZXkuXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgVGhlIG9wdGlvbiB2YWx1ZS5cbiAqL1xuVGVybWluYWwucHJvdG90eXBlLnNldE9wdGlvbiA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgaWYgKCEoa2V5IGluIFRlcm1pbmFsLmRlZmF1bHRzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIG9wdGlvbiB3aXRoIGtleSBcIicgKyBrZXkgKyAnXCInKTtcbiAgICB9XG4gICAgdGhpc1trZXldID0gdmFsdWU7XG4gICAgdGhpcy5vcHRpb25zW2tleV0gPSB2YWx1ZTtcbn07XG4vKipcbiAqIEJpbmRzIHRoZSBkZXNpcmVkIGZvY3VzIGJlaGF2aW9yIG9uIGEgZ2l2ZW4gdGVybWluYWwgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqL1xuVGVybWluYWwuYmluZEZvY3VzID0gZnVuY3Rpb24gKHRlcm0pIHtcbiAgICBvbih0ZXJtLnRleHRhcmVhLCAnZm9jdXMnLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgaWYgKHRlcm0uc2VuZEZvY3VzKSB7XG4gICAgICAgICAgICB0ZXJtLnNlbmQoJ1xceDFiW0knKTtcbiAgICAgICAgfVxuICAgICAgICB0ZXJtLmVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnZm9jdXMnKTtcbiAgICAgICAgdGVybS5zaG93Q3Vyc29yKCk7XG4gICAgICAgIFRlcm1pbmFsLmZvY3VzID0gdGVybTtcbiAgICAgICAgdGVybS5lbWl0KCdmb2N1cycsIHsgdGVybWluYWw6IHRlcm0gfSk7XG4gICAgfSk7XG59O1xuLyoqXG4gKiBCbHVyIHRoZSB0ZXJtaW5hbC4gRGVsZWdhdGVzIGJsdXIgaGFuZGxpbmcgdG8gdGhlIHRlcm1pbmFsJ3MgRE9NIGVsZW1lbnQuXG4gKi9cblRlcm1pbmFsLnByb3RvdHlwZS5ibHVyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnRleHRhcmVhLmJsdXIoKTtcbn07XG4vKipcbiAqIEJpbmRzIHRoZSBkZXNpcmVkIGJsdXIgYmVoYXZpb3Igb24gYSBnaXZlbiB0ZXJtaW5hbCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICovXG5UZXJtaW5hbC5iaW5kQmx1ciA9IGZ1bmN0aW9uICh0ZXJtKSB7XG4gICAgb24odGVybS50ZXh0YXJlYSwgJ2JsdXInLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgdGVybS5yZWZyZXNoKHRlcm0ueSwgdGVybS55KTtcbiAgICAgICAgaWYgKHRlcm0uc2VuZEZvY3VzKSB7XG4gICAgICAgICAgICB0ZXJtLnNlbmQoJ1xceDFiW08nKTtcbiAgICAgICAgfVxuICAgICAgICB0ZXJtLmVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnZm9jdXMnKTtcbiAgICAgICAgVGVybWluYWwuZm9jdXMgPSBudWxsO1xuICAgICAgICB0ZXJtLmVtaXQoJ2JsdXInLCB7IHRlcm1pbmFsOiB0ZXJtIH0pO1xuICAgIH0pO1xufTtcbi8qKlxuICogSW5pdGlhbGl6ZSBkZWZhdWx0IGJlaGF2aW9yXG4gKi9cblRlcm1pbmFsLnByb3RvdHlwZS5pbml0R2xvYmFsID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB0ZXJtID0gdGhpcztcbiAgICBUZXJtaW5hbC5iaW5kS2V5cyh0aGlzKTtcbiAgICBUZXJtaW5hbC5iaW5kRm9jdXModGhpcyk7XG4gICAgVGVybWluYWwuYmluZEJsdXIodGhpcyk7XG4gICAgLy8gQmluZCBjbGlwYm9hcmQgZnVuY3Rpb25hbGl0eVxuICAgIG9uKHRoaXMuZWxlbWVudCwgJ2NvcHknLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgQ2xpcGJvYXJkX2pzXzEuY29weUhhbmRsZXIuY2FsbCh0aGlzLCBldiwgdGVybSk7XG4gICAgfSk7XG4gICAgb24odGhpcy50ZXh0YXJlYSwgJ3Bhc3RlJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgIENsaXBib2FyZF9qc18xLnBhc3RlSGFuZGxlci5jYWxsKHRoaXMsIGV2LCB0ZXJtKTtcbiAgICB9KTtcbiAgICBvbih0aGlzLmVsZW1lbnQsICdwYXN0ZScsIGZ1bmN0aW9uIChldikge1xuICAgICAgICBDbGlwYm9hcmRfanNfMS5wYXN0ZUhhbmRsZXIuY2FsbCh0aGlzLCBldiwgdGVybSk7XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gcmlnaHRDbGlja0hhbmRsZXJXcmFwcGVyKGV2KSB7XG4gICAgICAgIENsaXBib2FyZF9qc18xLnJpZ2h0Q2xpY2tIYW5kbGVyLmNhbGwodGhpcywgZXYsIHRlcm0pO1xuICAgIH1cbiAgICBpZiAodGVybS5icm93c2VyLmlzRmlyZWZveCkge1xuICAgICAgICBvbih0aGlzLmVsZW1lbnQsICdtb3VzZWRvd24nLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIGlmIChldi5idXR0b24gPT0gMikge1xuICAgICAgICAgICAgICAgIHJpZ2h0Q2xpY2tIYW5kbGVyV3JhcHBlcihldik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgb24odGhpcy5lbGVtZW50LCAnY29udGV4dG1lbnUnLCByaWdodENsaWNrSGFuZGxlcldyYXBwZXIpO1xuICAgIH1cbn07XG4vKipcbiAqIEFwcGx5IGtleSBoYW5kbGluZyB0byB0aGUgdGVybWluYWxcbiAqL1xuVGVybWluYWwuYmluZEtleXMgPSBmdW5jdGlvbiAodGVybSkge1xuICAgIG9uKHRlcm0uZWxlbWVudCwgJ2tleWRvd24nLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT0gdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRlcm0ua2V5RG93bihldik7XG4gICAgfSwgdHJ1ZSk7XG4gICAgb24odGVybS5lbGVtZW50LCAna2V5cHJlc3MnLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT0gdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRlcm0ua2V5UHJlc3MoZXYpO1xuICAgIH0sIHRydWUpO1xuICAgIG9uKHRlcm0uZWxlbWVudCwgJ2tleXVwJywgdGVybS5mb2N1cy5iaW5kKHRlcm0pKTtcbiAgICBvbih0ZXJtLnRleHRhcmVhLCAna2V5ZG93bicsIGZ1bmN0aW9uIChldikge1xuICAgICAgICB0ZXJtLmtleURvd24oZXYpO1xuICAgIH0sIHRydWUpO1xuICAgIG9uKHRlcm0udGV4dGFyZWEsICdrZXlwcmVzcycsIGZ1bmN0aW9uIChldikge1xuICAgICAgICB0ZXJtLmtleVByZXNzKGV2KTtcbiAgICAgICAgLy8gVHJ1bmNhdGUgdGhlIHRleHRhcmVhJ3MgdmFsdWUsIHNpbmNlIGl0IGlzIG5vdCBuZWVkZWRcbiAgICAgICAgdGhpcy52YWx1ZSA9ICcnO1xuICAgIH0sIHRydWUpO1xuICAgIG9uKHRlcm0udGV4dGFyZWEsICdjb21wb3NpdGlvbnN0YXJ0JywgdGVybS5jb21wb3NpdGlvbkhlbHBlci5jb21wb3NpdGlvbnN0YXJ0LmJpbmQodGVybS5jb21wb3NpdGlvbkhlbHBlcikpO1xuICAgIG9uKHRlcm0udGV4dGFyZWEsICdjb21wb3NpdGlvbnVwZGF0ZScsIHRlcm0uY29tcG9zaXRpb25IZWxwZXIuY29tcG9zaXRpb251cGRhdGUuYmluZCh0ZXJtLmNvbXBvc2l0aW9uSGVscGVyKSk7XG4gICAgb24odGVybS50ZXh0YXJlYSwgJ2NvbXBvc2l0aW9uZW5kJywgdGVybS5jb21wb3NpdGlvbkhlbHBlci5jb21wb3NpdGlvbmVuZC5iaW5kKHRlcm0uY29tcG9zaXRpb25IZWxwZXIpKTtcbiAgICB0ZXJtLm9uKCdyZWZyZXNoJywgdGVybS5jb21wb3NpdGlvbkhlbHBlci51cGRhdGVDb21wb3NpdGlvbkVsZW1lbnRzLmJpbmQodGVybS5jb21wb3NpdGlvbkhlbHBlcikpO1xufTtcbi8qKlxuICogSW5zZXJ0IHRoZSBnaXZlbiByb3cgdG8gdGhlIHRlcm1pbmFsIG9yIHByb2R1Y2UgYSBuZXcgb25lXG4gKiBpZiBubyByb3cgYXJndW1lbnQgaXMgcGFzc2VkLiBSZXR1cm4gdGhlIGluc2VydGVkIHJvdy5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHJvdyAob3B0aW9uYWwpIFRoZSByb3cgdG8gYXBwZW5kIHRvIHRoZSB0ZXJtaW5hbC5cbiAqL1xuVGVybWluYWwucHJvdG90eXBlLmluc2VydFJvdyA9IGZ1bmN0aW9uIChyb3cpIHtcbiAgICBpZiAodHlwZW9mIHJvdyAhPSAnb2JqZWN0Jykge1xuICAgICAgICByb3cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB9XG4gICAgdGhpcy5yb3dDb250YWluZXIuYXBwZW5kQ2hpbGQocm93KTtcbiAgICB0aGlzLmNoaWxkcmVuLnB1c2gocm93KTtcbiAgICByZXR1cm4gcm93O1xufTtcbi8qKlxuICogT3BlbnMgdGhlIHRlcm1pbmFsIHdpdGhpbiBhbiBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBhcmVudCBUaGUgZWxlbWVudCB0byBjcmVhdGUgdGhlIHRlcm1pbmFsIHdpdGhpbi5cbiAqL1xuVGVybWluYWwucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAocGFyZW50KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLCBpID0gMCwgZGl2O1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50IHx8IHRoaXMucGFyZW50O1xuICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUZXJtaW5hbCByZXF1aXJlcyBhIHBhcmVudCBlbGVtZW50LicpO1xuICAgIH1cbiAgICAvLyBHcmFiIGdsb2JhbCBlbGVtZW50c1xuICAgIHRoaXMuY29udGV4dCA9IHRoaXMucGFyZW50Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gICAgdGhpcy5kb2N1bWVudCA9IHRoaXMucGFyZW50Lm93bmVyRG9jdW1lbnQ7XG4gICAgdGhpcy5ib2R5ID0gdGhpcy5kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYm9keScpWzBdO1xuICAgIC8vQ3JlYXRlIG1haW4gZWxlbWVudCBjb250YWluZXJcbiAgICB0aGlzLmVsZW1lbnQgPSB0aGlzLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKCd0ZXJtaW5hbCcpO1xuICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKCd4dGVybScpO1xuICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKCd4dGVybS10aGVtZS0nICsgdGhpcy50aGVtZSk7XG4gICAgdGhpcy5lbGVtZW50LnN0eWxlLmhlaWdodDtcbiAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsIDApO1xuICAgIHRoaXMudmlld3BvcnRFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy52aWV3cG9ydEVsZW1lbnQuY2xhc3NMaXN0LmFkZCgneHRlcm0tdmlld3BvcnQnKTtcbiAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy52aWV3cG9ydEVsZW1lbnQpO1xuICAgIHRoaXMudmlld3BvcnRTY3JvbGxBcmVhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy52aWV3cG9ydFNjcm9sbEFyZWEuY2xhc3NMaXN0LmFkZCgneHRlcm0tc2Nyb2xsLWFyZWEnKTtcbiAgICB0aGlzLnZpZXdwb3J0RWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLnZpZXdwb3J0U2Nyb2xsQXJlYSk7XG4gICAgLy8gQ3JlYXRlIHRoZSBjb250YWluZXIgdGhhdCB3aWxsIGhvbGQgdGhlIGxpbmVzIG9mIHRoZSB0ZXJtaW5hbCBhbmQgdGhlblxuICAgIC8vIHByb2R1Y2UgdGhlIGxpbmVzIHRoZSBsaW5lcy5cbiAgICB0aGlzLnJvd0NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMucm93Q29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ3h0ZXJtLXJvd3MnKTtcbiAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5yb3dDb250YWluZXIpO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICAvLyBDcmVhdGUgdGhlIGNvbnRhaW5lciB0aGF0IHdpbGwgaG9sZCBoZWxwZXJzIGxpa2UgdGhlIHRleHRhcmVhIGZvclxuICAgIC8vIGNhcHR1cmluZyBET00gRXZlbnRzLiBUaGVuIHByb2R1Y2UgdGhlIGhlbHBlcnMuXG4gICAgdGhpcy5oZWxwZXJDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLmhlbHBlckNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCd4dGVybS1oZWxwZXJzJyk7XG4gICAgLy8gVE9ETzogVGhpcyBzaG91bGQgcHJvYmFibHkgYmUgaW5zZXJ0ZWQgb25jZSBpdCdzIGZpbGxlZCB0byBwcmV2ZW50IGFuIGFkZGl0aW9uYWwgbGF5b3V0XG4gICAgdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuaGVscGVyQ29udGFpbmVyKTtcbiAgICB0aGlzLnRleHRhcmVhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGV4dGFyZWEnKTtcbiAgICB0aGlzLnRleHRhcmVhLmNsYXNzTGlzdC5hZGQoJ3h0ZXJtLWhlbHBlci10ZXh0YXJlYScpO1xuICAgIHRoaXMudGV4dGFyZWEuc2V0QXR0cmlidXRlKCdhdXRvY29ycmVjdCcsICdvZmYnKTtcbiAgICB0aGlzLnRleHRhcmVhLnNldEF0dHJpYnV0ZSgnYXV0b2NhcGl0YWxpemUnLCAnb2ZmJyk7XG4gICAgdGhpcy50ZXh0YXJlYS5zZXRBdHRyaWJ1dGUoJ3NwZWxsY2hlY2snLCAnZmFsc2UnKTtcbiAgICB0aGlzLnRleHRhcmVhLnRhYkluZGV4ID0gMDtcbiAgICB0aGlzLnRleHRhcmVhLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLmVtaXQoJ2ZvY3VzJywgeyB0ZXJtaW5hbDogc2VsZiB9KTtcbiAgICB9KTtcbiAgICB0aGlzLnRleHRhcmVhLmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuZW1pdCgnYmx1cicsIHsgdGVybWluYWw6IHNlbGYgfSk7XG4gICAgfSk7XG4gICAgdGhpcy5oZWxwZXJDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy50ZXh0YXJlYSk7XG4gICAgdGhpcy5jb21wb3NpdGlvblZpZXcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLmNvbXBvc2l0aW9uVmlldy5jbGFzc0xpc3QuYWRkKCdjb21wb3NpdGlvbi12aWV3Jyk7XG4gICAgdGhpcy5jb21wb3NpdGlvbkhlbHBlciA9IG5ldyBDb21wb3NpdGlvbkhlbHBlcl9qc18xLkNvbXBvc2l0aW9uSGVscGVyKHRoaXMudGV4dGFyZWEsIHRoaXMuY29tcG9zaXRpb25WaWV3LCB0aGlzKTtcbiAgICB0aGlzLmhlbHBlckNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmNvbXBvc2l0aW9uVmlldyk7XG4gICAgdGhpcy5jaGFyTWVhc3VyZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLmNoYXJNZWFzdXJlRWxlbWVudC5jbGFzc0xpc3QuYWRkKCd4dGVybS1jaGFyLW1lYXN1cmUtZWxlbWVudCcpO1xuICAgIHRoaXMuY2hhck1lYXN1cmVFbGVtZW50LmlubmVySFRNTCA9ICdXJztcbiAgICB0aGlzLmhlbHBlckNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmNoYXJNZWFzdXJlRWxlbWVudCk7XG4gICAgZm9yICg7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgICB0aGlzLmluc2VydFJvdygpO1xuICAgIH1cbiAgICB0aGlzLnBhcmVudC5hcHBlbmRDaGlsZCh0aGlzLmVsZW1lbnQpO1xuICAgIHRoaXMudmlld3BvcnQgPSBuZXcgVmlld3BvcnRfanNfMS5WaWV3cG9ydCh0aGlzLCB0aGlzLnZpZXdwb3J0RWxlbWVudCwgdGhpcy52aWV3cG9ydFNjcm9sbEFyZWEsIHRoaXMuY2hhck1lYXN1cmVFbGVtZW50KTtcbiAgICAvLyBEcmF3IHRoZSBzY3JlZW4uXG4gICAgdGhpcy5yZWZyZXNoKDAsIHRoaXMucm93cyAtIDEpO1xuICAgIC8vIEluaXRpYWxpemUgZ2xvYmFsIGFjdGlvbnMgdGhhdFxuICAgIC8vIG5lZWQgdG8gYmUgdGFrZW4gb24gdGhlIGRvY3VtZW50LlxuICAgIHRoaXMuaW5pdEdsb2JhbCgpO1xuICAgIC8vIEVuc3VyZSB0aGVyZSBpcyBhIFRlcm1pbmFsLmZvY3VzLlxuICAgIHRoaXMuZm9jdXMoKTtcbiAgICBvbih0aGlzLmVsZW1lbnQsICdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNlbGVjdGlvbiA9IGRvY3VtZW50LmdldFNlbGVjdGlvbigpLCBjb2xsYXBzZWQgPSBzZWxlY3Rpb24uaXNDb2xsYXBzZWQsIGlzUmFuZ2UgPSB0eXBlb2YgY29sbGFwc2VkID09ICdib29sZWFuJyA/ICFjb2xsYXBzZWQgOiBzZWxlY3Rpb24udHlwZSA9PSAnUmFuZ2UnO1xuICAgICAgICBpZiAoIWlzUmFuZ2UpIHtcbiAgICAgICAgICAgIHNlbGYuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vIExpc3RlbiBmb3IgbW91c2UgZXZlbnRzIGFuZCB0cmFuc2xhdGVcbiAgICAvLyB0aGVtIGludG8gdGVybWluYWwgbW91c2UgcHJvdG9jb2xzLlxuICAgIHRoaXMuYmluZE1vdXNlKCk7XG4gICAgLy8gRmlndXJlIG91dCB3aGV0aGVyIGJvbGRuZXNzIGFmZmVjdHNcbiAgICAvLyB0aGUgY2hhcmFjdGVyIHdpZHRoIG9mIG1vbm9zcGFjZSBmb250cy5cbiAgICBpZiAoVGVybWluYWwuYnJva2VuQm9sZCA9PSBudWxsKSB7XG4gICAgICAgIFRlcm1pbmFsLmJyb2tlbkJvbGQgPSBpc0JvbGRCcm9rZW4odGhpcy5kb2N1bWVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgZXZlbnQgaXMgZW1pdHRlZCB3aGVuIHRlcm1pbmFsIGhhcyBjb21wbGV0ZWQgb3BlbmluZy5cbiAgICAgKlxuICAgICAqIEBldmVudCBvcGVuXG4gICAgICovXG4gICAgdGhpcy5lbWl0KCdvcGVuJyk7XG59O1xuLyoqXG4gKiBBdHRlbXB0cyB0byBsb2FkIGFuIGFkZC1vbiB1c2luZyBDb21tb25KUyBvciBSZXF1aXJlSlMgKHdoaWNoZXZlciBpcyBhdmFpbGFibGUpLlxuICogQHBhcmFtIHtzdHJpbmd9IGFkZG9uIFRoZSBuYW1lIG9mIHRoZSBhZGRvbiB0byBsb2FkXG4gKiBAc3RhdGljXG4gKi9cblRlcm1pbmFsLmxvYWRBZGRvbiA9IGZ1bmN0aW9uIChhZGRvbiwgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8vIENvbW1vbkpTXG4gICAgICAgIHJldHVybiByZXF1aXJlKCcuL2FkZG9ucy8nICsgYWRkb24gKyAnLycgKyBhZGRvbik7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBSZXF1aXJlSlNcbiAgICAgICAgcmV0dXJuIHJlcXVpcmUoWycuL2FkZG9ucy8nICsgYWRkb24gKyAnLycgKyBhZGRvbl0sIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Nhbm5vdCBsb2FkIGEgbW9kdWxlIHdpdGhvdXQgYSBDb21tb25KUyBvciBSZXF1aXJlSlMgZW52aXJvbm1lbnQuJyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59O1xuLyoqXG4gKiBYVGVybSBtb3VzZSBldmVudHNcbiAqIGh0dHA6Ly9pbnZpc2libGUtaXNsYW5kLm5ldC94dGVybS9jdGxzZXFzL2N0bHNlcXMuaHRtbCNNb3VzZSUyMFRyYWNraW5nXG4gKiBUbyBiZXR0ZXIgdW5kZXJzdGFuZCB0aGVzZVxuICogdGhlIHh0ZXJtIGNvZGUgaXMgdmVyeSBoZWxwZnVsOlxuICogUmVsZXZhbnQgZmlsZXM6XG4gKiAgIGJ1dHRvbi5jLCBjaGFycHJvYy5jLCBtaXNjLmNcbiAqIFJlbGV2YW50IGZ1bmN0aW9ucyBpbiB4dGVybS9idXR0b24uYzpcbiAqICAgQnRuQ29kZSwgRW1pdEJ1dHRvbkNvZGUsIEVkaXRvckJ1dHRvbiwgU2VuZE1vdXNlUG9zaXRpb25cbiAqL1xuVGVybWluYWwucHJvdG90eXBlLmJpbmRNb3VzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWwgPSB0aGlzLmVsZW1lbnQsIHNlbGYgPSB0aGlzLCBwcmVzc2VkID0gMzI7XG4gICAgLy8gbW91c2V1cCwgbW91c2Vkb3duLCB3aGVlbFxuICAgIC8vIGxlZnQgY2xpY2s6IF5bW00gMzxeW1tNIzM8XG4gICAgLy8gd2hlZWwgdXA6IF5bW01gMz5cbiAgICBmdW5jdGlvbiBzZW5kQnV0dG9uKGV2KSB7XG4gICAgICAgIHZhciBidXR0b24sIHBvcztcbiAgICAgICAgLy8gZ2V0IHRoZSB4dGVybS1zdHlsZSBidXR0b25cbiAgICAgICAgYnV0dG9uID0gZ2V0QnV0dG9uKGV2KTtcbiAgICAgICAgLy8gZ2V0IG1vdXNlIGNvb3JkaW5hdGVzXG4gICAgICAgIHBvcyA9IGdldENvb3Jkcyhldik7XG4gICAgICAgIGlmICghcG9zKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBzZW5kRXZlbnQoYnV0dG9uLCBwb3MpO1xuICAgICAgICBzd2l0Y2ggKGV2Lm92ZXJyaWRlVHlwZSB8fCBldi50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdtb3VzZWRvd24nOlxuICAgICAgICAgICAgICAgIHByZXNzZWQgPSBidXR0b247XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtb3VzZXVwJzpcbiAgICAgICAgICAgICAgICAvLyBrZWVwIGl0IGF0IHRoZSBsZWZ0XG4gICAgICAgICAgICAgICAgLy8gYnV0dG9uLCBqdXN0IGluIGNhc2UuXG4gICAgICAgICAgICAgICAgcHJlc3NlZCA9IDMyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnd2hlZWwnOlxuICAgICAgICAgICAgICAgIC8vIG5vdGhpbmcuIGRvbid0XG4gICAgICAgICAgICAgICAgLy8gaW50ZXJmZXJlIHdpdGhcbiAgICAgICAgICAgICAgICAvLyBgcHJlc3NlZGAuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gbW90aW9uIGV4YW1wbGUgb2YgYSBsZWZ0IGNsaWNrOlxuICAgIC8vIF5bW00gMzxeW1tNQDQ8XltbTUA1PF5bW01ANjxeW1tNQDc8XltbTSM3PFxuICAgIGZ1bmN0aW9uIHNlbmRNb3ZlKGV2KSB7XG4gICAgICAgIHZhciBidXR0b24gPSBwcmVzc2VkLCBwb3M7XG4gICAgICAgIHBvcyA9IGdldENvb3Jkcyhldik7XG4gICAgICAgIGlmICghcG9zKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBidXR0b25zIG1hcmtlZCBhcyBtb3Rpb25zXG4gICAgICAgIC8vIGFyZSBpbmNyZW1lbnRlZCBieSAzMlxuICAgICAgICBidXR0b24gKz0gMzI7XG4gICAgICAgIHNlbmRFdmVudChidXR0b24sIHBvcyk7XG4gICAgfVxuICAgIC8vIGVuY29kZSBidXR0b24gYW5kXG4gICAgLy8gcG9zaXRpb24gdG8gY2hhcmFjdGVyc1xuICAgIGZ1bmN0aW9uIGVuY29kZShkYXRhLCBjaCkge1xuICAgICAgICBpZiAoIXNlbGYudXRmTW91c2UpIHtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gMjU1KVxuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhLnB1c2goMCk7XG4gICAgICAgICAgICBpZiAoY2ggPiAxMjcpXG4gICAgICAgICAgICAgICAgY2ggPSAxMjc7XG4gICAgICAgICAgICBkYXRhLnB1c2goY2gpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNoID09PSAyMDQ3KVxuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhLnB1c2goMCk7XG4gICAgICAgICAgICBpZiAoY2ggPCAxMjcpIHtcbiAgICAgICAgICAgICAgICBkYXRhLnB1c2goY2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoID4gMjA0NylcbiAgICAgICAgICAgICAgICAgICAgY2ggPSAyMDQ3O1xuICAgICAgICAgICAgICAgIGRhdGEucHVzaCgweEMwIHwgKGNoID4+IDYpKTtcbiAgICAgICAgICAgICAgICBkYXRhLnB1c2goMHg4MCB8IChjaCAmIDB4M0YpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBzZW5kIGEgbW91c2UgZXZlbnQ6XG4gICAgLy8gcmVndWxhci91dGY4OiBeW1tNIENiIEN4IEN5XG4gICAgLy8gdXJ4dnQ6IF5bWyBDYiA7IEN4IDsgQ3kgTVxuICAgIC8vIHNncjogXltbIENiIDsgQ3ggOyBDeSBNL21cbiAgICAvLyB2dDMwMDogXltbIDI0KDEvMy81KX4gWyBDeCAsIEN5IF0gXFxyXG4gICAgLy8gbG9jYXRvcjogQ1NJIFAgZSA7IFAgYiA7IFAgciA7IFAgYyA7IFAgcCAmIHdcbiAgICBmdW5jdGlvbiBzZW5kRXZlbnQoYnV0dG9uLCBwb3MpIHtcbiAgICAgICAgLy8gc2VsZi5lbWl0KCdtb3VzZScsIHtcbiAgICAgICAgLy8gICB4OiBwb3MueCAtIDMyLFxuICAgICAgICAvLyAgIHk6IHBvcy54IC0gMzIsXG4gICAgICAgIC8vICAgYnV0dG9uOiBidXR0b25cbiAgICAgICAgLy8gfSk7XG4gICAgICAgIGlmIChzZWxmLnZ0MzAwTW91c2UpIHtcbiAgICAgICAgICAgIC8vIE5PVEU6IFVuc3RhYmxlLlxuICAgICAgICAgICAgLy8gaHR0cDovL3d3dy52dDEwMC5uZXQvZG9jcy92dDN4eC1ncC9jaGFwdGVyMTUuaHRtbFxuICAgICAgICAgICAgYnV0dG9uICY9IDM7XG4gICAgICAgICAgICBwb3MueCAtPSAzMjtcbiAgICAgICAgICAgIHBvcy55IC09IDMyO1xuICAgICAgICAgICAgdmFyIGRhdGEgPSAnXFx4MWJbMjQnO1xuICAgICAgICAgICAgaWYgKGJ1dHRvbiA9PT0gMClcbiAgICAgICAgICAgICAgICBkYXRhICs9ICcxJztcbiAgICAgICAgICAgIGVsc2UgaWYgKGJ1dHRvbiA9PT0gMSlcbiAgICAgICAgICAgICAgICBkYXRhICs9ICczJztcbiAgICAgICAgICAgIGVsc2UgaWYgKGJ1dHRvbiA9PT0gMilcbiAgICAgICAgICAgICAgICBkYXRhICs9ICc1JztcbiAgICAgICAgICAgIGVsc2UgaWYgKGJ1dHRvbiA9PT0gMylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZGF0YSArPSAnMCc7XG4gICAgICAgICAgICBkYXRhICs9ICd+WycgKyBwb3MueCArICcsJyArIHBvcy55ICsgJ11cXHInO1xuICAgICAgICAgICAgc2VsZi5zZW5kKGRhdGEpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxmLmRlY0xvY2F0b3IpIHtcbiAgICAgICAgICAgIC8vIE5PVEU6IFVuc3RhYmxlLlxuICAgICAgICAgICAgYnV0dG9uICY9IDM7XG4gICAgICAgICAgICBwb3MueCAtPSAzMjtcbiAgICAgICAgICAgIHBvcy55IC09IDMyO1xuICAgICAgICAgICAgaWYgKGJ1dHRvbiA9PT0gMClcbiAgICAgICAgICAgICAgICBidXR0b24gPSAyO1xuICAgICAgICAgICAgZWxzZSBpZiAoYnV0dG9uID09PSAxKVxuICAgICAgICAgICAgICAgIGJ1dHRvbiA9IDQ7XG4gICAgICAgICAgICBlbHNlIGlmIChidXR0b24gPT09IDIpXG4gICAgICAgICAgICAgICAgYnV0dG9uID0gNjtcbiAgICAgICAgICAgIGVsc2UgaWYgKGJ1dHRvbiA9PT0gMylcbiAgICAgICAgICAgICAgICBidXR0b24gPSAzO1xuICAgICAgICAgICAgc2VsZi5zZW5kKCdcXHgxYlsnXG4gICAgICAgICAgICAgICAgKyBidXR0b25cbiAgICAgICAgICAgICAgICArICc7J1xuICAgICAgICAgICAgICAgICsgKGJ1dHRvbiA9PT0gMyA/IDQgOiAwKVxuICAgICAgICAgICAgICAgICsgJzsnXG4gICAgICAgICAgICAgICAgKyBwb3MueVxuICAgICAgICAgICAgICAgICsgJzsnXG4gICAgICAgICAgICAgICAgKyBwb3MueFxuICAgICAgICAgICAgICAgICsgJzsnXG4gICAgICAgICAgICAgICAgKyAocG9zLnBhZ2UgfHwgMClcbiAgICAgICAgICAgICAgICArICcmdycpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxmLnVyeHZ0TW91c2UpIHtcbiAgICAgICAgICAgIHBvcy54IC09IDMyO1xuICAgICAgICAgICAgcG9zLnkgLT0gMzI7XG4gICAgICAgICAgICBwb3MueCsrO1xuICAgICAgICAgICAgcG9zLnkrKztcbiAgICAgICAgICAgIHNlbGYuc2VuZCgnXFx4MWJbJyArIGJ1dHRvbiArICc7JyArIHBvcy54ICsgJzsnICsgcG9zLnkgKyAnTScpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxmLnNnck1vdXNlKSB7XG4gICAgICAgICAgICBwb3MueCAtPSAzMjtcbiAgICAgICAgICAgIHBvcy55IC09IDMyO1xuICAgICAgICAgICAgc2VsZi5zZW5kKCdcXHgxYls8J1xuICAgICAgICAgICAgICAgICsgKCgoYnV0dG9uICYgMykgPT09IDMgPyBidXR0b24gJiB+MyA6IGJ1dHRvbikgLSAzMilcbiAgICAgICAgICAgICAgICArICc7J1xuICAgICAgICAgICAgICAgICsgcG9zLnhcbiAgICAgICAgICAgICAgICArICc7J1xuICAgICAgICAgICAgICAgICsgcG9zLnlcbiAgICAgICAgICAgICAgICArICgoYnV0dG9uICYgMykgPT09IDMgPyAnbScgOiAnTScpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGF0YSA9IFtdO1xuICAgICAgICBlbmNvZGUoZGF0YSwgYnV0dG9uKTtcbiAgICAgICAgZW5jb2RlKGRhdGEsIHBvcy54KTtcbiAgICAgICAgZW5jb2RlKGRhdGEsIHBvcy55KTtcbiAgICAgICAgc2VsZi5zZW5kKCdcXHgxYltNJyArIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBkYXRhKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEJ1dHRvbihldikge1xuICAgICAgICB2YXIgYnV0dG9uLCBzaGlmdCwgbWV0YSwgY3RybCwgbW9kO1xuICAgICAgICAvLyB0d28gbG93IGJpdHM6XG4gICAgICAgIC8vIDAgPSBsZWZ0XG4gICAgICAgIC8vIDEgPSBtaWRkbGVcbiAgICAgICAgLy8gMiA9IHJpZ2h0XG4gICAgICAgIC8vIDMgPSByZWxlYXNlXG4gICAgICAgIC8vIHdoZWVsIHVwL2Rvd246XG4gICAgICAgIC8vIDEsIGFuZCAyIC0gd2l0aCA2NCBhZGRlZFxuICAgICAgICBzd2l0Y2ggKGV2Lm92ZXJyaWRlVHlwZSB8fCBldi50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdtb3VzZWRvd24nOlxuICAgICAgICAgICAgICAgIGJ1dHRvbiA9IGV2LmJ1dHRvbiAhPSBudWxsXG4gICAgICAgICAgICAgICAgICAgID8gK2V2LmJ1dHRvblxuICAgICAgICAgICAgICAgICAgICA6IGV2LndoaWNoICE9IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgID8gZXYud2hpY2ggLSAxXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuYnJvd3Nlci5pc01TSUUpIHtcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uID0gYnV0dG9uID09PSAxID8gMCA6IGJ1dHRvbiA9PT0gNCA/IDEgOiBidXR0b247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbW91c2V1cCc6XG4gICAgICAgICAgICAgICAgYnV0dG9uID0gMztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0RPTU1vdXNlU2Nyb2xsJzpcbiAgICAgICAgICAgICAgICBidXR0b24gPSBldi5kZXRhaWwgPCAwXG4gICAgICAgICAgICAgICAgICAgID8gNjRcbiAgICAgICAgICAgICAgICAgICAgOiA2NTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3doZWVsJzpcbiAgICAgICAgICAgICAgICBidXR0b24gPSBldi53aGVlbERlbHRhWSA+IDBcbiAgICAgICAgICAgICAgICAgICAgPyA2NFxuICAgICAgICAgICAgICAgICAgICA6IDY1O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5leHQgdGhyZWUgYml0cyBhcmUgdGhlIG1vZGlmaWVyczpcbiAgICAgICAgLy8gNCA9IHNoaWZ0LCA4ID0gbWV0YSwgMTYgPSBjb250cm9sXG4gICAgICAgIHNoaWZ0ID0gZXYuc2hpZnRLZXkgPyA0IDogMDtcbiAgICAgICAgbWV0YSA9IGV2Lm1ldGFLZXkgPyA4IDogMDtcbiAgICAgICAgY3RybCA9IGV2LmN0cmxLZXkgPyAxNiA6IDA7XG4gICAgICAgIG1vZCA9IHNoaWZ0IHwgbWV0YSB8IGN0cmw7XG4gICAgICAgIC8vIG5vIG1vZHNcbiAgICAgICAgaWYgKHNlbGYudnQyMDBNb3VzZSkge1xuICAgICAgICAgICAgLy8gY3RybCBvbmx5XG4gICAgICAgICAgICBtb2QgJj0gY3RybDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghc2VsZi5ub3JtYWxNb3VzZSkge1xuICAgICAgICAgICAgbW9kID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBpbmNyZW1lbnQgdG8gU1BcbiAgICAgICAgYnV0dG9uID0gKDMyICsgKG1vZCA8PCAyKSkgKyBidXR0b247XG4gICAgICAgIHJldHVybiBidXR0b247XG4gICAgfVxuICAgIC8vIG1vdXNlIGNvb3JkaW5hdGVzIG1lYXN1cmVkIGluIGNvbHMvcm93c1xuICAgIGZ1bmN0aW9uIGdldENvb3Jkcyhldikge1xuICAgICAgICB2YXIgeCwgeSwgdywgaCwgZWw7XG4gICAgICAgIC8vIGlnbm9yZSBicm93c2VycyB3aXRob3V0IHBhZ2VYIGZvciBub3dcbiAgICAgICAgaWYgKGV2LnBhZ2VYID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHggPSBldi5wYWdlWDtcbiAgICAgICAgeSA9IGV2LnBhZ2VZO1xuICAgICAgICBlbCA9IHNlbGYuZWxlbWVudDtcbiAgICAgICAgLy8gc2hvdWxkIHByb2JhYmx5IGNoZWNrIG9mZnNldFBhcmVudFxuICAgICAgICAvLyBidXQgdGhpcyBpcyBtb3JlIHBvcnRhYmxlXG4gICAgICAgIHdoaWxlIChlbCAmJiBlbCAhPT0gc2VsZi5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHggLT0gZWwub2Zmc2V0TGVmdDtcbiAgICAgICAgICAgIHkgLT0gZWwub2Zmc2V0VG9wO1xuICAgICAgICAgICAgZWwgPSAnb2Zmc2V0UGFyZW50JyBpbiBlbFxuICAgICAgICAgICAgICAgID8gZWwub2Zmc2V0UGFyZW50XG4gICAgICAgICAgICAgICAgOiBlbC5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbnZlcnQgdG8gY29scy9yb3dzXG4gICAgICAgIHcgPSBzZWxmLmVsZW1lbnQuY2xpZW50V2lkdGg7XG4gICAgICAgIGggPSBzZWxmLmVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICAgICAgICB4ID0gTWF0aC5jZWlsKCh4IC8gdykgKiBzZWxmLmNvbHMpO1xuICAgICAgICB5ID0gTWF0aC5jZWlsKCh5IC8gaCkgKiBzZWxmLnJvd3MpO1xuICAgICAgICAvLyBiZSBzdXJlIHRvIGF2b2lkIHNlbmRpbmdcbiAgICAgICAgLy8gYmFkIHBvc2l0aW9ucyB0byB0aGUgcHJvZ3JhbVxuICAgICAgICBpZiAoeCA8IDApXG4gICAgICAgICAgICB4ID0gMDtcbiAgICAgICAgaWYgKHggPiBzZWxmLmNvbHMpXG4gICAgICAgICAgICB4ID0gc2VsZi5jb2xzO1xuICAgICAgICBpZiAoeSA8IDApXG4gICAgICAgICAgICB5ID0gMDtcbiAgICAgICAgaWYgKHkgPiBzZWxmLnJvd3MpXG4gICAgICAgICAgICB5ID0gc2VsZi5yb3dzO1xuICAgICAgICAvLyB4dGVybSBzZW5kcyByYXcgYnl0ZXMgYW5kXG4gICAgICAgIC8vIHN0YXJ0cyBhdCAzMiAoU1ApIGZvciBlYWNoLlxuICAgICAgICB4ICs9IDMyO1xuICAgICAgICB5ICs9IDMyO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICB0eXBlOiAnd2hlZWwnXG4gICAgICAgIH07XG4gICAgfVxuICAgIG9uKGVsLCAnbW91c2Vkb3duJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgIGlmICghc2VsZi5tb3VzZUV2ZW50cylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gc2VuZCB0aGUgYnV0dG9uXG4gICAgICAgIHNlbmRCdXR0b24oZXYpO1xuICAgICAgICAvLyBlbnN1cmUgZm9jdXNcbiAgICAgICAgc2VsZi5mb2N1cygpO1xuICAgICAgICAvLyBmaXggZm9yIG9kZCBidWdcbiAgICAgICAgLy9pZiAoc2VsZi52dDIwME1vdXNlICYmICFzZWxmLm5vcm1hbE1vdXNlKSB7XG4gICAgICAgIGlmIChzZWxmLnZ0MjAwTW91c2UpIHtcbiAgICAgICAgICAgIGV2Lm92ZXJyaWRlVHlwZSA9ICdtb3VzZXVwJztcbiAgICAgICAgICAgIHNlbmRCdXR0b24oZXYpO1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuY2FuY2VsKGV2KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBiaW5kIGV2ZW50c1xuICAgICAgICBpZiAoc2VsZi5ub3JtYWxNb3VzZSlcbiAgICAgICAgICAgIG9uKHNlbGYuZG9jdW1lbnQsICdtb3VzZW1vdmUnLCBzZW5kTW92ZSk7XG4gICAgICAgIC8vIHgxMCBjb21wYXRpYmlsaXR5IG1vZGUgY2FuJ3Qgc2VuZCBidXR0b24gcmVsZWFzZXNcbiAgICAgICAgaWYgKCFzZWxmLngxME1vdXNlKSB7XG4gICAgICAgICAgICBvbihzZWxmLmRvY3VtZW50LCAnbW91c2V1cCcsIGZ1bmN0aW9uIHVwKGV2KSB7XG4gICAgICAgICAgICAgICAgc2VuZEJ1dHRvbihldik7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYubm9ybWFsTW91c2UpXG4gICAgICAgICAgICAgICAgICAgIG9mZihzZWxmLmRvY3VtZW50LCAnbW91c2Vtb3ZlJywgc2VuZE1vdmUpO1xuICAgICAgICAgICAgICAgIG9mZihzZWxmLmRvY3VtZW50LCAnbW91c2V1cCcsIHVwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5jYW5jZWwoZXYpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGYuY2FuY2VsKGV2KTtcbiAgICB9KTtcbiAgICAvL2lmIChzZWxmLm5vcm1hbE1vdXNlKSB7XG4gICAgLy8gIG9uKHNlbGYuZG9jdW1lbnQsICdtb3VzZW1vdmUnLCBzZW5kTW92ZSk7XG4gICAgLy99XG4gICAgb24oZWwsICd3aGVlbCcsIGZ1bmN0aW9uIChldikge1xuICAgICAgICBpZiAoIXNlbGYubW91c2VFdmVudHMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChzZWxmLngxME1vdXNlXG4gICAgICAgICAgICB8fCBzZWxmLnZ0MzAwTW91c2VcbiAgICAgICAgICAgIHx8IHNlbGYuZGVjTG9jYXRvcilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgc2VuZEJ1dHRvbihldik7XG4gICAgICAgIHJldHVybiBzZWxmLmNhbmNlbChldik7XG4gICAgfSk7XG4gICAgLy8gYWxsb3cgd2hlZWwgc2Nyb2xsaW5nIGluXG4gICAgLy8gdGhlIHNoZWxsIGZvciBleGFtcGxlXG4gICAgb24oZWwsICd3aGVlbCcsIGZ1bmN0aW9uIChldikge1xuICAgICAgICBpZiAoc2VsZi5tb3VzZUV2ZW50cylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgc2VsZi52aWV3cG9ydC5vbldoZWVsKGV2KTtcbiAgICAgICAgcmV0dXJuIHNlbGYuY2FuY2VsKGV2KTtcbiAgICB9KTtcbn07XG4vKipcbiAqIERlc3Ryb3lzIHRoZSB0ZXJtaW5hbC5cbiAqL1xuVGVybWluYWwucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICB0aGlzLmhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgdGhpcy53cml0ZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICBpZiAodGhpcy5lbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5lbGVtZW50KTtcbiAgICB9XG4gICAgLy90aGlzLmVtaXQoJ2Nsb3NlJyk7XG59O1xuLyoqXG4gKiBGbGFncyB1c2VkIHRvIHJlbmRlciB0ZXJtaW5hbCB0ZXh0IHByb3Blcmx5XG4gKi9cblRlcm1pbmFsLmZsYWdzID0ge1xuICAgIEJPTEQ6IDEsXG4gICAgVU5ERVJMSU5FOiAyLFxuICAgIEJMSU5LOiA0LFxuICAgIElOVkVSU0U6IDgsXG4gICAgSU5WSVNJQkxFOiAxNlxufTtcbi8qKlxuICogUmVmcmVzaGVzIChyZS1yZW5kZXJzKSB0ZXJtaW5hbCBjb250ZW50IHdpdGhpbiB0d28gcm93cyAoaW5jbHVzaXZlKVxuICpcbiAqIFJlbmRlcmluZyBFbmdpbmU6XG4gKlxuICogSW4gdGhlIHNjcmVlbiBidWZmZXIsIGVhY2ggY2hhcmFjdGVyIGlzIHN0b3JlZCBhcyBhIGFuIGFycmF5IHdpdGggYSBjaGFyYWN0ZXJcbiAqIGFuZCBhIDMyLWJpdCBpbnRlZ2VyOlxuICogICAtIEZpcnN0IHZhbHVlOiBhIHV0Zi0xNiBjaGFyYWN0ZXIuXG4gKiAgIC0gU2Vjb25kIHZhbHVlOlxuICogICAtIE5leHQgOSBiaXRzOiBiYWNrZ3JvdW5kIGNvbG9yICgwLTUxMSkuXG4gKiAgIC0gTmV4dCA5IGJpdHM6IGZvcmVncm91bmQgY29sb3IgKDAtNTExKS5cbiAqICAgLSBOZXh0IDE0IGJpdHM6IGEgbWFzayBmb3IgbWlzYy4gZmxhZ3M6XG4gKiAgICAgLSAxPWJvbGRcbiAqICAgICAtIDI9dW5kZXJsaW5lXG4gKiAgICAgLSA0PWJsaW5rXG4gKiAgICAgLSA4PWludmVyc2VcbiAqICAgICAtIDE2PWludmlzaWJsZVxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgcm93IHRvIHN0YXJ0IGZyb20gKGJldHdlZW4gMCBhbmQgdGVybWluYWwncyBoZWlnaHQgdGVybWluYWwgLSAxKVxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgcm93IHRvIGVuZCBhdCAoYmV0d2VlbiBmcm9tUm93IGFuZCB0ZXJtaW5hbCdzIGhlaWdodCB0ZXJtaW5hbCAtIDEpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHF1ZXVlIFdoZXRoZXIgdGhlIHJlZnJlc2ggc2hvdWxkIHJhbiByaWdodCBub3cgb3IgYmUgcXVldWVkXG4gKi9cblRlcm1pbmFsLnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIHF1ZXVlKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIC8vIHF1ZXVlIGRlZmF1bHRzIHRvIHRydWVcbiAgICBxdWV1ZSA9ICh0eXBlb2YgcXVldWUgPT0gJ3VuZGVmaW5lZCcpID8gdHJ1ZSA6IHF1ZXVlO1xuICAgIC8qKlxuICAgICAqIFRoZSByZWZyZXNoIHF1ZXVlIGFsbG93cyByZWZyZXNoIHRvIGV4ZWN1dGUgb25seSBhcHByb3hpbWF0ZWx5IDMwIHRpbWVzIGEgc2Vjb25kLiBGb3JcbiAgICAgKiBjb21tYW5kcyB0aGF0IHBhc3MgYSBzaWduaWZpY2FudCBhbW91bnQgb2Ygb3V0cHV0IHRvIHRoZSB3cml0ZSBmdW5jdGlvbiwgdGhpcyBwcmV2ZW50cyB0aGVcbiAgICAgKiB0ZXJtaW5hbCBmcm9tIG1heGluZyBvdXQgdGhlIENQVSBhbmQgbWFraW5nIHRoZSBVSSB1bnJlc3BvbnNpdmUuIFdoaWxlIGNvbW1hbmRzIGNhbiBzdGlsbFxuICAgICAqIHJ1biBiZXlvbmQgd2hhdCB0aGV5IGRvIG9uIHRoZSB0ZXJtaW5hbCwgaXQgaXMgZmFyIGJldHRlciB3aXRoIGEgZGVib3VuY2UgaW4gcGxhY2UgYXNcbiAgICAgKiBldmVyeSBzaW5nbGUgdGVybWluYWwgbWFuaXB1bGF0aW9uIGRvZXMgbm90IG5lZWQgdG8gYmUgY29uc3RydWN0ZWQgaW4gdGhlIERPTS5cbiAgICAgKlxuICAgICAqIEEgc2lkZS1lZmZlY3Qgb2YgdGhpcyBpcyB0aGF0IGl0IG1ha2VzIF5DIHRvIGludGVycnVwdCBhIHByb2Nlc3Mgc2VlbSBtb3JlIHJlc3BvbnNpdmUuXG4gICAgICovXG4gICAgaWYgKHF1ZXVlKSB7XG4gICAgICAgIC8vIElmIHJlZnJlc2ggc2hvdWxkIGJlIHF1ZXVlZCwgb3JkZXIgdGhlIHJlZnJlc2ggYW5kIHJldHVybi5cbiAgICAgICAgaWYgKHRoaXMuX3JlZnJlc2hJc1F1ZXVlZCkge1xuICAgICAgICAgICAgLy8gSWYgYSByZWZyZXNoIGhhcyBhbHJlYWR5IGJlZW4gcXVldWVkLCBqdXN0IG9yZGVyIGEgZnVsbCByZWZyZXNoIG5leHRcbiAgICAgICAgICAgIHRoaXMuX2Z1bGxSZWZyZXNoTmV4dCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnJlZnJlc2goc3RhcnQsIGVuZCwgZmFsc2UpO1xuICAgICAgICAgICAgfSwgMzQpO1xuICAgICAgICAgICAgdGhpcy5fcmVmcmVzaElzUXVldWVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIElmIHJlZnJlc2ggc2hvdWxkIGJlIHJ1biByaWdodCBub3cgKG5vdCBiZSBxdWV1ZWQpLCByZWxlYXNlIHRoZSBsb2NrXG4gICAgdGhpcy5fcmVmcmVzaElzUXVldWVkID0gZmFsc2U7XG4gICAgLy8gSWYgbXVsdGlwbGUgcmVmcmVzaGVzIHdlcmUgcmVxdWVzdGVkLCBtYWtlIGEgZnVsbCByZWZyZXNoLlxuICAgIGlmICh0aGlzLl9mdWxsUmVmcmVzaE5leHQpIHtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICBlbmQgPSB0aGlzLnJvd3MgLSAxO1xuICAgICAgICB0aGlzLl9mdWxsUmVmcmVzaE5leHQgPSBmYWxzZTsgLy8gcmVzZXQgbG9ja1xuICAgIH1cbiAgICB2YXIgeCwgeSwgaSwgbGluZSwgb3V0LCBjaCwgY2hfd2lkdGgsIHdpZHRoLCBkYXRhLCBhdHRyLCBiZywgZmcsIGZsYWdzLCByb3csIHBhcmVudCwgZm9jdXNlZCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgLy8gSWYgdGhpcyBpcyBhIGJpZyByZWZyZXNoLCByZW1vdmUgdGhlIHRlcm1pbmFsIHJvd3MgZnJvbSB0aGUgRE9NIGZvciBmYXN0ZXIgY2FsY3VsYXRpb25zXG4gICAgaWYgKGVuZCAtIHN0YXJ0ID49IHRoaXMucm93cyAvIDIpIHtcbiAgICAgICAgcGFyZW50ID0gdGhpcy5lbGVtZW50LnBhcmVudE5vZGU7XG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVDaGlsZCh0aGlzLnJvd0NvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2lkdGggPSB0aGlzLmNvbHM7XG4gICAgeSA9IHN0YXJ0O1xuICAgIGlmIChlbmQgPj0gdGhpcy5yb3dzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLmxvZygnYGVuZGAgaXMgdG9vIGxhcmdlLiBNb3N0IGxpa2VseSBhIGJhZCBDU1IuJyk7XG4gICAgICAgIGVuZCA9IHRoaXMucm93cy5sZW5ndGggLSAxO1xuICAgIH1cbiAgICBmb3IgKDsgeSA8PSBlbmQ7IHkrKykge1xuICAgICAgICByb3cgPSB5ICsgdGhpcy55ZGlzcDtcbiAgICAgICAgbGluZSA9IHRoaXMubGluZXNbcm93XTtcbiAgICAgICAgb3V0ID0gJyc7XG4gICAgICAgIGlmICh0aGlzLnkgPT09IHkgLSAodGhpcy55YmFzZSAtIHRoaXMueWRpc3ApXG4gICAgICAgICAgICAmJiB0aGlzLmN1cnNvclN0YXRlXG4gICAgICAgICAgICAmJiAhdGhpcy5jdXJzb3JIaWRkZW4pIHtcbiAgICAgICAgICAgIHggPSB0aGlzLng7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB4ID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgYXR0ciA9IHRoaXMuZGVmQXR0cjtcbiAgICAgICAgaSA9IDA7XG4gICAgICAgIGZvciAoOyBpIDwgd2lkdGg7IGkrKykge1xuICAgICAgICAgICAgZGF0YSA9IGxpbmVbaV1bMF07XG4gICAgICAgICAgICBjaCA9IGxpbmVbaV1bMV07XG4gICAgICAgICAgICBjaF93aWR0aCA9IGxpbmVbaV1bMl07XG4gICAgICAgICAgICBpZiAoIWNoX3dpZHRoKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKGkgPT09IHgpXG4gICAgICAgICAgICAgICAgZGF0YSA9IC0xO1xuICAgICAgICAgICAgaWYgKGRhdGEgIT09IGF0dHIpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXR0ciAhPT0gdGhpcy5kZWZBdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSAnPC9zcGFuPic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkYXRhICE9PSB0aGlzLmRlZkF0dHIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQgKz0gJzxzcGFuIGNsYXNzPVwicmV2ZXJzZS12aWRlbyB0ZXJtaW5hbC1jdXJzb3InO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY3Vyc29yQmxpbmspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXQgKz0gJyBibGlua2luZyc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQgKz0gJ1wiPic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2xhc3NOYW1lcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmcgPSBkYXRhICYgMHgxZmY7XG4gICAgICAgICAgICAgICAgICAgICAgICBmZyA9IChkYXRhID4+IDkpICYgMHgxZmY7XG4gICAgICAgICAgICAgICAgICAgICAgICBmbGFncyA9IGRhdGEgPj4gMTg7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MgJiBUZXJtaW5hbC5mbGFncy5CT0xEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFUZXJtaW5hbC5icm9rZW5Cb2xkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgneHRlcm0tYm9sZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTZWU6IFhUZXJtKmJvbGRDb2xvcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmcgPCA4KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZyArPSA4O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzICYgVGVybWluYWwuZmxhZ3MuVU5ERVJMSU5FKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCd4dGVybS11bmRlcmxpbmUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmbGFncyAmIFRlcm1pbmFsLmZsYWdzLkJMSU5LKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCd4dGVybS1ibGluaycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgaW52ZXJzZSBmbGFnIGlzIG9uLCB0aGVuIHN3YXAgdGhlIGZvcmVncm91bmQgYW5kIGJhY2tncm91bmQgdmFyaWFibGVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzICYgVGVybWluYWwuZmxhZ3MuSU5WRVJTRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIE9uZS1saW5lIHZhcmlhYmxlIHN3YXAgaW4gSmF2YVNjcmlwdDogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTYyMDE3MzAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZyA9IFtmZywgZmcgPSBiZ11bMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2hvdWxkIGludmVyc2UganVzdCBiZSBiZWZvcmUgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWJvdmUgYm9sZENvbG9ycyBlZmZlY3QgaW5zdGVhZD9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGZsYWdzICYgMSkgJiYgZmcgPCA4KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZyArPSA4O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzICYgVGVybWluYWwuZmxhZ3MuSU5WSVNJQkxFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCd4dGVybS1oaWRkZW4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogV2VpcmQgc2l0dWF0aW9uOiBJbnZlcnQgZmxhZyB1c2VkIGJsYWNrIGZvcmVncm91bmQgYW5kIHdoaXRlIGJhY2tncm91bmQgcmVzdWx0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICogaW4gaW52YWxpZCBiYWNrZ3JvdW5kIGNvbG9yLCBwb3NpdGlvbmVkIGF0IHRoZSAyNTYgaW5kZXggb2YgdGhlIDI1NiB0ZXJtaW5hbFxuICAgICAgICAgICAgICAgICAgICAgICAgICogY29sb3IgbWFwLiBQaW4gdGhlIGNvbG9ycyBtYW51YWxseSBpbiBzdWNoIGEgY2FzZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBTb3VyY2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9zb3VyY2VsYWlyL3h0ZXJtLmpzL2lzc3Vlcy81N1xuICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MgJiBUZXJtaW5hbC5mbGFncy5JTlZFUlNFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJnID09IDI1Nykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZyA9IDE1O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmcgPT0gMjU2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZnID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmcgPCAyNTYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ3h0ZXJtLWJnLWNvbG9yLScgKyBiZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmcgPCAyNTYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ3h0ZXJtLWNvbG9yLScgKyBmZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQgKz0gJzxzcGFuJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjbGFzc05hbWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dCArPSAnIGNsYXNzPVwiJyArIGNsYXNzTmFtZXMuam9pbignICcpICsgJ1wiJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG91dCArPSAnPic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKGNoKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnJic6XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSAnJmFtcDsnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9ICcmbHQ7JztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnPic6XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSAnJmd0Oyc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaCA8PSAnICcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dCArPSAnJm5ic3A7JztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dCArPSBjaDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF0dHIgPSBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhdHRyICE9PSB0aGlzLmRlZkF0dHIpIHtcbiAgICAgICAgICAgIG91dCArPSAnPC9zcGFuPic7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGlsZHJlblt5XS5pbm5lckhUTUwgPSBvdXQ7XG4gICAgfVxuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKHRoaXMucm93Q29udGFpbmVyKTtcbiAgICB9XG4gICAgdGhpcy5lbWl0KCdyZWZyZXNoJywgeyBlbGVtZW50OiB0aGlzLmVsZW1lbnQsIHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQgfSk7XG59O1xuLyoqXG4gKiBEaXNwbGF5IHRoZSBjdXJzb3IgZWxlbWVudFxuICovXG5UZXJtaW5hbC5wcm90b3R5cGUuc2hvd0N1cnNvciA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuY3Vyc29yU3RhdGUpIHtcbiAgICAgICAgdGhpcy5jdXJzb3JTdGF0ZSA9IDE7XG4gICAgICAgIHRoaXMucmVmcmVzaCh0aGlzLnksIHRoaXMueSk7XG4gICAgfVxufTtcbi8qKlxuICogU2Nyb2xsIHRoZSB0ZXJtaW5hbFxuICovXG5UZXJtaW5hbC5wcm90b3R5cGUuc2Nyb2xsID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByb3c7XG4gICAgaWYgKCsrdGhpcy55YmFzZSA9PT0gdGhpcy5zY3JvbGxiYWNrKSB7XG4gICAgICAgIHRoaXMueWJhc2UgPSB0aGlzLnliYXNlIC8gMiB8IDA7XG4gICAgICAgIHRoaXMubGluZXMgPSB0aGlzLmxpbmVzLnNsaWNlKC0odGhpcy55YmFzZSArIHRoaXMucm93cykgKyAxKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnVzZXJTY3JvbGxpbmcpIHtcbiAgICAgICAgdGhpcy55ZGlzcCA9IHRoaXMueWJhc2U7XG4gICAgfVxuICAgIC8vIGxhc3QgbGluZVxuICAgIHJvdyA9IHRoaXMueWJhc2UgKyB0aGlzLnJvd3MgLSAxO1xuICAgIC8vIHN1YnRyYWN0IHRoZSBib3R0b20gc2Nyb2xsIHJlZ2lvblxuICAgIHJvdyAtPSB0aGlzLnJvd3MgLSAxIC0gdGhpcy5zY3JvbGxCb3R0b207XG4gICAgaWYgKHJvdyA9PT0gdGhpcy5saW5lcy5sZW5ndGgpIHtcbiAgICAgICAgLy8gcG90ZW50aWFsIG9wdGltaXphdGlvbjpcbiAgICAgICAgLy8gcHVzaGluZyBpcyBmYXN0ZXIgdGhhbiBzcGxpY2luZ1xuICAgICAgICAvLyB3aGVuIHRoZXkgYW1vdW50IHRvIHRoZSBzYW1lXG4gICAgICAgIC8vIGJlaGF2aW9yLlxuICAgICAgICB0aGlzLmxpbmVzLnB1c2godGhpcy5ibGFua0xpbmUoKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBhZGQgb3VyIG5ldyBsaW5lXG4gICAgICAgIHRoaXMubGluZXMuc3BsaWNlKHJvdywgMCwgdGhpcy5ibGFua0xpbmUoKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLnNjcm9sbFRvcCAhPT0gMCkge1xuICAgICAgICBpZiAodGhpcy55YmFzZSAhPT0gMCkge1xuICAgICAgICAgICAgdGhpcy55YmFzZS0tO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnVzZXJTY3JvbGxpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnlkaXNwID0gdGhpcy55YmFzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxpbmVzLnNwbGljZSh0aGlzLnliYXNlICsgdGhpcy5zY3JvbGxUb3AsIDEpO1xuICAgIH1cbiAgICAvLyB0aGlzLm1heFJhbmdlKCk7XG4gICAgdGhpcy51cGRhdGVSYW5nZSh0aGlzLnNjcm9sbFRvcCk7XG4gICAgdGhpcy51cGRhdGVSYW5nZSh0aGlzLnNjcm9sbEJvdHRvbSk7XG4gICAgLyoqXG4gICAgICogVGhpcyBldmVudCBpcyBlbWl0dGVkIHdoZW5ldmVyIHRoZSB0ZXJtaW5hbCBpcyBzY3JvbGxlZC5cbiAgICAgKiBUaGUgb25lIHBhcmFtZXRlciBwYXNzZWQgaXMgdGhlIG5ldyB5IGRpc3BsYXkgcG9zaXRpb24uXG4gICAgICpcbiAgICAgKiBAZXZlbnQgc2Nyb2xsXG4gICAgICovXG4gICAgdGhpcy5lbWl0KCdzY3JvbGwnLCB0aGlzLnlkaXNwKTtcbn07XG4vKipcbiAqIFNjcm9sbCB0aGUgZGlzcGxheSBvZiB0aGUgdGVybWluYWxcbiAqIEBwYXJhbSB7bnVtYmVyfSBkaXNwIFRoZSBudW1iZXIgb2YgbGluZXMgdG8gc2Nyb2xsIGRvd24gKG5lZ2F0aXZlcyBzY3JvbGwgdXApLlxuICogQHBhcmFtIHtib29sZWFufSBzdXBwcmVzc1Njcm9sbEV2ZW50IERvbid0IGVtaXQgdGhlIHNjcm9sbCBldmVudCBhcyBzY3JvbGxEaXNwLiBUaGlzIGlzIHVzZWRcbiAqIHRvIGF2b2lkIHVud2FudGVkIGV2ZW50cyBiZWluZyBoYW5kbGVkIGJ5IHRoZSB2ZWl3cG9ydCB3aGVuIHRoZSBldmVudCB3YXMgdHJpZ2dlcmVkIGZyb20gdGhlXG4gKiB2aWV3cG9ydCBvcmlnaW5hbGx5LlxuICovXG5UZXJtaW5hbC5wcm90b3R5cGUuc2Nyb2xsRGlzcCA9IGZ1bmN0aW9uIChkaXNwLCBzdXBwcmVzc1Njcm9sbEV2ZW50KSB7XG4gICAgaWYgKGRpc3AgPCAwKSB7XG4gICAgICAgIHRoaXMudXNlclNjcm9sbGluZyA9IHRydWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRpc3AgKyB0aGlzLnlkaXNwID49IHRoaXMueWJhc2UpIHtcbiAgICAgICAgdGhpcy51c2VyU2Nyb2xsaW5nID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMueWRpc3AgKz0gZGlzcDtcbiAgICBpZiAodGhpcy55ZGlzcCA+IHRoaXMueWJhc2UpIHtcbiAgICAgICAgdGhpcy55ZGlzcCA9IHRoaXMueWJhc2U7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMueWRpc3AgPCAwKSB7XG4gICAgICAgIHRoaXMueWRpc3AgPSAwO1xuICAgIH1cbiAgICBpZiAoIXN1cHByZXNzU2Nyb2xsRXZlbnQpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdzY3JvbGwnLCB0aGlzLnlkaXNwKTtcbiAgICB9XG4gICAgdGhpcy5yZWZyZXNoKDAsIHRoaXMucm93cyAtIDEpO1xufTtcbi8qKlxuICogU2Nyb2xsIHRoZSBkaXNwbGF5IG9mIHRoZSB0ZXJtaW5hbCBieSBhIG51bWJlciBvZiBwYWdlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBwYWdlQ291bnQgVGhlIG51bWJlciBvZiBwYWdlcyB0byBzY3JvbGwgKG5lZ2F0aXZlIHNjcm9sbHMgdXApLlxuICovXG5UZXJtaW5hbC5wcm90b3R5cGUuc2Nyb2xsUGFnZXMgPSBmdW5jdGlvbiAocGFnZUNvdW50KSB7XG4gICAgdGhpcy5zY3JvbGxEaXNwKHBhZ2VDb3VudCAqICh0aGlzLnJvd3MgLSAxKSk7XG59O1xuLyoqXG4gKiBTY3JvbGxzIHRoZSBkaXNwbGF5IG9mIHRoZSB0ZXJtaW5hbCB0byB0aGUgdG9wLlxuICovXG5UZXJtaW5hbC5wcm90b3R5cGUuc2Nyb2xsVG9Ub3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zY3JvbGxEaXNwKC10aGlzLnlkaXNwKTtcbn07XG4vKipcbiAqIFNjcm9sbHMgdGhlIGRpc3BsYXkgb2YgdGhlIHRlcm1pbmFsIHRvIHRoZSBib3R0b20uXG4gKi9cblRlcm1pbmFsLnByb3RvdHlwZS5zY3JvbGxUb0JvdHRvbSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnNjcm9sbERpc3AodGhpcy55YmFzZSAtIHRoaXMueWRpc3ApO1xufTtcbi8qKlxuICogV3JpdGVzIHRleHQgdG8gdGhlIHRlcm1pbmFsLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQgVGhlIHRleHQgdG8gd3JpdGUgdG8gdGhlIHRlcm1pbmFsLlxuICovXG5UZXJtaW5hbC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBsID0gZGF0YS5sZW5ndGgsIGkgPSAwLCBqLCBjcywgY2gsIGNvZGUsIGxvdywgY2hfd2lkdGgsIHJvdztcbiAgICB0aGlzLnJlZnJlc2hTdGFydCA9IHRoaXMueTtcbiAgICB0aGlzLnJlZnJlc2hFbmQgPSB0aGlzLnk7XG4gICAgLy8gYXBwbHkgbGVmdG92ZXIgc3Vycm9nYXRlIGhpZ2ggZnJvbSBsYXN0IHdyaXRlXG4gICAgaWYgKHRoaXMuc3Vycm9nYXRlX2hpZ2gpIHtcbiAgICAgICAgZGF0YSA9IHRoaXMuc3Vycm9nYXRlX2hpZ2ggKyBkYXRhO1xuICAgICAgICB0aGlzLnN1cnJvZ2F0ZV9oaWdoID0gJyc7XG4gICAgfVxuICAgIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGNoID0gZGF0YVtpXTtcbiAgICAgICAgLy8gRklYTUU6IGhpZ2hlciBjaGFycyB0aGFuIDB4YTAgYXJlIG5vdCBhbGxvd2VkIGluIGVzY2FwZSBzZXF1ZW5jZXNcbiAgICAgICAgLy8gICAgICAgIC0tPiBtYXliZSBtb3ZlIHRvIGRlZmF1bHRcbiAgICAgICAgY29kZSA9IGRhdGEuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKDB4RDgwMCA8PSBjb2RlICYmIGNvZGUgPD0gMHhEQkZGKSB7XG4gICAgICAgICAgICAvLyB3ZSBnb3QgYSBzdXJyb2dhdGUgaGlnaFxuICAgICAgICAgICAgLy8gZ2V0IHN1cnJvZ2F0ZSBsb3cgKG5leHQgMiBieXRlcylcbiAgICAgICAgICAgIGxvdyA9IGRhdGEuY2hhckNvZGVBdChpICsgMSk7XG4gICAgICAgICAgICBpZiAoaXNOYU4obG93KSkge1xuICAgICAgICAgICAgICAgIC8vIGVuZCBvZiBkYXRhIHN0cmVhbSwgc2F2ZSBzdXJyb2dhdGUgaGlnaFxuICAgICAgICAgICAgICAgIHRoaXMuc3Vycm9nYXRlX2hpZ2ggPSBjaDtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvZGUgPSAoKGNvZGUgLSAweEQ4MDApICogMHg0MDApICsgKGxvdyAtIDB4REMwMCkgKyAweDEwMDAwO1xuICAgICAgICAgICAgY2ggKz0gZGF0YS5jaGFyQXQoaSArIDEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHN1cnJvZ2F0ZSBsb3cgLSBhbHJlYWR5IGhhbmRsZWQgYWJvdmVcbiAgICAgICAgaWYgKDB4REMwMCA8PSBjb2RlICYmIGNvZGUgPD0gMHhERkZGKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSBub3JtYWw6XG4gICAgICAgICAgICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdcXHgwNyc6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJlbGwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAvLyAnXFxuJywgJ1xcdicsICdcXGYnXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1xcbic6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1xceDBiJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnXFx4MGMnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29udmVydEVvbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMueCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnkrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnkgPiB0aGlzLnNjcm9sbEJvdHRvbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMueS0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgLy8gJ1xccidcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnXFxyJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMueCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgLy8gJ1xcYidcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnXFx4MDgnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMueCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLngtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAvLyAnXFx0J1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdcXHQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy54ID0gdGhpcy5uZXh0U3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNoaWZ0IG91dFxuICAgICAgICAgICAgICAgICAgICBjYXNlICdcXHgwZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldGdMZXZlbCgxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAvLyBzaGlmdCBpblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdcXHgwZic6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldGdMZXZlbCgwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAvLyAnXFxlJ1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdcXHgxYic6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gZXNjYXBlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJyAnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgcHJpbnQgc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV4cGVuc2l2ZSBjYWxsLCB0aGVyZWZvcmUgd2Ugc2F2ZSB3aWR0aCBpbiBsaW5lIGJ1ZmZlclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hfd2lkdGggPSB3Y3dpZHRoKGNvZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoID49ICcgJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoYXJzZXQgJiYgdGhpcy5jaGFyc2V0W2NoXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaCA9IHRoaXMuY2hhcnNldFtjaF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdyA9IHRoaXMueSArIHRoaXMueWJhc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5zZXJ0IGNvbWJpbmluZyBjaGFyIGluIGxhc3QgY2VsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FOiBuZWVkcyBoYW5kbGluZyBhZnRlciBjdXJzb3IganVtcHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNoX3dpZHRoICYmIHRoaXMueCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkb250IG92ZXJmbG93IGxlZnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubGluZXNbcm93XVt0aGlzLnggLSAxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmxpbmVzW3Jvd11bdGhpcy54IC0gMV1bMl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3VuZCBlbXB0eSBjZWxsIGFmdGVyIGZ1bGx3aWR0aCwgbmVlZCB0byBnbyAyIGNlbGxzIGJhY2tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5saW5lc1tyb3ddW3RoaXMueCAtIDJdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmVzW3Jvd11bdGhpcy54IC0gMl1bMV0gKz0gY2g7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmVzW3Jvd11bdGhpcy54IC0gMV1bMV0gKz0gY2g7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVJhbmdlKHRoaXMueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGdvdG8gbmV4dCBsaW5lIGlmIGNoIHdvdWxkIG92ZXJmbG93XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogbmVlZHMgYSBnbG9iYWwgbWluIHRlcm1pbmFsIHdpZHRoIG9mIDJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy54ICsgY2hfd2lkdGggLSAxID49IHRoaXMuY29scykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhdXRvd3JhcCAtIERFQ0FXTVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy53cmFwYXJvdW5kTW9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy54ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMueSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMueSA+IHRoaXMuc2Nyb2xsQm90dG9tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy55LS07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zY3JvbGwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMueCA9IHRoaXMuY29scyAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hfd2lkdGggPT09IDIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93ID0gdGhpcy55ICsgdGhpcy55YmFzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbnNlcnQgbW9kZTogbW92ZSBjaGFyYWN0ZXJzIHRvIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5zZXJ0TW9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkbyB0aGlzIHR3aWNlIGZvciBhIGZ1bGx3aWR0aCBjaGFyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG1vdmVzID0gMDsgbW92ZXMgPCBjaF93aWR0aDsgKyttb3Zlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGxhc3QgY2VsbCwgaWYgaXQncyB3aWR0aCBpcyAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBoYXZlIHRvIGFkanVzdCB0aGUgc2Vjb25kIGxhc3QgY2VsbCBhcyB3ZWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVtb3ZlZCA9IHRoaXMubGluZXNbdGhpcy55ICsgdGhpcy55YmFzZV0ucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVtb3ZlZFsyXSA9PT0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIHRoaXMubGluZXNbcm93XVt0aGlzLmNvbHMgLSAyXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIHRoaXMubGluZXNbcm93XVt0aGlzLmNvbHMgLSAyXVsyXSA9PT0gMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmVzW3Jvd11bdGhpcy5jb2xzIC0gMl0gPSBbdGhpcy5jdXJBdHRyLCAnICcsIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5zZXJ0IGVtcHR5IGNlbGwgYXQgY3Vyc29yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmVzW3Jvd10uc3BsaWNlKHRoaXMueCwgMCwgW3RoaXMuY3VyQXR0ciwgJyAnLCAxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5lc1tyb3ddW3RoaXMueF0gPSBbdGhpcy5jdXJBdHRyLCBjaCwgY2hfd2lkdGhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMueCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlUmFuZ2UodGhpcy55KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmdWxsd2lkdGggY2hhciAtIHNldCBuZXh0IGNlbGwgd2lkdGggdG8gemVybyBhbmQgYWR2YW5jZSBjdXJzb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hfd2lkdGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5lc1tyb3ddW3RoaXMueF0gPSBbdGhpcy5jdXJBdHRyLCAnJywgMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMueCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgZXNjYXBlZDpcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVTQyBbIENvbnRyb2wgU2VxdWVuY2UgSW50cm9kdWNlciAoIENTSSBpcyAweDliKS5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnWyc6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmFtcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50UGFyYW0gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IGNzaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAvLyBFU0MgXSBPcGVyYXRpbmcgU3lzdGVtIENvbW1hbmQgKCBPU0MgaXMgMHg5ZCkuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ10nOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJhbXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFBhcmFtID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBvc2M7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgLy8gRVNDIFAgRGV2aWNlIENvbnRyb2wgU3RyaW5nICggRENTIGlzIDB4OTApLlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdQJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyYW1zID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRQYXJhbSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gZGNzO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVTQyBfIEFwcGxpY2F0aW9uIFByb2dyYW0gQ29tbWFuZCAoIEFQQyBpcyAweDlmKS5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnXyc6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gaWdub3JlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVTQyBeIFByaXZhY3kgTWVzc2FnZSAoIFBNIGlzIDB4OWUpLlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdeJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBpZ25vcmU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgLy8gRVNDIGMgRnVsbCBSZXNldCAoUklTKS5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYyc6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgLy8gRVNDIEUgTmV4dCBMaW5lICggTkVMIGlzIDB4ODUpLlxuICAgICAgICAgICAgICAgICAgICAvLyBFU0MgRCBJbmRleCAoIElORCBpcyAweDg0KS5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnRSc6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnggPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdEJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAvLyBFU0MgTSBSZXZlcnNlIEluZGV4ICggUkkgaXMgMHg4ZCkuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ00nOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXZlcnNlSW5kZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAvLyBFU0MgJSBTZWxlY3QgZGVmYXVsdC91dGYtOCBjaGFyYWN0ZXIgc2V0LlxuICAgICAgICAgICAgICAgICAgICAvLyBAID0gZGVmYXVsdCwgRyA9IHV0Zi04XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJyUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy90aGlzLmNoYXJzZXQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRnTGV2ZWwoMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldGdDaGFyc2V0KDAsIFRlcm1pbmFsLmNoYXJzZXRzLlVTKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBub3JtYWw7XG4gICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgLy8gRVNDICgsKSwqLCssLSwuIERlc2lnbmF0ZSBHMC1HMiBDaGFyYWN0ZXIgU2V0LlxuICAgICAgICAgICAgICAgICAgICBjYXNlICcoJzogLy8gPC0tIHRoaXMgc2VlbXMgdG8gZ2V0IGFsbCB0aGUgYXR0ZW50aW9uXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJyknOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICcqJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICcuJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcoJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nY2hhcnNldCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJyknOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdjaGFyc2V0ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnKic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2NoYXJzZXQgPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcrJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nY2hhcnNldCA9IDM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdjaGFyc2V0ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnLic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2NoYXJzZXQgPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBjaGFyc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIC8vIERlc2lnbmF0ZSBHMyBDaGFyYWN0ZXIgU2V0IChWVDMwMCkuXG4gICAgICAgICAgICAgICAgICAgIC8vIEEgPSBJU08gTGF0aW4tMSBTdXBwbGVtZW50YWwuXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdCBpbXBsZW1lbnRlZC5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnLyc6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdjaGFyc2V0ID0gMztcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBjaGFyc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVTQyBOXG4gICAgICAgICAgICAgICAgICAgIC8vIFNpbmdsZSBTaGlmdCBTZWxlY3Qgb2YgRzIgQ2hhcmFjdGVyIFNldFxuICAgICAgICAgICAgICAgICAgICAvLyAoIFNTMiBpcyAweDhlKS4gVGhpcyBhZmZlY3RzIG5leHQgY2hhcmFjdGVyIG9ubHkuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ04nOlxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVTQyBPXG4gICAgICAgICAgICAgICAgICAgIC8vIFNpbmdsZSBTaGlmdCBTZWxlY3Qgb2YgRzMgQ2hhcmFjdGVyIFNldFxuICAgICAgICAgICAgICAgICAgICAvLyAoIFNTMyBpcyAweDhmKS4gVGhpcyBhZmZlY3RzIG5leHQgY2hhcmFjdGVyIG9ubHkuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ08nOlxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVTQyBuXG4gICAgICAgICAgICAgICAgICAgIC8vIEludm9rZSB0aGUgRzIgQ2hhcmFjdGVyIFNldCBhcyBHTCAoTFMyKS5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbic6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldGdMZXZlbCgyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAvLyBFU0Mgb1xuICAgICAgICAgICAgICAgICAgICAvLyBJbnZva2UgdGhlIEczIENoYXJhY3RlciBTZXQgYXMgR0wgKExTMykuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ28nOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRnTGV2ZWwoMyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgLy8gRVNDIHxcbiAgICAgICAgICAgICAgICAgICAgLy8gSW52b2tlIHRoZSBHMyBDaGFyYWN0ZXIgU2V0IGFzIEdSIChMUzNSKS5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnfCc6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldGdMZXZlbCgzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAvLyBFU0MgfVxuICAgICAgICAgICAgICAgICAgICAvLyBJbnZva2UgdGhlIEcyIENoYXJhY3RlciBTZXQgYXMgR1IgKExTMlIpLlxuICAgICAgICAgICAgICAgICAgICBjYXNlICd9JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0Z0xldmVsKDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVTQyB+XG4gICAgICAgICAgICAgICAgICAgIC8vIEludm9rZSB0aGUgRzEgQ2hhcmFjdGVyIFNldCBhcyBHUiAoTFMxUikuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ34nOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRnTGV2ZWwoMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgLy8gRVNDIDcgU2F2ZSBDdXJzb3IgKERFQ1NDKS5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnNyc6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNhdmVDdXJzb3IoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBub3JtYWw7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgLy8gRVNDIDggUmVzdG9yZSBDdXJzb3IgKERFQ1JDKS5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnOCc6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3RvcmVDdXJzb3IoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBub3JtYWw7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgLy8gRVNDICMgMyBERUMgbGluZSBoZWlnaHQvd2lkdGhcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnIyc6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gbm9ybWFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVTQyBIIFRhYiBTZXQgKEhUUyBpcyAweDg4KS5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnSCc6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRhYlNldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVTQyA9IEFwcGxpY2F0aW9uIEtleXBhZCAoREVDS1BBTSkuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJz0nOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2coJ1NlcmlhbCBwb3J0IHJlcXVlc3RlZCBhcHBsaWNhdGlvbiBrZXlwYWQuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGxpY2F0aW9uS2V5cGFkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmlld3BvcnQuc3luY1Njcm9sbEFyZWEoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBub3JtYWw7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgLy8gRVNDID4gTm9ybWFsIEtleXBhZCAoREVDS1BOTSkuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJz4nOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2coJ1N3aXRjaGluZyBiYWNrIHRvIG5vcm1hbCBrZXlwYWQuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGxpY2F0aW9uS2V5cGFkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdwb3J0LnN5bmNTY3JvbGxBcmVhKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gbm9ybWFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gbm9ybWFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcignVW5rbm93biBFU0MgY29udHJvbDogJXMuJywgY2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBjaGFyc2V0OlxuICAgICAgICAgICAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnMCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjcyA9IFRlcm1pbmFsLmNoYXJzZXRzLlNDTEQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnQSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjcyA9IFRlcm1pbmFsLmNoYXJzZXRzLlVLO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0InOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3MgPSBUZXJtaW5hbC5jaGFyc2V0cy5VUztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICc0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNzID0gVGVybWluYWwuY2hhcnNldHMuRHV0Y2g7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnQyc6IC8vIEZpbm5pc2hcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnNSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjcyA9IFRlcm1pbmFsLmNoYXJzZXRzLkZpbm5pc2g7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnUic6XG4gICAgICAgICAgICAgICAgICAgICAgICBjcyA9IFRlcm1pbmFsLmNoYXJzZXRzLkZyZW5jaDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdRJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNzID0gVGVybWluYWwuY2hhcnNldHMuRnJlbmNoQ2FuYWRpYW47XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnSyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjcyA9IFRlcm1pbmFsLmNoYXJzZXRzLkdlcm1hbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdZJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNzID0gVGVybWluYWwuY2hhcnNldHMuSXRhbGlhbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdFJzogLy8gTm9yd2VnaWFuRGFuaXNoXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJzYnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3MgPSBUZXJtaW5hbC5jaGFyc2V0cy5Ob3J3ZWdpYW5EYW5pc2g7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnWic6XG4gICAgICAgICAgICAgICAgICAgICAgICBjcyA9IFRlcm1pbmFsLmNoYXJzZXRzLlNwYW5pc2g7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnSCc6IC8vIFN3ZWRpc2hcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnNyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjcyA9IFRlcm1pbmFsLmNoYXJzZXRzLlN3ZWRpc2g7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnPSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjcyA9IFRlcm1pbmFsLmNoYXJzZXRzLlN3aXNzO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJy8nOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3MgPSBUZXJtaW5hbC5jaGFyc2V0cy5JU09MYXRpbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgY3MgPSBUZXJtaW5hbC5jaGFyc2V0cy5VUztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnNldGdDaGFyc2V0KHRoaXMuZ2NoYXJzZXQsIGNzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmdjaGFyc2V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gbm9ybWFsO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBvc2M6XG4gICAgICAgICAgICAgICAgLy8gT1NDIFBzIDsgUHQgU1RcbiAgICAgICAgICAgICAgICAvLyBPU0MgUHMgOyBQdCBCRUxcbiAgICAgICAgICAgICAgICAvLyAgIFNldCBUZXh0IFBhcmFtZXRlcnMuXG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXFx4MWInIHx8IGNoID09PSAnXFx4MDcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xceDFiJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJhbXMucHVzaCh0aGlzLmN1cnJlbnRQYXJhbSk7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5wYXJhbXNbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJhbXNbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50aXRsZSA9IHRoaXMucGFyYW1zWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVRpdGxlKHRoaXMudGl0bGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXQgWCBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoYW5nZSBkeW5hbWljIGNvbG9yc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGFuZ2UgZHluYW1pYyB1aSBjb2xvcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDY6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hhbmdlIGxvZyBmaWxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDUwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGR5bmFtaWMgZm9udFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1MTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlbWFjcyBzaGVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1MjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBtYW5pcHVsYXRlIHNlbGVjdGlvbiBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEwNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTA6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDExMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTEyOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTM6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDExNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTE1OlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTY6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDExNzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTE4OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlc2V0IGNvbG9yc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyYW1zID0gW107XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFBhcmFtID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IG5vcm1hbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5wYXJhbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPj0gJzAnICYmIGNoIDw9ICc5Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFBhcmFtID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50UGFyYW0gKiAxMCArIGNoLmNoYXJDb2RlQXQoMCkgLSA0ODtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoID09PSAnOycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmFtcy5wdXNoKHRoaXMuY3VycmVudFBhcmFtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRQYXJhbSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50UGFyYW0gKz0gY2g7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGNzaTpcbiAgICAgICAgICAgICAgICAvLyAnPycsICc+JywgJyEnXG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnPycgfHwgY2ggPT09ICc+JyB8fCBjaCA9PT0gJyEnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJlZml4ID0gY2g7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyAwIC0gOVxuICAgICAgICAgICAgICAgIGlmIChjaCA+PSAnMCcgJiYgY2ggPD0gJzknKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFBhcmFtID0gdGhpcy5jdXJyZW50UGFyYW0gKiAxMCArIGNoLmNoYXJDb2RlQXQoMCkgLSA0ODtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vICckJywgJ1wiJywgJyAnLCAnXFwnJ1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJyQnIHx8IGNoID09PSAnXCInIHx8IGNoID09PSAnICcgfHwgY2ggPT09ICdcXCcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9zdGZpeCA9IGNoO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJhbXMucHVzaCh0aGlzLmN1cnJlbnRQYXJhbSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50UGFyYW0gPSAwO1xuICAgICAgICAgICAgICAgIC8vICc7J1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJzsnKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gbm9ybWFsO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ1NJIFBzIEFcbiAgICAgICAgICAgICAgICAgICAgLy8gQ3Vyc29yIFVwIFBzIFRpbWVzIChkZWZhdWx0ID0gMSkgKENVVSkuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0EnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJzb3JVcCh0aGlzLnBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgLy8gQ1NJIFBzIEJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ3Vyc29yIERvd24gUHMgVGltZXMgKGRlZmF1bHQgPSAxKSAoQ1VEKS5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnQic6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnNvckRvd24odGhpcy5wYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIC8vIENTSSBQcyBDXG4gICAgICAgICAgICAgICAgICAgIC8vIEN1cnNvciBGb3J3YXJkIFBzIFRpbWVzIChkZWZhdWx0ID0gMSkgKENVRikuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJzb3JGb3J3YXJkKHRoaXMucGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAvLyBDU0kgUHMgRFxuICAgICAgICAgICAgICAgICAgICAvLyBDdXJzb3IgQmFja3dhcmQgUHMgVGltZXMgKGRlZmF1bHQgPSAxKSAoQ1VCKS5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnRCc6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnNvckJhY2t3YXJkKHRoaXMucGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAvLyBDU0kgUHMgOyBQcyBIXG4gICAgICAgICAgICAgICAgICAgIC8vIEN1cnNvciBQb3NpdGlvbiBbcm93O2NvbHVtbl0gKGRlZmF1bHQgPSBbMSwxXSkgKENVUCkuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0gnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJzb3JQb3ModGhpcy5wYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIC8vIENTSSBQcyBKICBFcmFzZSBpbiBEaXNwbGF5IChFRCkuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0onOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lcmFzZUluRGlzcGxheSh0aGlzLnBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgLy8gQ1NJIFBzIEsgIEVyYXNlIGluIExpbmUgKEVMKS5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnSyc6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVyYXNlSW5MaW5lKHRoaXMucGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAvLyBDU0kgUG0gbSAgQ2hhcmFjdGVyIEF0dHJpYnV0ZXMgKFNHUikuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ20nOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnByZWZpeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhckF0dHJpYnV0ZXModGhpcy5wYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIC8vIENTSSBQcyBuICBEZXZpY2UgU3RhdHVzIFJlcG9ydCAoRFNSKS5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbic6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMucHJlZml4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXZpY2VTdGF0dXModGhpcy5wYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBBZGRpdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIC8vIENTSSBQcyBAXG4gICAgICAgICAgICAgICAgICAgIC8vIEluc2VydCBQcyAoQmxhbmspIENoYXJhY3RlcihzKSAoZGVmYXVsdCA9IDEpIChJQ0gpLlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdAJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5zZXJ0Q2hhcnModGhpcy5wYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIC8vIENTSSBQcyBFXG4gICAgICAgICAgICAgICAgICAgIC8vIEN1cnNvciBOZXh0IExpbmUgUHMgVGltZXMgKGRlZmF1bHQgPSAxKSAoQ05MKS5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnRSc6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnNvck5leHRMaW5lKHRoaXMucGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAvLyBDU0kgUHMgRlxuICAgICAgICAgICAgICAgICAgICAvLyBDdXJzb3IgUHJlY2VkaW5nIExpbmUgUHMgVGltZXMgKGRlZmF1bHQgPSAxKSAoQ05MKS5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnRic6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnNvclByZWNlZGluZ0xpbmUodGhpcy5wYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIC8vIENTSSBQcyBHXG4gICAgICAgICAgICAgICAgICAgIC8vIEN1cnNvciBDaGFyYWN0ZXIgQWJzb2x1dGUgIFtjb2x1bW5dIChkZWZhdWx0ID0gW3JvdywxXSkgKENIQSkuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0cnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJzb3JDaGFyQWJzb2x1dGUodGhpcy5wYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIC8vIENTSSBQcyBMXG4gICAgICAgICAgICAgICAgICAgIC8vIEluc2VydCBQcyBMaW5lKHMpIChkZWZhdWx0ID0gMSkgKElMKS5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTCc6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluc2VydExpbmVzKHRoaXMucGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAvLyBDU0kgUHMgTVxuICAgICAgICAgICAgICAgICAgICAvLyBEZWxldGUgUHMgTGluZShzKSAoZGVmYXVsdCA9IDEpIChETCkuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ00nOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWxldGVMaW5lcyh0aGlzLnBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgLy8gQ1NJIFBzIFBcbiAgICAgICAgICAgICAgICAgICAgLy8gRGVsZXRlIFBzIENoYXJhY3RlcihzKSAoZGVmYXVsdCA9IDEpIChEQ0gpLlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdQJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsZXRlQ2hhcnModGhpcy5wYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIC8vIENTSSBQcyBYXG4gICAgICAgICAgICAgICAgICAgIC8vIEVyYXNlIFBzIENoYXJhY3RlcihzKSAoZGVmYXVsdCA9IDEpIChFQ0gpLlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdYJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXJhc2VDaGFycyh0aGlzLnBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgLy8gQ1NJIFBtIGAgIENoYXJhY3RlciBQb3NpdGlvbiBBYnNvbHV0ZVxuICAgICAgICAgICAgICAgICAgICAvLyAgIFtjb2x1bW5dIChkZWZhdWx0ID0gW3JvdywxXSkgKEhQQSkuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2AnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFyUG9zQWJzb2x1dGUodGhpcy5wYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIC8vIDE0MSA2MSBhICogSFBSIC1cbiAgICAgICAgICAgICAgICAgICAgLy8gSG9yaXpvbnRhbCBQb3NpdGlvbiBSZWxhdGl2ZVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdhJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuSFBvc2l0aW9uUmVsYXRpdmUodGhpcy5wYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIC8vIENTSSBQIHMgY1xuICAgICAgICAgICAgICAgICAgICAvLyBTZW5kIERldmljZSBBdHRyaWJ1dGVzIChQcmltYXJ5IERBKS5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ1NJID4gUCBzIGNcbiAgICAgICAgICAgICAgICAgICAgLy8gU2VuZCBEZXZpY2UgQXR0cmlidXRlcyAoU2Vjb25kYXJ5IERBKVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdjJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VuZERldmljZUF0dHJpYnV0ZXModGhpcy5wYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIC8vIENTSSBQbSBkXG4gICAgICAgICAgICAgICAgICAgIC8vIExpbmUgUG9zaXRpb24gQWJzb2x1dGUgIFtyb3ddIChkZWZhdWx0ID0gWzEsY29sdW1uXSkgKFZQQSkuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2QnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5lUG9zQWJzb2x1dGUodGhpcy5wYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIC8vIDE0NSA2NSBlICogVlBSIC0gVmVydGljYWwgUG9zaXRpb24gUmVsYXRpdmVcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLlZQb3NpdGlvblJlbGF0aXZlKHRoaXMucGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAvLyBDU0kgUHMgOyBQcyBmXG4gICAgICAgICAgICAgICAgICAgIC8vICAgSG9yaXpvbnRhbCBhbmQgVmVydGljYWwgUG9zaXRpb24gW3Jvdztjb2x1bW5dIChkZWZhdWx0ID1cbiAgICAgICAgICAgICAgICAgICAgLy8gICBbMSwxXSkgKEhWUCkuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2YnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5IVlBvc2l0aW9uKHRoaXMucGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAvLyBDU0kgUG0gaCAgU2V0IE1vZGUgKFNNKS5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ1NJID8gUG0gaCAtIG1vdXNlIGVzY2FwZSBjb2RlcywgY3Vyc29yIGVzY2FwZSBjb2Rlc1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdoJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0TW9kZSh0aGlzLnBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgLy8gQ1NJIFBtIGwgIFJlc2V0IE1vZGUgKFJNKS5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ1NJID8gUG0gbFxuICAgICAgICAgICAgICAgICAgICBjYXNlICdsJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzZXRNb2RlKHRoaXMucGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAvLyBDU0kgUHMgOyBQcyByXG4gICAgICAgICAgICAgICAgICAgIC8vICAgU2V0IFNjcm9sbGluZyBSZWdpb24gW3RvcDtib3R0b21dIChkZWZhdWx0ID0gZnVsbCBzaXplIG9mIHdpbi1cbiAgICAgICAgICAgICAgICAgICAgLy8gICBkb3cpIChERUNTVEJNKS5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ1NJID8gUG0gclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdyJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U2Nyb2xsUmVnaW9uKHRoaXMucGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAvLyBDU0kgc1xuICAgICAgICAgICAgICAgICAgICAvLyAgIFNhdmUgY3Vyc29yIChBTlNJLlNZUykuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zYXZlQ3Vyc29yKHRoaXMucGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAvLyBDU0kgdVxuICAgICAgICAgICAgICAgICAgICAvLyAgIFJlc3RvcmUgY3Vyc29yIChBTlNJLlNZUykuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3UnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXN0b3JlQ3Vyc29yKHRoaXMucGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogTGVzc2VyIFVzZWRcbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIC8vIENTSSBQcyBJXG4gICAgICAgICAgICAgICAgICAgIC8vIEN1cnNvciBGb3J3YXJkIFRhYnVsYXRpb24gUHMgdGFiIHN0b3BzIChkZWZhdWx0ID0gMSkgKENIVCkuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0knOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJzb3JGb3J3YXJkVGFiKHRoaXMucGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAvLyBDU0kgUHMgUyAgU2Nyb2xsIHVwIFBzIGxpbmVzIChkZWZhdWx0ID0gMSkgKFNVKS5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnUyc6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbFVwKHRoaXMucGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAvLyBDU0kgUHMgVCAgU2Nyb2xsIGRvd24gUHMgbGluZXMgKGRlZmF1bHQgPSAxKSAoU0QpLlxuICAgICAgICAgICAgICAgICAgICAvLyBDU0kgUHMgOyBQcyA7IFBzIDsgUHMgOyBQcyBUXG4gICAgICAgICAgICAgICAgICAgIC8vIENTSSA+IFBzOyBQcyBUXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1QnOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgKHRoaXMucHJlZml4ID09PSAnPicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgdGhpcy5yZXNldFRpdGxlTW9kZXModGhpcy5wYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmICh0aGlzLnBhcmFtcy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgIHRoaXMuaW5pdE1vdXNlVHJhY2tpbmcodGhpcy5wYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhcmFtcy5sZW5ndGggPCAyICYmICF0aGlzLnByZWZpeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsRG93bih0aGlzLnBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgLy8gQ1NJIFBzIFpcbiAgICAgICAgICAgICAgICAgICAgLy8gQ3Vyc29yIEJhY2t3YXJkIFRhYnVsYXRpb24gUHMgdGFiIHN0b3BzIChkZWZhdWx0ID0gMSkgKENCVCkuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1onOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJzb3JCYWNrd2FyZFRhYih0aGlzLnBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgLy8gQ1NJIFBzIGIgIFJlcGVhdCB0aGUgcHJlY2VkaW5nIGdyYXBoaWMgY2hhcmFjdGVyIFBzIHRpbWVzIChSRVApLlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdiJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwZWF0UHJlY2VkaW5nQ2hhcmFjdGVyKHRoaXMucGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAvLyBDU0kgUHMgZyAgVGFiIENsZWFyIChUQkMpLlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdnJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGFiQ2xlYXIodGhpcy5wYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIC8vIENTSSBQbSBpICBNZWRpYSBDb3B5IChNQykuXG4gICAgICAgICAgICAgICAgICAgIC8vIENTSSA/IFBtIGlcbiAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnaSc6XG4gICAgICAgICAgICAgICAgICAgIC8vICAgdGhpcy5tZWRpYUNvcHkodGhpcy5wYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAvLyAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAvLyBDU0kgUG0gbSAgQ2hhcmFjdGVyIEF0dHJpYnV0ZXMgKFNHUikuXG4gICAgICAgICAgICAgICAgICAgIC8vIENTSSA+IFBzOyBQcyBtXG4gICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ20nOiAvLyBkdXBsaWNhdGVcbiAgICAgICAgICAgICAgICAgICAgLy8gICBpZiAodGhpcy5wcmVmaXggPT09ICc+Jykge1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgdGhpcy5zZXRSZXNvdXJjZXModGhpcy5wYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAvLyAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICB0aGlzLmNoYXJBdHRyaWJ1dGVzKHRoaXMucGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gICB9XG4gICAgICAgICAgICAgICAgICAgIC8vICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIC8vIENTSSBQcyBuICBEZXZpY2UgU3RhdHVzIFJlcG9ydCAoRFNSKS5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ1NJID4gUHMgblxuICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICduJzogLy8gZHVwbGljYXRlXG4gICAgICAgICAgICAgICAgICAgIC8vICAgaWYgKHRoaXMucHJlZml4ID09PSAnPicpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIHRoaXMuZGlzYWJsZU1vZGlmaWVycyh0aGlzLnBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIHRoaXMuZGV2aWNlU3RhdHVzKHRoaXMucGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gICB9XG4gICAgICAgICAgICAgICAgICAgIC8vICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIC8vIENTSSA+IFBzIHAgIFNldCBwb2ludGVyIG1vZGUuXG4gICAgICAgICAgICAgICAgICAgIC8vIENTSSAhIHAgICBTb2Z0IHRlcm1pbmFsIHJlc2V0IChERUNTVFIpLlxuICAgICAgICAgICAgICAgICAgICAvLyBDU0kgUHMkIHBcbiAgICAgICAgICAgICAgICAgICAgLy8gICBSZXF1ZXN0IEFOU0kgbW9kZSAoREVDUlFNKS5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ1NJID8gUHMkIHBcbiAgICAgICAgICAgICAgICAgICAgLy8gICBSZXF1ZXN0IERFQyBwcml2YXRlIG1vZGUgKERFQ1JRTSkuXG4gICAgICAgICAgICAgICAgICAgIC8vIENTSSBQcyA7IFBzIFwiIHBcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMucHJlZml4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnPic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICB0aGlzLnNldFBvaW50ZXJNb2RlKHRoaXMucGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJyEnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNvZnRSZXNldCh0aGlzLnBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIC8vIENTSSBQcyBxICBMb2FkIExFRHMgKERFQ0xMKS5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ1NJIFBzIFNQIHFcbiAgICAgICAgICAgICAgICAgICAgLy8gQ1NJIFBzIFwiIHFcbiAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAncSc6XG4gICAgICAgICAgICAgICAgICAgIC8vICAgaWYgKHRoaXMucG9zdGZpeCA9PT0gJyAnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICB0aGlzLnNldEN1cnNvclN0eWxlKHRoaXMucGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAvLyAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gICBpZiAodGhpcy5wb3N0Zml4ID09PSAnXCInKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICB0aGlzLnNldENoYXJQcm90ZWN0aW9uQXR0cih0aGlzLnBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgLy8gICB9XG4gICAgICAgICAgICAgICAgICAgIC8vICAgdGhpcy5sb2FkTEVEcyh0aGlzLnBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIC8vIENTSSBQcyA7IFBzIHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICBTZXQgU2Nyb2xsaW5nIFJlZ2lvbiBbdG9wO2JvdHRvbV0gKGRlZmF1bHQgPSBmdWxsIHNpemUgb2Ygd2luLVxuICAgICAgICAgICAgICAgICAgICAvLyAgIGRvdykgKERFQ1NUQk0pLlxuICAgICAgICAgICAgICAgICAgICAvLyBDU0kgPyBQbSByXG4gICAgICAgICAgICAgICAgICAgIC8vIENTSSBQdDsgUGw7IFBiOyBQcjsgUHMkIHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAncic6IC8vIGR1cGxpY2F0ZVxuICAgICAgICAgICAgICAgICAgICAvLyAgIGlmICh0aGlzLnByZWZpeCA9PT0gJz8nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICB0aGlzLnJlc3RvcmVQcml2YXRlVmFsdWVzKHRoaXMucGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gICB9IGVsc2UgaWYgKHRoaXMucG9zdGZpeCA9PT0gJyQnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICB0aGlzLnNldEF0dHJJblJlY3RhbmdsZSh0aGlzLnBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIHRoaXMuc2V0U2Nyb2xsUmVnaW9uKHRoaXMucGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gICB9XG4gICAgICAgICAgICAgICAgICAgIC8vICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIC8vIENTSSBzICAgICBTYXZlIGN1cnNvciAoQU5TSS5TWVMpLlxuICAgICAgICAgICAgICAgICAgICAvLyBDU0kgPyBQbSBzXG4gICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ3MnOiAvLyBkdXBsaWNhdGVcbiAgICAgICAgICAgICAgICAgICAgLy8gICBpZiAodGhpcy5wcmVmaXggPT09ICc/Jykge1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgdGhpcy5zYXZlUHJpdmF0ZVZhbHVlcyh0aGlzLnBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIHRoaXMuc2F2ZUN1cnNvcih0aGlzLnBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAvLyBDU0kgUHMgOyBQcyA7IFBzIHRcbiAgICAgICAgICAgICAgICAgICAgLy8gQ1NJIFB0OyBQbDsgUGI7IFByOyBQcyQgdFxuICAgICAgICAgICAgICAgICAgICAvLyBDU0kgPiBQczsgUHMgdFxuICAgICAgICAgICAgICAgICAgICAvLyBDU0kgUHMgU1AgdFxuICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICd0JzpcbiAgICAgICAgICAgICAgICAgICAgLy8gICBpZiAodGhpcy5wb3N0Zml4ID09PSAnJCcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIHRoaXMucmV2ZXJzZUF0dHJJblJlY3RhbmdsZSh0aGlzLnBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgfSBlbHNlIGlmICh0aGlzLnBvc3RmaXggPT09ICcgJykge1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgdGhpcy5zZXRXYXJuaW5nQmVsbFZvbHVtZSh0aGlzLnBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIGlmICh0aGlzLnByZWZpeCA9PT0gJz4nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgIHRoaXMuc2V0VGl0bGVNb2RlRmVhdHVyZSh0aGlzLnBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICB0aGlzLm1hbmlwdWxhdGVXaW5kb3codGhpcy5wYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgLy8gQ1NJIHUgICAgIFJlc3RvcmUgY3Vyc29yIChBTlNJLlNZUykuXG4gICAgICAgICAgICAgICAgICAgIC8vIENTSSBQcyBTUCB1XG4gICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ3UnOiAvLyBkdXBsaWNhdGVcbiAgICAgICAgICAgICAgICAgICAgLy8gICBpZiAodGhpcy5wb3N0Zml4ID09PSAnICcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIHRoaXMuc2V0TWFyZ2luQmVsbFZvbHVtZSh0aGlzLnBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIHRoaXMucmVzdG9yZUN1cnNvcih0aGlzLnBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAvLyBDU0kgUHQ7IFBsOyBQYjsgUHI7IFBwOyBQdDsgUGw7IFBwJCB2XG4gICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ3YnOlxuICAgICAgICAgICAgICAgICAgICAvLyAgIGlmICh0aGlzLnBvc3RmaXggPT09ICckJykge1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgdGhpcy5jb3B5UmVjdGFnbGUodGhpcy5wYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAvLyAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgLy8gQ1NJIFB0IDsgUGwgOyBQYiA7IFByICcgd1xuICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICd3JzpcbiAgICAgICAgICAgICAgICAgICAgLy8gICBpZiAodGhpcy5wb3N0Zml4ID09PSAnXFwnJykge1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgdGhpcy5lbmFibGVGaWx0ZXJSZWN0YW5nbGUodGhpcy5wYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAvLyAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgLy8gQ1NJIFBzIHggIFJlcXVlc3QgVGVybWluYWwgUGFyYW1ldGVycyAoREVDUkVRVFBBUk0pLlxuICAgICAgICAgICAgICAgICAgICAvLyBDU0kgUHMgeCAgU2VsZWN0IEF0dHJpYnV0ZSBDaGFuZ2UgRXh0ZW50IChERUNTQUNFKS5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ1NJIFBjOyBQdDsgUGw7IFBiOyBQciQgeFxuICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICd4JzpcbiAgICAgICAgICAgICAgICAgICAgLy8gICBpZiAodGhpcy5wb3N0Zml4ID09PSAnJCcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIHRoaXMuZmlsbFJlY3RhbmdsZSh0aGlzLnBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIHRoaXMucmVxdWVzdFBhcmFtZXRlcnModGhpcy5wYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgLy90aGlzLl9fKHRoaXMucGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gICB9XG4gICAgICAgICAgICAgICAgICAgIC8vICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIC8vIENTSSBQcyA7IFB1ICcgelxuICAgICAgICAgICAgICAgICAgICAvLyBDU0kgUHQ7IFBsOyBQYjsgUHIkIHpcbiAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAneic6XG4gICAgICAgICAgICAgICAgICAgIC8vICAgaWYgKHRoaXMucG9zdGZpeCA9PT0gJ1xcJycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIHRoaXMuZW5hYmxlTG9jYXRvclJlcG9ydGluZyh0aGlzLnBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgfSBlbHNlIGlmICh0aGlzLnBvc3RmaXggPT09ICckJykge1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgdGhpcy5lcmFzZVJlY3RhbmdsZSh0aGlzLnBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAvLyBDU0kgUG0gJyB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENTSSBQdDsgUGw7IFBiOyBQciQge1xuICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICd7JzpcbiAgICAgICAgICAgICAgICAgICAgLy8gICBpZiAodGhpcy5wb3N0Zml4ID09PSAnXFwnJykge1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgdGhpcy5zZXRMb2NhdG9yRXZlbnRzKHRoaXMucGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gICB9IGVsc2UgaWYgKHRoaXMucG9zdGZpeCA9PT0gJyQnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICB0aGlzLnNlbGVjdGl2ZUVyYXNlUmVjdGFuZ2xlKHRoaXMucGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gICB9XG4gICAgICAgICAgICAgICAgICAgIC8vICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIC8vIENTSSBQcyAnIHxcbiAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnfCc6XG4gICAgICAgICAgICAgICAgICAgIC8vICAgaWYgKHRoaXMucG9zdGZpeCA9PT0gJ1xcJycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIHRoaXMucmVxdWVzdExvY2F0b3JQb3NpdGlvbih0aGlzLnBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAvLyBDU0kgUCBtIFNQIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gSW5zZXJ0IFAgcyBDb2x1bW4ocykgKGRlZmF1bHQgPSAxKSAoREVDSUMpLCBWVDQyMCBhbmQgdXAuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ30nOlxuICAgICAgICAgICAgICAgICAgICAvLyAgIGlmICh0aGlzLnBvc3RmaXggPT09ICcgJykge1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgdGhpcy5pbnNlcnRDb2x1bW5zKHRoaXMucGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gICB9XG4gICAgICAgICAgICAgICAgICAgIC8vICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIC8vIENTSSBQIG0gU1AgflxuICAgICAgICAgICAgICAgICAgICAvLyBEZWxldGUgUCBzIENvbHVtbihzKSAoZGVmYXVsdCA9IDEpIChERUNEQyksIFZUNDIwIGFuZCB1cFxuICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICd+JzpcbiAgICAgICAgICAgICAgICAgICAgLy8gICBpZiAodGhpcy5wb3N0Zml4ID09PSAnICcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIHRoaXMuZGVsZXRlQ29sdW1ucyh0aGlzLnBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcignVW5rbm93biBDU0kgY29kZTogJXMuJywgY2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucHJlZml4ID0gJyc7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3N0Zml4ID0gJyc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGRjczpcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICdcXHgxYicgfHwgY2ggPT09ICdcXHgwNycpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXFx4MWInKVxuICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMucHJlZml4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2VyLURlZmluZWQgS2V5cyAoREVDVURLKS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXF1ZXN0IFN0YXR1cyBTdHJpbmcgKERFQ1JRU1MpLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGVzdDogZWNobyAtZSAnXFxlUCRxXCJwXFxlXFxcXCdcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJyRxJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHQgPSB0aGlzLmN1cnJlbnRQYXJhbSwgdmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERFQ1NDQVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdcInEnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHQgPSAnMFwicSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gREVDU0NMXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ1wicCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdCA9ICc2MVwicCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gREVDU1RCTVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdyJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB0ID0gJydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArICh0aGlzLnNjcm9sbFRvcCArIDEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyAnOydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArICh0aGlzLnNjcm9sbEJvdHRvbSArIDEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyAncic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU0dSXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ20nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHQgPSAnMG0nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yKCdVbmtub3duIERDUyBQdDogJXMuJywgcHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHQgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbmQoJ1xceDFiUCcgKyArdmFsaWQgKyAnJHInICsgcHQgKyAnXFx4MWJcXFxcJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTZXQgVGVybWNhcC9UZXJtaW5mbyBEYXRhICh4dGVybSwgZXhwZXJpbWVudGFsKS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJytwJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlcXVlc3QgVGVybWNhcC9UZXJtaW5mbyBTdHJpbmcgKHh0ZXJtLCBleHBlcmltZW50YWwpXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZWd1bGFyIHh0ZXJtIGRvZXMgbm90IGV2ZW4gcmVzcG9uZCB0byB0aGlzIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBjYW4gY2F1c2UgYSBzbWFsbCBnbGl0Y2ggaW4gdmltLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGVzdDogZWNobyAtbmUgJ1xcZVArcTZiNjRcXGVcXFxcJ1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnK3EnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwdCA9IHRoaXMuY3VycmVudFBhcmFtLCB2YWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VuZCgnXFx4MWJQJyArICt2YWxpZCArICcrcicgKyBwdCArICdcXHgxYlxcXFwnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcignVW5rbm93biBEQ1MgcHJlZml4OiAlcy4nLCB0aGlzLnByZWZpeCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50UGFyYW0gPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByZWZpeCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gbm9ybWFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghdGhpcy5jdXJyZW50UGFyYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnByZWZpeCAmJiBjaCAhPT0gJyQnICYmIGNoICE9PSAnKycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFBhcmFtID0gY2g7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5wcmVmaXgubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRQYXJhbSA9IGNoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmVmaXggKz0gY2g7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFBhcmFtICs9IGNoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgaWdub3JlOlxuICAgICAgICAgICAgICAgIC8vIEZvciBQTSBhbmQgQVBDLlxuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xceDFiJyB8fCBjaCA9PT0gJ1xceDA3Jykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICdcXHgxYicpXG4gICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBub3JtYWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMudXBkYXRlUmFuZ2UodGhpcy55KTtcbiAgICB0aGlzLnJlZnJlc2godGhpcy5yZWZyZXNoU3RhcnQsIHRoaXMucmVmcmVzaEVuZCk7XG59O1xuLyoqXG4gKiBXcml0ZXMgdGV4dCB0byB0aGUgdGVybWluYWwsIGZvbGxvd2VkIGJ5IGEgYnJlYWsgbGluZSBjaGFyYWN0ZXIgKFxcbikuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUaGUgdGV4dCB0byB3cml0ZSB0byB0aGUgdGVybWluYWwuXG4gKi9cblRlcm1pbmFsLnByb3RvdHlwZS53cml0ZWxuID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB0aGlzLndyaXRlKGRhdGEgKyAnXFxyXFxuJyk7XG59O1xuLyoqXG4gKiBBdHRhY2hlcyBhIGN1c3RvbSBrZXlkb3duIGhhbmRsZXIgd2hpY2ggaXMgcnVuIGJlZm9yZSBrZXlzIGFyZSBwcm9jZXNzZWQsIGdpdmluZyBjb25zdW1lcnMgb2ZcbiAqIHh0ZXJtLmpzIHVsdGltYXRlIGNvbnRyb2wgYXMgdG8gd2hhdCBrZXlzIHNob3VsZCBiZSBwcm9jZXNzZWQgYnkgdGhlIHRlcm1pbmFsIGFuZCB3aGF0IGtleXNcbiAqIHNob3VsZCBub3QuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjdXN0b21LZXlkb3duSGFuZGxlciBUaGUgY3VzdG9tIEtleWJvYXJkRXZlbnQgaGFuZGxlciB0byBhdHRhY2guIFRoaXMgaXMgYVxuICogICBmdW5jdGlvbiB0aGF0IHRha2VzIGEgS2V5Ym9hcmRFdmVudCwgYWxsb3dpbmcgY29uc3VtZXJzIHRvIHN0b3AgcHJvcG9nYXRpb24gYW5kL29yIHByZXZlbnRcbiAqICAgdGhlIGRlZmF1bHQgYWN0aW9uLiBUaGUgZnVuY3Rpb24gcmV0dXJucyB3aGV0aGVyIHRoZSBldmVudCBzaG91bGQgYmUgcHJvY2Vzc2VkIGJ5IHh0ZXJtLmpzLlxuICovXG5UZXJtaW5hbC5wcm90b3R5cGUuYXR0YWNoQ3VzdG9tS2V5ZG93bkhhbmRsZXIgPSBmdW5jdGlvbiAoY3VzdG9tS2V5ZG93bkhhbmRsZXIpIHtcbiAgICB0aGlzLmN1c3RvbUtleWRvd25IYW5kbGVyID0gY3VzdG9tS2V5ZG93bkhhbmRsZXI7XG59O1xuLyoqXG4gKiBIYW5kbGUgYSBrZXlkb3duIGV2ZW50XG4gKiBLZXkgUmVzb3VyY2VzOlxuICogICAtIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvRE9NL0tleWJvYXJkRXZlbnRcbiAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZXYgVGhlIGtleWRvd24gZXZlbnQgdG8gYmUgaGFuZGxlZC5cbiAqL1xuVGVybWluYWwucHJvdG90eXBlLmtleURvd24gPSBmdW5jdGlvbiAoZXYpIHtcbiAgICBpZiAodGhpcy5jdXN0b21LZXlkb3duSGFuZGxlciAmJiB0aGlzLmN1c3RvbUtleWRvd25IYW5kbGVyKGV2KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuY29tcG9zaXRpb25IZWxwZXIua2V5ZG93bi5iaW5kKHRoaXMuY29tcG9zaXRpb25IZWxwZXIpKGV2KSkge1xuICAgICAgICBpZiAodGhpcy55YmFzZSAhPT0gdGhpcy55ZGlzcCkge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxUb0JvdHRvbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciByZXN1bHQgPSB0aGlzLmV2YWx1YXRlS2V5RXNjYXBlU2VxdWVuY2UoZXYpO1xuICAgIGlmIChyZXN1bHQuc2Nyb2xsRGlzcCkge1xuICAgICAgICB0aGlzLnNjcm9sbERpc3AocmVzdWx0LnNjcm9sbERpc3ApO1xuICAgICAgICByZXR1cm4gdGhpcy5jYW5jZWwoZXYsIHRydWUpO1xuICAgIH1cbiAgICBpZiAoaXNUaGlyZExldmVsU2hpZnQodGhpcywgZXYpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAocmVzdWx0LmNhbmNlbCkge1xuICAgICAgICAvLyBUaGUgZXZlbnQgaXMgY2FuY2VsZWQgYXQgdGhlIGVuZCBhbHJlYWR5LCBpcyB0aGlzIG5lY2Vzc2FyeT9cbiAgICAgICAgdGhpcy5jYW5jZWwoZXYsIHRydWUpO1xuICAgIH1cbiAgICBpZiAoIXJlc3VsdC5rZXkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHRoaXMuZW1pdCgna2V5ZG93bicsIGV2KTtcbiAgICB0aGlzLmVtaXQoJ2tleScsIHJlc3VsdC5rZXksIGV2KTtcbiAgICB0aGlzLnNob3dDdXJzb3IoKTtcbiAgICB0aGlzLmhhbmRsZXIocmVzdWx0LmtleSk7XG4gICAgcmV0dXJuIHRoaXMuY2FuY2VsKGV2LCB0cnVlKTtcbn07XG4vKipcbiAqIFJldHVybnMgYW4gb2JqZWN0IHRoYXQgZGV0ZXJtaW5lcyBob3cgYSBLZXlib2FyZEV2ZW50IHNob3VsZCBiZSBoYW5kbGVkLiBUaGUga2V5IG9mIHRoZVxuICogcmV0dXJuZWQgdmFsdWUgaXMgdGhlIG5ldyBrZXkgY29kZSB0byBwYXNzIHRvIHRoZSBQVFkuXG4gKlxuICogUmVmZXJlbmNlOiBodHRwOi8vaW52aXNpYmxlLWlzbGFuZC5uZXQveHRlcm0vY3Rsc2Vxcy9jdGxzZXFzLmh0bWxcbiAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZXYgVGhlIGtleWJvYXJkIGV2ZW50IHRvIGJlIHRyYW5zbGF0ZWQgdG8ga2V5IGVzY2FwZSBzZXF1ZW5jZS5cbiAqL1xuVGVybWluYWwucHJvdG90eXBlLmV2YWx1YXRlS2V5RXNjYXBlU2VxdWVuY2UgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAvLyBXaGV0aGVyIHRvIGNhbmNlbCBldmVudCBwcm9wb2dhdGlvbiAoTk9URTogdGhpcyBtYXkgbm90IGJlIG5lZWRlZCBzaW5jZSB0aGUgZXZlbnQgaXNcbiAgICAgICAgLy8gY2FuY2VsZWQgYXQgdGhlIGVuZCBvZiBrZXlEb3duXG4gICAgICAgIGNhbmNlbDogZmFsc2UsXG4gICAgICAgIC8vIFRoZSBuZXcga2V5IGV2ZW4gdG8gZW1pdFxuICAgICAgICBrZXk6IHVuZGVmaW5lZCxcbiAgICAgICAgLy8gVGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIHRvIHNjcm9sbCwgaWYgdGhpcyBpcyBkZWZpbmVkIGl0IHdpbGwgY2FuY2VsIHRoZSBldmVudFxuICAgICAgICBzY3JvbGxEaXNwOiB1bmRlZmluZWRcbiAgICB9O1xuICAgIHZhciBtb2RpZmllcnMgPSBldi5zaGlmdEtleSA8PCAwIHwgZXYuYWx0S2V5IDw8IDEgfCBldi5jdHJsS2V5IDw8IDIgfCBldi5tZXRhS2V5IDw8IDM7XG4gICAgc3dpdGNoIChldi5rZXlDb2RlKSB7XG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIC8vIGJhY2tzcGFjZVxuICAgICAgICAgICAgaWYgKGV2LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmtleSA9ICdcXHgwOCc7IC8vIF5IXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQua2V5ID0gJ1xceDdmJzsgLy8gXj9cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAvLyB0YWJcbiAgICAgICAgICAgIGlmIChldi5zaGlmdEtleSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5rZXkgPSAnXFx4MWJbWic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQua2V5ID0gJ1xcdCc7XG4gICAgICAgICAgICByZXN1bHQuY2FuY2VsID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgLy8gcmV0dXJuL2VudGVyXG4gICAgICAgICAgICByZXN1bHQua2V5ID0gJ1xccic7XG4gICAgICAgICAgICByZXN1bHQuY2FuY2VsID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI3OlxuICAgICAgICAgICAgLy8gZXNjYXBlXG4gICAgICAgICAgICByZXN1bHQua2V5ID0gJ1xceDFiJztcbiAgICAgICAgICAgIHJlc3VsdC5jYW5jZWwgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzc6XG4gICAgICAgICAgICAvLyBsZWZ0LWFycm93XG4gICAgICAgICAgICBpZiAobW9kaWZpZXJzKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmtleSA9ICdcXHgxYlsxOycgKyAobW9kaWZpZXJzICsgMSkgKyAnRCc7XG4gICAgICAgICAgICAgICAgLy8gSEFDSzogTWFrZSBBbHQgKyBsZWZ0LWFycm93IGJlaGF2ZSBsaWtlIEN0cmwgKyBsZWZ0LWFycm93OiBtb3ZlIG9uZSB3b3JkIGJhY2t3YXJkc1xuICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly91bml4LnN0YWNrZXhjaGFuZ2UuY29tL2EvMTA4MTA2XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5rZXkgPT0gJ1xceDFiWzE7M0QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5rZXkgPSAnXFx4MWJbMTs1RCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5hcHBsaWNhdGlvbkN1cnNvcikge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5rZXkgPSAnXFx4MWJPRCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQua2V5ID0gJ1xceDFiW0QnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzk6XG4gICAgICAgICAgICAvLyByaWdodC1hcnJvd1xuICAgICAgICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5rZXkgPSAnXFx4MWJbMTsnICsgKG1vZGlmaWVycyArIDEpICsgJ0MnO1xuICAgICAgICAgICAgICAgIC8vIEhBQ0s6IE1ha2UgQWx0ICsgcmlnaHQtYXJyb3cgYmVoYXZlIGxpa2UgQ3RybCArIHJpZ2h0LWFycm93OiBtb3ZlIG9uZSB3b3JkIGZvcndhcmRcbiAgICAgICAgICAgICAgICAvLyBodHRwOi8vdW5peC5zdGFja2V4Y2hhbmdlLmNvbS9hLzEwODEwNlxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQua2V5ID09ICdcXHgxYlsxOzNDJykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQua2V5ID0gJ1xceDFiWzE7NUMnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuYXBwbGljYXRpb25DdXJzb3IpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQua2V5ID0gJ1xceDFiT0MnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmtleSA9ICdcXHgxYltDJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM4OlxuICAgICAgICAgICAgLy8gdXAtYXJyb3dcbiAgICAgICAgICAgIGlmIChtb2RpZmllcnMpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQua2V5ID0gJ1xceDFiWzE7JyArIChtb2RpZmllcnMgKyAxKSArICdBJztcbiAgICAgICAgICAgICAgICAvLyBIQUNLOiBNYWtlIEFsdCArIHVwLWFycm93IGJlaGF2ZSBsaWtlIEN0cmwgKyB1cC1hcnJvd1xuICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly91bml4LnN0YWNrZXhjaGFuZ2UuY29tL2EvMTA4MTA2XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5rZXkgPT0gJ1xceDFiWzE7M0EnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5rZXkgPSAnXFx4MWJbMTs1QSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5hcHBsaWNhdGlvbkN1cnNvcikge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5rZXkgPSAnXFx4MWJPQSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQua2V5ID0gJ1xceDFiW0EnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNDA6XG4gICAgICAgICAgICAvLyBkb3duLWFycm93XG4gICAgICAgICAgICBpZiAobW9kaWZpZXJzKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmtleSA9ICdcXHgxYlsxOycgKyAobW9kaWZpZXJzICsgMSkgKyAnQic7XG4gICAgICAgICAgICAgICAgLy8gSEFDSzogTWFrZSBBbHQgKyBkb3duLWFycm93IGJlaGF2ZSBsaWtlIEN0cmwgKyBkb3duLWFycm93XG4gICAgICAgICAgICAgICAgLy8gaHR0cDovL3VuaXguc3RhY2tleGNoYW5nZS5jb20vYS8xMDgxMDZcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmtleSA9PSAnXFx4MWJbMTszQicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmtleSA9ICdcXHgxYlsxOzVCJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmFwcGxpY2F0aW9uQ3Vyc29yKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmtleSA9ICdcXHgxYk9CJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5rZXkgPSAnXFx4MWJbQic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0NTpcbiAgICAgICAgICAgIC8vIGluc2VydFxuICAgICAgICAgICAgaWYgKCFldi5zaGlmdEtleSAmJiAhZXYuY3RybEtleSkge1xuICAgICAgICAgICAgICAgIC8vIDxDdHJsPiBvciA8U2hpZnQ+ICsgPEluc2VydD4gYXJlIHVzZWQgdG9cbiAgICAgICAgICAgICAgICAvLyBjb3B5LXBhc3RlIG9uIHNvbWUgc3lzdGVtcy5cbiAgICAgICAgICAgICAgICByZXN1bHQua2V5ID0gJ1xceDFiWzJ+JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQ2OlxuICAgICAgICAgICAgLy8gZGVsZXRlXG4gICAgICAgICAgICBpZiAobW9kaWZpZXJzKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmtleSA9ICdcXHgxYlszOycgKyAobW9kaWZpZXJzICsgMSkgKyAnfic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQua2V5ID0gJ1xceDFiWzN+JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM2OlxuICAgICAgICAgICAgLy8gaG9tZVxuICAgICAgICAgICAgaWYgKG1vZGlmaWVycylcbiAgICAgICAgICAgICAgICByZXN1bHQua2V5ID0gJ1xceDFiWzE7JyArIChtb2RpZmllcnMgKyAxKSArICdIJztcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuYXBwbGljYXRpb25DdXJzb3IpXG4gICAgICAgICAgICAgICAgcmVzdWx0LmtleSA9ICdcXHgxYk9IJztcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXN1bHQua2V5ID0gJ1xceDFiW0gnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzU6XG4gICAgICAgICAgICAvLyBlbmRcbiAgICAgICAgICAgIGlmIChtb2RpZmllcnMpXG4gICAgICAgICAgICAgICAgcmVzdWx0LmtleSA9ICdcXHgxYlsxOycgKyAobW9kaWZpZXJzICsgMSkgKyAnRic7XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmFwcGxpY2F0aW9uQ3Vyc29yKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5rZXkgPSAnXFx4MWJPRic7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmVzdWx0LmtleSA9ICdcXHgxYltGJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDMzOlxuICAgICAgICAgICAgLy8gcGFnZSB1cFxuICAgICAgICAgICAgaWYgKGV2LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnNjcm9sbERpc3AgPSAtKHRoaXMucm93cyAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmtleSA9ICdcXHgxYls1fic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzNDpcbiAgICAgICAgICAgIC8vIHBhZ2UgZG93blxuICAgICAgICAgICAgaWYgKGV2LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnNjcm9sbERpc3AgPSB0aGlzLnJvd3MgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmtleSA9ICdcXHgxYls2fic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMTI6XG4gICAgICAgICAgICAvLyBGMS1GMTJcbiAgICAgICAgICAgIGlmIChtb2RpZmllcnMpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQua2V5ID0gJ1xceDFiWzE7JyArIChtb2RpZmllcnMgKyAxKSArICdQJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5rZXkgPSAnXFx4MWJPUCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMTM6XG4gICAgICAgICAgICBpZiAobW9kaWZpZXJzKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmtleSA9ICdcXHgxYlsxOycgKyAobW9kaWZpZXJzICsgMSkgKyAnUSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQua2V5ID0gJ1xceDFiT1EnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTE0OlxuICAgICAgICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5rZXkgPSAnXFx4MWJbMTsnICsgKG1vZGlmaWVycyArIDEpICsgJ1InO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmtleSA9ICdcXHgxYk9SJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDExNTpcbiAgICAgICAgICAgIGlmIChtb2RpZmllcnMpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQua2V5ID0gJ1xceDFiWzE7JyArIChtb2RpZmllcnMgKyAxKSArICdTJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5rZXkgPSAnXFx4MWJPUyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMTY6XG4gICAgICAgICAgICBpZiAobW9kaWZpZXJzKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmtleSA9ICdcXHgxYlsxNTsnICsgKG1vZGlmaWVycyArIDEpICsgJ34nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmtleSA9ICdcXHgxYlsxNX4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTE3OlxuICAgICAgICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5rZXkgPSAnXFx4MWJbMTc7JyArIChtb2RpZmllcnMgKyAxKSArICd+JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5rZXkgPSAnXFx4MWJbMTd+JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDExODpcbiAgICAgICAgICAgIGlmIChtb2RpZmllcnMpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQua2V5ID0gJ1xceDFiWzE4OycgKyAobW9kaWZpZXJzICsgMSkgKyAnfic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQua2V5ID0gJ1xceDFiWzE4fic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMTk6XG4gICAgICAgICAgICBpZiAobW9kaWZpZXJzKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmtleSA9ICdcXHgxYlsxOTsnICsgKG1vZGlmaWVycyArIDEpICsgJ34nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmtleSA9ICdcXHgxYlsxOX4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTIwOlxuICAgICAgICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5rZXkgPSAnXFx4MWJbMjA7JyArIChtb2RpZmllcnMgKyAxKSArICd+JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5rZXkgPSAnXFx4MWJbMjB+JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEyMTpcbiAgICAgICAgICAgIGlmIChtb2RpZmllcnMpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQua2V5ID0gJ1xceDFiWzIxOycgKyAobW9kaWZpZXJzICsgMSkgKyAnfic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQua2V5ID0gJ1xceDFiWzIxfic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMjI6XG4gICAgICAgICAgICBpZiAobW9kaWZpZXJzKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmtleSA9ICdcXHgxYlsyMzsnICsgKG1vZGlmaWVycyArIDEpICsgJ34nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmtleSA9ICdcXHgxYlsyM34nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTIzOlxuICAgICAgICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5rZXkgPSAnXFx4MWJbMjQ7JyArIChtb2RpZmllcnMgKyAxKSArICd+JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5rZXkgPSAnXFx4MWJbMjR+JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgLy8gYS16IGFuZCBzcGFjZVxuICAgICAgICAgICAgaWYgKGV2LmN0cmxLZXkgJiYgIWV2LnNoaWZ0S2V5ICYmICFldi5hbHRLZXkgJiYgIWV2Lm1ldGFLZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXYua2V5Q29kZSA+PSA2NSAmJiBldi5rZXlDb2RlIDw9IDkwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5rZXkgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGV2LmtleUNvZGUgLSA2NCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGV2LmtleUNvZGUgPT09IDMyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5VTFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQua2V5ID0gU3RyaW5nLmZyb21DaGFyQ29kZSgwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZXYua2V5Q29kZSA+PSA1MSAmJiBldi5rZXlDb2RlIDw9IDU1KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzY2FwZSwgZmlsZSBzZXAsIGdyb3VwIHNlcCwgcmVjb3JkIHNlcCwgdW5pdCBzZXBcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmtleSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoZXYua2V5Q29kZSAtIDUxICsgMjcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChldi5rZXlDb2RlID09PSA1Nikge1xuICAgICAgICAgICAgICAgICAgICAvLyBkZWxldGVcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmtleSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMTI3KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZXYua2V5Q29kZSA9PT0gMjE5KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIF5bIC0gQ29udHJvbCBTZXF1ZW5jZSBJbnRyb2R1Y2VyIChDU0kpXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5rZXkgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDI3KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZXYua2V5Q29kZSA9PT0gMjIwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIF5cXCAtIFN0cmluZyBUZXJtaW5hdG9yIChTVClcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmtleSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMjgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChldi5rZXlDb2RlID09PSAyMjEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gXl0gLSBPcGVyYXRpbmcgU3lzdGVtIENvbW1hbmQgKE9TQylcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmtleSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMjkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLmJyb3dzZXIuaXNNYWMgJiYgZXYuYWx0S2V5ICYmICFldi5jdHJsS2V5ICYmICFldi5tZXRhS2V5KSB7XG4gICAgICAgICAgICAgICAgLy8gT24gTWFjIHRoaXMgaXMgYSB0aGlyZCBsZXZlbCBzaGlmdC4gVXNlIDxFc2M+IGluc3RlYWQuXG4gICAgICAgICAgICAgICAgaWYgKGV2LmtleUNvZGUgPj0gNjUgJiYgZXYua2V5Q29kZSA8PSA5MCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQua2V5ID0gJ1xceDFiJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoZXYua2V5Q29kZSArIDMyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZXYua2V5Q29kZSA9PT0gMTkyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5rZXkgPSAnXFx4MWJgJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZXYua2V5Q29kZSA+PSA0OCAmJiBldi5rZXlDb2RlIDw9IDU3KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5rZXkgPSAnXFx4MWInICsgKGV2LmtleUNvZGUgLSA0OCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuLyoqXG4gKiBTZXQgdGhlIEcgbGV2ZWwgb2YgdGhlIHRlcm1pbmFsXG4gKiBAcGFyYW0gZ1xuICovXG5UZXJtaW5hbC5wcm90b3R5cGUuc2V0Z0xldmVsID0gZnVuY3Rpb24gKGcpIHtcbiAgICB0aGlzLmdsZXZlbCA9IGc7XG4gICAgdGhpcy5jaGFyc2V0ID0gdGhpcy5jaGFyc2V0c1tnXTtcbn07XG4vKipcbiAqIFNldCB0aGUgY2hhcnNldCBmb3IgdGhlIGdpdmVuIEcgbGV2ZWwgb2YgdGhlIHRlcm1pbmFsXG4gKiBAcGFyYW0gZ1xuICogQHBhcmFtIGNoYXJzZXRcbiAqL1xuVGVybWluYWwucHJvdG90eXBlLnNldGdDaGFyc2V0ID0gZnVuY3Rpb24gKGcsIGNoYXJzZXQpIHtcbiAgICB0aGlzLmNoYXJzZXRzW2ddID0gY2hhcnNldDtcbiAgICBpZiAodGhpcy5nbGV2ZWwgPT09IGcpIHtcbiAgICAgICAgdGhpcy5jaGFyc2V0ID0gY2hhcnNldDtcbiAgICB9XG59O1xuLyoqXG4gKiBIYW5kbGUgYSBrZXlwcmVzcyBldmVudC5cbiAqIEtleSBSZXNvdXJjZXM6XG4gKiAgIC0gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9ET00vS2V5Ym9hcmRFdmVudFxuICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldiBUaGUga2V5cHJlc3MgZXZlbnQgdG8gYmUgaGFuZGxlZC5cbiAqL1xuVGVybWluYWwucHJvdG90eXBlLmtleVByZXNzID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgdmFyIGtleTtcbiAgICB0aGlzLmNhbmNlbChldik7XG4gICAgaWYgKGV2LmNoYXJDb2RlKSB7XG4gICAgICAgIGtleSA9IGV2LmNoYXJDb2RlO1xuICAgIH1cbiAgICBlbHNlIGlmIChldi53aGljaCA9PSBudWxsKSB7XG4gICAgICAgIGtleSA9IGV2LmtleUNvZGU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV2LndoaWNoICE9PSAwICYmIGV2LmNoYXJDb2RlICE9PSAwKSB7XG4gICAgICAgIGtleSA9IGV2LndoaWNoO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWtleSB8fCAoKGV2LmFsdEtleSB8fCBldi5jdHJsS2V5IHx8IGV2Lm1ldGFLZXkpICYmICFpc1RoaXJkTGV2ZWxTaGlmdCh0aGlzLCBldikpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAga2V5ID0gU3RyaW5nLmZyb21DaGFyQ29kZShrZXkpO1xuICAgIHRoaXMuZW1pdCgna2V5cHJlc3MnLCBrZXksIGV2KTtcbiAgICB0aGlzLmVtaXQoJ2tleScsIGtleSwgZXYpO1xuICAgIHRoaXMuc2hvd0N1cnNvcigpO1xuICAgIHRoaXMuaGFuZGxlcihrZXkpO1xuICAgIHJldHVybiBmYWxzZTtcbn07XG4vKipcbiAqIFNlbmQgZGF0YSBmb3IgaGFuZGxpbmcgdG8gdGhlIHRlcm1pbmFsXG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0YVxuICovXG5UZXJtaW5hbC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmICghdGhpcy5xdWV1ZSkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNlbGYuaGFuZGxlcihzZWxmLnF1ZXVlKTtcbiAgICAgICAgICAgIHNlbGYucXVldWUgPSAnJztcbiAgICAgICAgfSwgMSk7XG4gICAgfVxuICAgIHRoaXMucXVldWUgKz0gZGF0YTtcbn07XG4vKipcbiAqIFJpbmcgdGhlIGJlbGwuXG4gKiBOb3RlOiBXZSBjb3VsZCBkbyBzd2VldCB0aGluZ3Mgd2l0aCB3ZWJhdWRpbyBoZXJlXG4gKi9cblRlcm1pbmFsLnByb3RvdHlwZS5iZWxsID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy52aXN1YWxCZWxsKVxuICAgICAgICByZXR1cm47XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuZWxlbWVudC5zdHlsZS5ib3JkZXJDb2xvciA9ICd3aGl0ZSc7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuZWxlbWVudC5zdHlsZS5ib3JkZXJDb2xvciA9ICcnO1xuICAgIH0sIDEwKTtcbiAgICBpZiAodGhpcy5wb3BPbkJlbGwpXG4gICAgICAgIHRoaXMuZm9jdXMoKTtcbn07XG4vKipcbiAqIExvZyB0aGUgY3VycmVudCBzdGF0ZSB0byB0aGUgY29uc29sZS5cbiAqL1xuVGVybWluYWwucHJvdG90eXBlLmxvZyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuZGVidWcpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoIXRoaXMuY29udGV4dC5jb25zb2xlIHx8ICF0aGlzLmNvbnRleHQuY29uc29sZS5sb2cpXG4gICAgICAgIHJldHVybjtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgdGhpcy5jb250ZXh0LmNvbnNvbGUubG9nLmFwcGx5KHRoaXMuY29udGV4dC5jb25zb2xlLCBhcmdzKTtcbn07XG4vKipcbiAqIExvZyB0aGUgY3VycmVudCBzdGF0ZSBhcyBlcnJvciB0byB0aGUgY29uc29sZS5cbiAqL1xuVGVybWluYWwucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5kZWJ1ZylcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICghdGhpcy5jb250ZXh0LmNvbnNvbGUgfHwgIXRoaXMuY29udGV4dC5jb25zb2xlLmVycm9yKVxuICAgICAgICByZXR1cm47XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIHRoaXMuY29udGV4dC5jb25zb2xlLmVycm9yLmFwcGx5KHRoaXMuY29udGV4dC5jb25zb2xlLCBhcmdzKTtcbn07XG4vKipcbiAqIFJlc2l6ZXMgdGhlIHRlcm1pbmFsLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFRoZSBudW1iZXIgb2YgY29sdW1ucyB0byByZXNpemUgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0geSBUaGUgbnVtYmVyIG9mIHJvd3MgdG8gcmVzaXplIHRvLlxuICovXG5UZXJtaW5hbC5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICB2YXIgbGluZSwgZWwsIGksIGosIGNoLCBhZGRUb1k7XG4gICAgaWYgKHggPT09IHRoaXMuY29scyAmJiB5ID09PSB0aGlzLnJvd3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoeCA8IDEpXG4gICAgICAgIHggPSAxO1xuICAgIGlmICh5IDwgMSlcbiAgICAgICAgeSA9IDE7XG4gICAgLy8gcmVzaXplIGNvbHNcbiAgICBqID0gdGhpcy5jb2xzO1xuICAgIGlmIChqIDwgeCkge1xuICAgICAgICBjaCA9IFt0aGlzLmRlZkF0dHIsICcgJywgMV07IC8vIGRvZXMgeHRlcm0gdXNlIHRoZSBkZWZhdWx0IGF0dHI/XG4gICAgICAgIGkgPSB0aGlzLmxpbmVzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMubGluZXNbaV0ubGVuZ3RoIDwgeCkge1xuICAgICAgICAgICAgICAgIHRoaXMubGluZXNbaV0ucHVzaChjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGkgPSB0aGlzLmxpbmVzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMubGluZXNbaV0ubGVuZ3RoID4geCkge1xuICAgICAgICAgICAgICAgIHRoaXMubGluZXNbaV0ucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5zZXR1cFN0b3BzKGopO1xuICAgIHRoaXMuY29scyA9IHg7XG4gICAgLy8gcmVzaXplIHJvd3NcbiAgICBqID0gdGhpcy5yb3dzO1xuICAgIGFkZFRvWSA9IDA7XG4gICAgaWYgKGogPCB5KSB7XG4gICAgICAgIGVsID0gdGhpcy5lbGVtZW50O1xuICAgICAgICB3aGlsZSAoaisrIDwgeSkge1xuICAgICAgICAgICAgLy8geSBpcyByb3dzLCBub3QgdGhpcy55XG4gICAgICAgICAgICBpZiAodGhpcy5saW5lcy5sZW5ndGggPCB5ICsgdGhpcy55YmFzZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnliYXNlID4gMCAmJiB0aGlzLmxpbmVzLmxlbmd0aCA8PSB0aGlzLnliYXNlICsgdGhpcy55ICsgYWRkVG9ZICsgMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGVyZSBpcyByb29tIGFib3ZlIHRoZSBidWZmZXIgYW5kIHRoZXJlIGFyZSBubyBlbXB0eSBlbGVtZW50cyBiZWxvdyB0aGUgbGluZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gc2Nyb2xsIHVwXG4gICAgICAgICAgICAgICAgICAgIHRoaXMueWJhc2UtLTtcbiAgICAgICAgICAgICAgICAgICAgYWRkVG9ZKys7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnlkaXNwID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVmlld3BvcnQgaXMgYXQgdGhlIHRvcCBvZiB0aGUgYnVmZmVyLCBtdXN0IGluY3JlYXNlIGRvd253YXJkc1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy55ZGlzcC0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgYSBibGFuayBsaW5lIGlmIHRoZXJlIGlzIG5vIGJ1ZmZlciBsZWZ0IGF0IHRoZSB0b3AgdG8gc2Nyb2xsIHRvLCBvciBpZiB0aGVyZVxuICAgICAgICAgICAgICAgICAgICAvLyBhcmUgYmxhbmsgbGluZXMgYWZ0ZXIgdGhlIGN1cnNvclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmVzLnB1c2godGhpcy5ibGFua0xpbmUoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoIDwgeSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5zZXJ0Um93KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHdoaWxlIChqLS0gPiB5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5saW5lcy5sZW5ndGggPiB5ICsgdGhpcy55YmFzZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxpbmVzLmxlbmd0aCA+IHRoaXMueWJhc2UgKyB0aGlzLnkgKyAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBsaW5lIGlzIGEgYmxhbmsgbGluZSBiZWxvdyB0aGUgY3Vyc29yLCByZW1vdmUgaXRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5lcy5wb3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBsaW5lIGlzIHRoZSBjdXJzb3IsIHNjcm9sbCBkb3duXG4gICAgICAgICAgICAgICAgICAgIHRoaXMueWJhc2UrKztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy55ZGlzcCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA+IHkpIHtcbiAgICAgICAgICAgICAgICBlbCA9IHRoaXMuY2hpbGRyZW4uc2hpZnQoKTtcbiAgICAgICAgICAgICAgICBpZiAoIWVsKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnJvd3MgPSB5O1xuICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBjdXJzb3Igc3RheXMgb24gc2NyZWVuXG4gICAgaWYgKHRoaXMueSA+PSB5KSB7XG4gICAgICAgIHRoaXMueSA9IHkgLSAxO1xuICAgIH1cbiAgICBpZiAoYWRkVG9ZKSB7XG4gICAgICAgIHRoaXMueSArPSBhZGRUb1k7XG4gICAgfVxuICAgIGlmICh0aGlzLnggPj0geCkge1xuICAgICAgICB0aGlzLnggPSB4IC0gMTtcbiAgICB9XG4gICAgdGhpcy5zY3JvbGxUb3AgPSAwO1xuICAgIHRoaXMuc2Nyb2xsQm90dG9tID0geSAtIDE7XG4gICAgdGhpcy5yZWZyZXNoKDAsIHRoaXMucm93cyAtIDEpO1xuICAgIHRoaXMubm9ybWFsID0gbnVsbDtcbiAgICB0aGlzLmdlb21ldHJ5ID0gW3RoaXMuY29scywgdGhpcy5yb3dzXTtcbiAgICB0aGlzLmVtaXQoJ3Jlc2l6ZScsIHsgdGVybWluYWw6IHRoaXMsIGNvbHM6IHgsIHJvd3M6IHkgfSk7XG59O1xuLyoqXG4gKiBVcGRhdGVzIHRoZSByYW5nZSBvZiByb3dzIHRvIHJlZnJlc2hcbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFRoZSBudW1iZXIgb2Ygcm93cyB0byByZWZyZXNoIG5leHQuXG4gKi9cblRlcm1pbmFsLnByb3RvdHlwZS51cGRhdGVSYW5nZSA9IGZ1bmN0aW9uICh5KSB7XG4gICAgaWYgKHkgPCB0aGlzLnJlZnJlc2hTdGFydClcbiAgICAgICAgdGhpcy5yZWZyZXNoU3RhcnQgPSB5O1xuICAgIGlmICh5ID4gdGhpcy5yZWZyZXNoRW5kKVxuICAgICAgICB0aGlzLnJlZnJlc2hFbmQgPSB5O1xuICAgIC8vIGlmICh5ID4gdGhpcy5yZWZyZXNoRW5kKSB7XG4gICAgLy8gICB0aGlzLnJlZnJlc2hFbmQgPSB5O1xuICAgIC8vICAgaWYgKHkgPiB0aGlzLnJvd3MgLSAxKSB7XG4gICAgLy8gICAgIHRoaXMucmVmcmVzaEVuZCA9IHRoaXMucm93cyAtIDE7XG4gICAgLy8gICB9XG4gICAgLy8gfVxufTtcbi8qKlxuICogU2V0IHRoZSByYW5nZSBvZiByZWZyZXNoaW5nIHRvIHRoZSBtYXhpbXVtIHZhbHVlXG4gKi9cblRlcm1pbmFsLnByb3RvdHlwZS5tYXhSYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJlZnJlc2hTdGFydCA9IDA7XG4gICAgdGhpcy5yZWZyZXNoRW5kID0gdGhpcy5yb3dzIC0gMTtcbn07XG4vKipcbiAqIFNldHVwIHRoZSB0YWIgc3RvcHMuXG4gKiBAcGFyYW0ge251bWJlcn0gaVxuICovXG5UZXJtaW5hbC5wcm90b3R5cGUuc2V0dXBTdG9wcyA9IGZ1bmN0aW9uIChpKSB7XG4gICAgaWYgKGkgIT0gbnVsbCkge1xuICAgICAgICBpZiAoIXRoaXMudGFic1tpXSkge1xuICAgICAgICAgICAgaSA9IHRoaXMucHJldlN0b3AoaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRoaXMudGFicyA9IHt9O1xuICAgICAgICBpID0gMDtcbiAgICB9XG4gICAgZm9yICg7IGkgPCB0aGlzLmNvbHM7IGkgKz0gOCkge1xuICAgICAgICB0aGlzLnRhYnNbaV0gPSB0cnVlO1xuICAgIH1cbn07XG4vKipcbiAqIE1vdmUgdGhlIGN1cnNvciB0byB0aGUgcHJldmlvdXMgdGFiIHN0b3AgZnJvbSB0aGUgZ2l2ZW4gcG9zaXRpb24gKGRlZmF1bHQgaXMgY3VycmVudCkuXG4gKiBAcGFyYW0ge251bWJlcn0geCBUaGUgcG9zaXRpb24gdG8gbW92ZSB0aGUgY3Vyc29yIHRvIHRoZSBwcmV2aW91cyB0YWIgc3RvcC5cbiAqL1xuVGVybWluYWwucHJvdG90eXBlLnByZXZTdG9wID0gZnVuY3Rpb24gKHgpIHtcbiAgICBpZiAoeCA9PSBudWxsKVxuICAgICAgICB4ID0gdGhpcy54O1xuICAgIHdoaWxlICghdGhpcy50YWJzWy0teF0gJiYgeCA+IDApXG4gICAgICAgIDtcbiAgICByZXR1cm4geCA+PSB0aGlzLmNvbHNcbiAgICAgICAgPyB0aGlzLmNvbHMgLSAxXG4gICAgICAgIDogeCA8IDAgPyAwIDogeDtcbn07XG4vKipcbiAqIE1vdmUgdGhlIGN1cnNvciBvbmUgdGFiIHN0b3AgZm9yd2FyZCBmcm9tIHRoZSBnaXZlbiBwb3NpdGlvbiAoZGVmYXVsdCBpcyBjdXJyZW50KS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFRoZSBwb3NpdGlvbiB0byBtb3ZlIHRoZSBjdXJzb3Igb25lIHRhYiBzdG9wIGZvcndhcmQuXG4gKi9cblRlcm1pbmFsLnByb3RvdHlwZS5uZXh0U3RvcCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgaWYgKHggPT0gbnVsbClcbiAgICAgICAgeCA9IHRoaXMueDtcbiAgICB3aGlsZSAoIXRoaXMudGFic1srK3hdICYmIHggPCB0aGlzLmNvbHMpXG4gICAgICAgIDtcbiAgICByZXR1cm4geCA+PSB0aGlzLmNvbHNcbiAgICAgICAgPyB0aGlzLmNvbHMgLSAxXG4gICAgICAgIDogeCA8IDAgPyAwIDogeDtcbn07XG4vKipcbiAqIEVyYXNlIGluIHRoZSBpZGVudGlmaWVkIGxpbmUgZXZlcnl0aGluZyBmcm9tIFwieFwiIHRvIHRoZSBlbmQgb2YgdGhlIGxpbmUgKHJpZ2h0KS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFRoZSBjb2x1bW4gZnJvbSB3aGljaCB0byBzdGFydCBlcmFzaW5nIHRvIHRoZSBlbmQgb2YgdGhlIGxpbmUuXG4gKiBAcGFyYW0ge251bWJlcn0geSBUaGUgbGluZSBpbiB3aGljaCB0byBvcGVyYXRlLlxuICovXG5UZXJtaW5hbC5wcm90b3R5cGUuZXJhc2VSaWdodCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgdmFyIGxpbmUgPSB0aGlzLmxpbmVzW3RoaXMueWJhc2UgKyB5XSwgY2ggPSBbdGhpcy5lcmFzZUF0dHIoKSwgJyAnLCAxXTsgLy8geHRlcm1cbiAgICBmb3IgKDsgeCA8IHRoaXMuY29sczsgeCsrKSB7XG4gICAgICAgIGxpbmVbeF0gPSBjaDtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVSYW5nZSh5KTtcbn07XG4vKipcbiAqIEVyYXNlIGluIHRoZSBpZGVudGlmaWVkIGxpbmUgZXZlcnl0aGluZyBmcm9tIFwieFwiIHRvIHRoZSBzdGFydCBvZiB0aGUgbGluZSAobGVmdCkuXG4gKiBAcGFyYW0ge251bWJlcn0geCBUaGUgY29sdW1uIGZyb20gd2hpY2ggdG8gc3RhcnQgZXJhc2luZyB0byB0aGUgc3RhcnQgb2YgdGhlIGxpbmUuXG4gKiBAcGFyYW0ge251bWJlcn0geSBUaGUgbGluZSBpbiB3aGljaCB0byBvcGVyYXRlLlxuICovXG5UZXJtaW5hbC5wcm90b3R5cGUuZXJhc2VMZWZ0ID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICB2YXIgbGluZSA9IHRoaXMubGluZXNbdGhpcy55YmFzZSArIHldLCBjaCA9IFt0aGlzLmVyYXNlQXR0cigpLCAnICcsIDFdOyAvLyB4dGVybVxuICAgIHgrKztcbiAgICB3aGlsZSAoeC0tKVxuICAgICAgICBsaW5lW3hdID0gY2g7XG4gICAgdGhpcy51cGRhdGVSYW5nZSh5KTtcbn07XG4vKipcbiAqIENsZWFycyB0aGUgZW50aXJlIGJ1ZmZlciwgbWFraW5nIHRoZSBwcm9tcHQgbGluZSB0aGUgbmV3IGZpcnN0IGxpbmUuXG4gKi9cblRlcm1pbmFsLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy55YmFzZSA9PT0gMCAmJiB0aGlzLnkgPT09IDApIHtcbiAgICAgICAgLy8gRG9uJ3QgY2xlYXIgaWYgaXQncyBhbHJlYWR5IGNsZWFyXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5saW5lcyA9IFt0aGlzLmxpbmVzW3RoaXMueWJhc2UgKyB0aGlzLnldXTtcbiAgICB0aGlzLnlkaXNwID0gMDtcbiAgICB0aGlzLnliYXNlID0gMDtcbiAgICB0aGlzLnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgICAgdGhpcy5saW5lcy5wdXNoKHRoaXMuYmxhbmtMaW5lKCkpO1xuICAgIH1cbiAgICB0aGlzLnJlZnJlc2goMCwgdGhpcy5yb3dzIC0gMSk7XG4gICAgdGhpcy5lbWl0KCdzY3JvbGwnLCB0aGlzLnlkaXNwKTtcbn07XG4vKipcbiAqIEVyYXNlIGFsbCBjb250ZW50IGluIHRoZSBnaXZlbiBsaW5lXG4gKiBAcGFyYW0ge251bWJlcn0geSBUaGUgbGluZSB0byBlcmFzZSBhbGwgb2YgaXRzIGNvbnRlbnRzLlxuICovXG5UZXJtaW5hbC5wcm90b3R5cGUuZXJhc2VMaW5lID0gZnVuY3Rpb24gKHkpIHtcbiAgICB0aGlzLmVyYXNlUmlnaHQoMCwgeSk7XG59O1xuLyoqXG4gKiBSZXR1cm4gdGhlIGRhdGEgYXJyYXkgb2YgYSBibGFuayBsaW5lL1xuICogQHBhcmFtIHtudW1iZXJ9IGN1ciBGaXJzdCBidW5jaCBvZiBkYXRhIGZvciBlYWNoIFwiYmxhbmtcIiBjaGFyYWN0ZXIuXG4gKi9cblRlcm1pbmFsLnByb3RvdHlwZS5ibGFua0xpbmUgPSBmdW5jdGlvbiAoY3VyKSB7XG4gICAgdmFyIGF0dHIgPSBjdXJcbiAgICAgICAgPyB0aGlzLmVyYXNlQXR0cigpXG4gICAgICAgIDogdGhpcy5kZWZBdHRyO1xuICAgIHZhciBjaCA9IFthdHRyLCAnICcsIDFdIC8vIHdpZHRoIGRlZmF1bHRzIHRvIDEgaGFsZndpZHRoIGNoYXJhY3RlclxuICAgICwgbGluZSA9IFtdLCBpID0gMDtcbiAgICBmb3IgKDsgaSA8IHRoaXMuY29sczsgaSsrKSB7XG4gICAgICAgIGxpbmVbaV0gPSBjaDtcbiAgICB9XG4gICAgcmV0dXJuIGxpbmU7XG59O1xuLyoqXG4gKiBJZiBjdXIgcmV0dXJuIHRoZSBiYWNrIGNvbG9yIHh0ZXJtIGZlYXR1cmUgYXR0cmlidXRlLiBFbHNlIHJldHVybiBkZWZBdHRyLlxuICogQHBhcmFtIHtvYmplY3R9IGN1clxuICovXG5UZXJtaW5hbC5wcm90b3R5cGUuY2ggPSBmdW5jdGlvbiAoY3VyKSB7XG4gICAgcmV0dXJuIGN1clxuICAgICAgICA/IFt0aGlzLmVyYXNlQXR0cigpLCAnICcsIDFdXG4gICAgICAgIDogW3RoaXMuZGVmQXR0ciwgJyAnLCAxXTtcbn07XG4vKipcbiAqIEV2YWx1YXRlIGlmIHRoZSBjdXJyZW50IGVybWluYWwgaXMgdGhlIGdpdmVuIGFyZ3VtZW50LlxuICogQHBhcmFtIHtvYmplY3R9IHRlcm0gVGhlIHRlcm1pbmFsIHRvIGV2YWx1YXRlXG4gKi9cblRlcm1pbmFsLnByb3RvdHlwZS5pcyA9IGZ1bmN0aW9uICh0ZXJtKSB7XG4gICAgdmFyIG5hbWUgPSB0aGlzLnRlcm1OYW1lO1xuICAgIHJldHVybiAobmFtZSArICcnKS5pbmRleE9mKHRlcm0pID09PSAwO1xufTtcbi8qKlxuICogRW1pdCB0aGUgJ2RhdGEnIGV2ZW50IGFuZCBwb3B1bGF0ZSB0aGUgZ2l2ZW4gZGF0YS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhIFRoZSBkYXRhIHRvIHBvcHVsYXRlIGluIHRoZSBldmVudC5cbiAqL1xuVGVybWluYWwucHJvdG90eXBlLmhhbmRsZXIgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIC8vIElucHV0IGlzIGJlaW5nIHNlbnQgdG8gdGhlIHRlcm1pbmFsLCB0aGUgdGVybWluYWwgc2hvdWxkIGZvY3VzIHRoZSBwcm9tcHQuXG4gICAgaWYgKHRoaXMueWJhc2UgIT09IHRoaXMueWRpc3ApIHtcbiAgICAgICAgdGhpcy5zY3JvbGxUb0JvdHRvbSgpO1xuICAgIH1cbiAgICB0aGlzLmVtaXQoJ2RhdGEnLCBkYXRhKTtcbn07XG4vKipcbiAqIEVtaXQgdGhlICd0aXRsZScgZXZlbnQgYW5kIHBvcHVsYXRlIHRoZSBnaXZlbiB0aXRsZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0aXRsZSBUaGUgdGl0bGUgdG8gcG9wdWxhdGUgaW4gdGhlIGV2ZW50LlxuICovXG5UZXJtaW5hbC5wcm90b3R5cGUuaGFuZGxlVGl0bGUgPSBmdW5jdGlvbiAodGl0bGUpIHtcbiAgICAvKipcbiAgICAgKiBUaGlzIGV2ZW50IGlzIGVtaXR0ZWQgd2hlbiB0aGUgdGl0bGUgb2YgdGhlIHRlcm1pbmFsIGlzIGNoYW5nZWRcbiAgICAgKiBmcm9tIGluc2lkZSB0aGUgdGVybWluYWwuIFRoZSBwYXJhbWV0ZXIgaXMgdGhlIG5ldyB0aXRsZS5cbiAgICAgKlxuICAgICAqIEBldmVudCB0aXRsZVxuICAgICAqL1xuICAgIHRoaXMuZW1pdCgndGl0bGUnLCB0aXRsZSk7XG59O1xuLyoqXG4gKiBFU0NcbiAqL1xuLyoqXG4gKiBFU0MgRCBJbmRleCAoSU5EIGlzIDB4ODQpLlxuICovXG5UZXJtaW5hbC5wcm90b3R5cGUuaW5kZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy55Kys7XG4gICAgaWYgKHRoaXMueSA+IHRoaXMuc2Nyb2xsQm90dG9tKSB7XG4gICAgICAgIHRoaXMueS0tO1xuICAgICAgICB0aGlzLnNjcm9sbCgpO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlID0gbm9ybWFsO1xufTtcbi8qKlxuICogRVNDIE0gUmV2ZXJzZSBJbmRleCAoUkkgaXMgMHg4ZCkuXG4gKi9cblRlcm1pbmFsLnByb3RvdHlwZS5yZXZlcnNlSW5kZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGo7XG4gICAgdGhpcy55LS07XG4gICAgaWYgKHRoaXMueSA8IHRoaXMuc2Nyb2xsVG9wKSB7XG4gICAgICAgIHRoaXMueSsrO1xuICAgICAgICAvLyBwb3NzaWJseSBtb3ZlIHRoZSBjb2RlIGJlbG93IHRvIHRlcm0ucmV2ZXJzZVNjcm9sbCgpO1xuICAgICAgICAvLyB0ZXN0OiBlY2hvIC1uZSAnXFxlWzE7MUhcXGVbNDRtXFxlTVxcZVswbSdcbiAgICAgICAgLy8gYmxhbmtMaW5lKHRydWUpIGlzIHh0ZXJtL2xpbnV4IGJlaGF2aW9yXG4gICAgICAgIHRoaXMubGluZXMuc3BsaWNlKHRoaXMueSArIHRoaXMueWJhc2UsIDAsIHRoaXMuYmxhbmtMaW5lKHRydWUpKTtcbiAgICAgICAgaiA9IHRoaXMucm93cyAtIDEgLSB0aGlzLnNjcm9sbEJvdHRvbTtcbiAgICAgICAgdGhpcy5saW5lcy5zcGxpY2UodGhpcy5yb3dzIC0gMSArIHRoaXMueWJhc2UgLSBqICsgMSwgMSk7XG4gICAgICAgIC8vIHRoaXMubWF4UmFuZ2UoKTtcbiAgICAgICAgdGhpcy51cGRhdGVSYW5nZSh0aGlzLnNjcm9sbFRvcCk7XG4gICAgICAgIHRoaXMudXBkYXRlUmFuZ2UodGhpcy5zY3JvbGxCb3R0b20pO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlID0gbm9ybWFsO1xufTtcbi8qKlxuICogRVNDIGMgRnVsbCBSZXNldCAoUklTKS5cbiAqL1xuVGVybWluYWwucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMub3B0aW9ucy5yb3dzID0gdGhpcy5yb3dzO1xuICAgIHRoaXMub3B0aW9ucy5jb2xzID0gdGhpcy5jb2xzO1xuICAgIHZhciBjdXN0b21LZXlkb3duSGFuZGxlciA9IHRoaXMuY3VzdG9tS2V5ZG93bkhhbmRsZXI7XG4gICAgVGVybWluYWwuY2FsbCh0aGlzLCB0aGlzLm9wdGlvbnMpO1xuICAgIHRoaXMuY3VzdG9tS2V5ZG93bkhhbmRsZXIgPSBjdXN0b21LZXlkb3duSGFuZGxlcjtcbiAgICB0aGlzLnJlZnJlc2goMCwgdGhpcy5yb3dzIC0gMSk7XG4gICAgdGhpcy52aWV3cG9ydC5zeW5jU2Nyb2xsQXJlYSgpO1xufTtcbi8qKlxuICogRVNDIEggVGFiIFNldCAoSFRTIGlzIDB4ODgpLlxuICovXG5UZXJtaW5hbC5wcm90b3R5cGUudGFiU2V0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMudGFic1t0aGlzLnhdID0gdHJ1ZTtcbiAgICB0aGlzLnN0YXRlID0gbm9ybWFsO1xufTtcbi8qKlxuICogQ1NJXG4gKi9cbi8qKlxuICogQ1NJIFBzIEFcbiAqIEN1cnNvciBVcCBQcyBUaW1lcyAoZGVmYXVsdCA9IDEpIChDVVUpLlxuICovXG5UZXJtaW5hbC5wcm90b3R5cGUuY3Vyc29yVXAgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgdmFyIHBhcmFtID0gcGFyYW1zWzBdO1xuICAgIGlmIChwYXJhbSA8IDEpXG4gICAgICAgIHBhcmFtID0gMTtcbiAgICB0aGlzLnkgLT0gcGFyYW07XG4gICAgaWYgKHRoaXMueSA8IDApXG4gICAgICAgIHRoaXMueSA9IDA7XG59O1xuLyoqXG4gKiBDU0kgUHMgQlxuICogQ3Vyc29yIERvd24gUHMgVGltZXMgKGRlZmF1bHQgPSAxKSAoQ1VEKS5cbiAqL1xuVGVybWluYWwucHJvdG90eXBlLmN1cnNvckRvd24gPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgdmFyIHBhcmFtID0gcGFyYW1zWzBdO1xuICAgIGlmIChwYXJhbSA8IDEpXG4gICAgICAgIHBhcmFtID0gMTtcbiAgICB0aGlzLnkgKz0gcGFyYW07XG4gICAgaWYgKHRoaXMueSA+PSB0aGlzLnJvd3MpIHtcbiAgICAgICAgdGhpcy55ID0gdGhpcy5yb3dzIC0gMTtcbiAgICB9XG59O1xuLyoqXG4gKiBDU0kgUHMgQ1xuICogQ3Vyc29yIEZvcndhcmQgUHMgVGltZXMgKGRlZmF1bHQgPSAxKSAoQ1VGKS5cbiAqL1xuVGVybWluYWwucHJvdG90eXBlLmN1cnNvckZvcndhcmQgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgdmFyIHBhcmFtID0gcGFyYW1zWzBdO1xuICAgIGlmIChwYXJhbSA8IDEpXG4gICAgICAgIHBhcmFtID0gMTtcbiAgICB0aGlzLnggKz0gcGFyYW07XG4gICAgaWYgKHRoaXMueCA+PSB0aGlzLmNvbHMpIHtcbiAgICAgICAgdGhpcy54ID0gdGhpcy5jb2xzIC0gMTtcbiAgICB9XG59O1xuLyoqXG4gKiBDU0kgUHMgRFxuICogQ3Vyc29yIEJhY2t3YXJkIFBzIFRpbWVzIChkZWZhdWx0ID0gMSkgKENVQikuXG4gKi9cblRlcm1pbmFsLnByb3RvdHlwZS5jdXJzb3JCYWNrd2FyZCA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICB2YXIgcGFyYW0gPSBwYXJhbXNbMF07XG4gICAgaWYgKHBhcmFtIDwgMSlcbiAgICAgICAgcGFyYW0gPSAxO1xuICAgIHRoaXMueCAtPSBwYXJhbTtcbiAgICBpZiAodGhpcy54IDwgMClcbiAgICAgICAgdGhpcy54ID0gMDtcbn07XG4vKipcbiAqIENTSSBQcyA7IFBzIEhcbiAqIEN1cnNvciBQb3NpdGlvbiBbcm93O2NvbHVtbl0gKGRlZmF1bHQgPSBbMSwxXSkgKENVUCkuXG4gKi9cblRlcm1pbmFsLnByb3RvdHlwZS5jdXJzb3JQb3MgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgdmFyIHJvdywgY29sO1xuICAgIHJvdyA9IHBhcmFtc1swXSAtIDE7XG4gICAgaWYgKHBhcmFtcy5sZW5ndGggPj0gMikge1xuICAgICAgICBjb2wgPSBwYXJhbXNbMV0gLSAxO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29sID0gMDtcbiAgICB9XG4gICAgaWYgKHJvdyA8IDApIHtcbiAgICAgICAgcm93ID0gMDtcbiAgICB9XG4gICAgZWxzZSBpZiAocm93ID49IHRoaXMucm93cykge1xuICAgICAgICByb3cgPSB0aGlzLnJvd3MgLSAxO1xuICAgIH1cbiAgICBpZiAoY29sIDwgMCkge1xuICAgICAgICBjb2wgPSAwO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb2wgPj0gdGhpcy5jb2xzKSB7XG4gICAgICAgIGNvbCA9IHRoaXMuY29scyAtIDE7XG4gICAgfVxuICAgIHRoaXMueCA9IGNvbDtcbiAgICB0aGlzLnkgPSByb3c7XG59O1xuLyoqXG4gKiBDU0kgUHMgSiAgRXJhc2UgaW4gRGlzcGxheSAoRUQpLlxuICogICAgIFBzID0gMCAgLT4gRXJhc2UgQmVsb3cgKGRlZmF1bHQpLlxuICogICAgIFBzID0gMSAgLT4gRXJhc2UgQWJvdmUuXG4gKiAgICAgUHMgPSAyICAtPiBFcmFzZSBBbGwuXG4gKiAgICAgUHMgPSAzICAtPiBFcmFzZSBTYXZlZCBMaW5lcyAoeHRlcm0pLlxuICogQ1NJID8gUHMgSlxuICogICBFcmFzZSBpbiBEaXNwbGF5IChERUNTRUQpLlxuICogICAgIFBzID0gMCAgLT4gU2VsZWN0aXZlIEVyYXNlIEJlbG93IChkZWZhdWx0KS5cbiAqICAgICBQcyA9IDEgIC0+IFNlbGVjdGl2ZSBFcmFzZSBBYm92ZS5cbiAqICAgICBQcyA9IDIgIC0+IFNlbGVjdGl2ZSBFcmFzZSBBbGwuXG4gKi9cblRlcm1pbmFsLnByb3RvdHlwZS5lcmFzZUluRGlzcGxheSA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICB2YXIgajtcbiAgICBzd2l0Y2ggKHBhcmFtc1swXSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICB0aGlzLmVyYXNlUmlnaHQodGhpcy54LCB0aGlzLnkpO1xuICAgICAgICAgICAgaiA9IHRoaXMueSArIDE7XG4gICAgICAgICAgICBmb3IgKDsgaiA8IHRoaXMucm93czsgaisrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcmFzZUxpbmUoaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgdGhpcy5lcmFzZUxlZnQodGhpcy54LCB0aGlzLnkpO1xuICAgICAgICAgICAgaiA9IHRoaXMueTtcbiAgICAgICAgICAgIHdoaWxlIChqLS0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVyYXNlTGluZShqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBqID0gdGhpcy5yb3dzO1xuICAgICAgICAgICAgd2hpbGUgKGotLSlcbiAgICAgICAgICAgICAgICB0aGlzLmVyYXNlTGluZShqKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICA7IC8vIG5vIHNhdmVkIGxpbmVzXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG59O1xuLyoqXG4gKiBDU0kgUHMgSyAgRXJhc2UgaW4gTGluZSAoRUwpLlxuICogICAgIFBzID0gMCAgLT4gRXJhc2UgdG8gUmlnaHQgKGRlZmF1bHQpLlxuICogICAgIFBzID0gMSAgLT4gRXJhc2UgdG8gTGVmdC5cbiAqICAgICBQcyA9IDIgIC0+IEVyYXNlIEFsbC5cbiAqIENTSSA/IFBzIEtcbiAqICAgRXJhc2UgaW4gTGluZSAoREVDU0VMKS5cbiAqICAgICBQcyA9IDAgIC0+IFNlbGVjdGl2ZSBFcmFzZSB0byBSaWdodCAoZGVmYXVsdCkuXG4gKiAgICAgUHMgPSAxICAtPiBTZWxlY3RpdmUgRXJhc2UgdG8gTGVmdC5cbiAqICAgICBQcyA9IDIgIC0+IFNlbGVjdGl2ZSBFcmFzZSBBbGwuXG4gKi9cblRlcm1pbmFsLnByb3RvdHlwZS5lcmFzZUluTGluZSA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICBzd2l0Y2ggKHBhcmFtc1swXSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICB0aGlzLmVyYXNlUmlnaHQodGhpcy54LCB0aGlzLnkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHRoaXMuZXJhc2VMZWZ0KHRoaXMueCwgdGhpcy55KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICB0aGlzLmVyYXNlTGluZSh0aGlzLnkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxufTtcbi8qKlxuICogQ1NJIFBtIG0gIENoYXJhY3RlciBBdHRyaWJ1dGVzIChTR1IpLlxuICogICAgIFBzID0gMCAgLT4gTm9ybWFsIChkZWZhdWx0KS5cbiAqICAgICBQcyA9IDEgIC0+IEJvbGQuXG4gKiAgICAgUHMgPSA0ICAtPiBVbmRlcmxpbmVkLlxuICogICAgIFBzID0gNSAgLT4gQmxpbmsgKGFwcGVhcnMgYXMgQm9sZCkuXG4gKiAgICAgUHMgPSA3ICAtPiBJbnZlcnNlLlxuICogICAgIFBzID0gOCAgLT4gSW52aXNpYmxlLCBpLmUuLCBoaWRkZW4gKFZUMzAwKS5cbiAqICAgICBQcyA9IDIgMiAgLT4gTm9ybWFsIChuZWl0aGVyIGJvbGQgbm9yIGZhaW50KS5cbiAqICAgICBQcyA9IDIgNCAgLT4gTm90IHVuZGVybGluZWQuXG4gKiAgICAgUHMgPSAyIDUgIC0+IFN0ZWFkeSAobm90IGJsaW5raW5nKS5cbiAqICAgICBQcyA9IDIgNyAgLT4gUG9zaXRpdmUgKG5vdCBpbnZlcnNlKS5cbiAqICAgICBQcyA9IDIgOCAgLT4gVmlzaWJsZSwgaS5lLiwgbm90IGhpZGRlbiAoVlQzMDApLlxuICogICAgIFBzID0gMyAwICAtPiBTZXQgZm9yZWdyb3VuZCBjb2xvciB0byBCbGFjay5cbiAqICAgICBQcyA9IDMgMSAgLT4gU2V0IGZvcmVncm91bmQgY29sb3IgdG8gUmVkLlxuICogICAgIFBzID0gMyAyICAtPiBTZXQgZm9yZWdyb3VuZCBjb2xvciB0byBHcmVlbi5cbiAqICAgICBQcyA9IDMgMyAgLT4gU2V0IGZvcmVncm91bmQgY29sb3IgdG8gWWVsbG93LlxuICogICAgIFBzID0gMyA0ICAtPiBTZXQgZm9yZWdyb3VuZCBjb2xvciB0byBCbHVlLlxuICogICAgIFBzID0gMyA1ICAtPiBTZXQgZm9yZWdyb3VuZCBjb2xvciB0byBNYWdlbnRhLlxuICogICAgIFBzID0gMyA2ICAtPiBTZXQgZm9yZWdyb3VuZCBjb2xvciB0byBDeWFuLlxuICogICAgIFBzID0gMyA3ICAtPiBTZXQgZm9yZWdyb3VuZCBjb2xvciB0byBXaGl0ZS5cbiAqICAgICBQcyA9IDMgOSAgLT4gU2V0IGZvcmVncm91bmQgY29sb3IgdG8gZGVmYXVsdCAob3JpZ2luYWwpLlxuICogICAgIFBzID0gNCAwICAtPiBTZXQgYmFja2dyb3VuZCBjb2xvciB0byBCbGFjay5cbiAqICAgICBQcyA9IDQgMSAgLT4gU2V0IGJhY2tncm91bmQgY29sb3IgdG8gUmVkLlxuICogICAgIFBzID0gNCAyICAtPiBTZXQgYmFja2dyb3VuZCBjb2xvciB0byBHcmVlbi5cbiAqICAgICBQcyA9IDQgMyAgLT4gU2V0IGJhY2tncm91bmQgY29sb3IgdG8gWWVsbG93LlxuICogICAgIFBzID0gNCA0ICAtPiBTZXQgYmFja2dyb3VuZCBjb2xvciB0byBCbHVlLlxuICogICAgIFBzID0gNCA1ICAtPiBTZXQgYmFja2dyb3VuZCBjb2xvciB0byBNYWdlbnRhLlxuICogICAgIFBzID0gNCA2ICAtPiBTZXQgYmFja2dyb3VuZCBjb2xvciB0byBDeWFuLlxuICogICAgIFBzID0gNCA3ICAtPiBTZXQgYmFja2dyb3VuZCBjb2xvciB0byBXaGl0ZS5cbiAqICAgICBQcyA9IDQgOSAgLT4gU2V0IGJhY2tncm91bmQgY29sb3IgdG8gZGVmYXVsdCAob3JpZ2luYWwpLlxuICpcbiAqICAgSWYgMTYtY29sb3Igc3VwcG9ydCBpcyBjb21waWxlZCwgdGhlIGZvbGxvd2luZyBhcHBseS4gIEFzc3VtZVxuICogICB0aGF0IHh0ZXJtJ3MgcmVzb3VyY2VzIGFyZSBzZXQgc28gdGhhdCB0aGUgSVNPIGNvbG9yIGNvZGVzIGFyZVxuICogICB0aGUgZmlyc3QgOCBvZiBhIHNldCBvZiAxNi4gIFRoZW4gdGhlIGFpeHRlcm0gY29sb3JzIGFyZSB0aGVcbiAqICAgYnJpZ2h0IHZlcnNpb25zIG9mIHRoZSBJU08gY29sb3JzOlxuICogICAgIFBzID0gOSAwICAtPiBTZXQgZm9yZWdyb3VuZCBjb2xvciB0byBCbGFjay5cbiAqICAgICBQcyA9IDkgMSAgLT4gU2V0IGZvcmVncm91bmQgY29sb3IgdG8gUmVkLlxuICogICAgIFBzID0gOSAyICAtPiBTZXQgZm9yZWdyb3VuZCBjb2xvciB0byBHcmVlbi5cbiAqICAgICBQcyA9IDkgMyAgLT4gU2V0IGZvcmVncm91bmQgY29sb3IgdG8gWWVsbG93LlxuICogICAgIFBzID0gOSA0ICAtPiBTZXQgZm9yZWdyb3VuZCBjb2xvciB0byBCbHVlLlxuICogICAgIFBzID0gOSA1ICAtPiBTZXQgZm9yZWdyb3VuZCBjb2xvciB0byBNYWdlbnRhLlxuICogICAgIFBzID0gOSA2ICAtPiBTZXQgZm9yZWdyb3VuZCBjb2xvciB0byBDeWFuLlxuICogICAgIFBzID0gOSA3ICAtPiBTZXQgZm9yZWdyb3VuZCBjb2xvciB0byBXaGl0ZS5cbiAqICAgICBQcyA9IDEgMCAwICAtPiBTZXQgYmFja2dyb3VuZCBjb2xvciB0byBCbGFjay5cbiAqICAgICBQcyA9IDEgMCAxICAtPiBTZXQgYmFja2dyb3VuZCBjb2xvciB0byBSZWQuXG4gKiAgICAgUHMgPSAxIDAgMiAgLT4gU2V0IGJhY2tncm91bmQgY29sb3IgdG8gR3JlZW4uXG4gKiAgICAgUHMgPSAxIDAgMyAgLT4gU2V0IGJhY2tncm91bmQgY29sb3IgdG8gWWVsbG93LlxuICogICAgIFBzID0gMSAwIDQgIC0+IFNldCBiYWNrZ3JvdW5kIGNvbG9yIHRvIEJsdWUuXG4gKiAgICAgUHMgPSAxIDAgNSAgLT4gU2V0IGJhY2tncm91bmQgY29sb3IgdG8gTWFnZW50YS5cbiAqICAgICBQcyA9IDEgMCA2ICAtPiBTZXQgYmFja2dyb3VuZCBjb2xvciB0byBDeWFuLlxuICogICAgIFBzID0gMSAwIDcgIC0+IFNldCBiYWNrZ3JvdW5kIGNvbG9yIHRvIFdoaXRlLlxuICpcbiAqICAgSWYgeHRlcm0gaXMgY29tcGlsZWQgd2l0aCB0aGUgMTYtY29sb3Igc3VwcG9ydCBkaXNhYmxlZCwgaXRcbiAqICAgc3VwcG9ydHMgdGhlIGZvbGxvd2luZywgZnJvbSByeHZ0OlxuICogICAgIFBzID0gMSAwIDAgIC0+IFNldCBmb3JlZ3JvdW5kIGFuZCBiYWNrZ3JvdW5kIGNvbG9yIHRvXG4gKiAgICAgZGVmYXVsdC5cbiAqXG4gKiAgIElmIDg4LSBvciAyNTYtY29sb3Igc3VwcG9ydCBpcyBjb21waWxlZCwgdGhlIGZvbGxvd2luZyBhcHBseS5cbiAqICAgICBQcyA9IDMgOCAgOyA1ICA7IFBzIC0+IFNldCBmb3JlZ3JvdW5kIGNvbG9yIHRvIHRoZSBzZWNvbmRcbiAqICAgICBQcy5cbiAqICAgICBQcyA9IDQgOCAgOyA1ICA7IFBzIC0+IFNldCBiYWNrZ3JvdW5kIGNvbG9yIHRvIHRoZSBzZWNvbmRcbiAqICAgICBQcy5cbiAqL1xuVGVybWluYWwucHJvdG90eXBlLmNoYXJBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgIC8vIE9wdGltaXplIGEgc2luZ2xlIFNHUjAuXG4gICAgaWYgKHBhcmFtcy5sZW5ndGggPT09IDEgJiYgcGFyYW1zWzBdID09PSAwKSB7XG4gICAgICAgIHRoaXMuY3VyQXR0ciA9IHRoaXMuZGVmQXR0cjtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbCA9IHBhcmFtcy5sZW5ndGgsIGkgPSAwLCBmbGFncyA9IHRoaXMuY3VyQXR0ciA+PiAxOCwgZmcgPSAodGhpcy5jdXJBdHRyID4+IDkpICYgMHgxZmYsIGJnID0gdGhpcy5jdXJBdHRyICYgMHgxZmYsIHA7XG4gICAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgcCA9IHBhcmFtc1tpXTtcbiAgICAgICAgaWYgKHAgPj0gMzAgJiYgcCA8PSAzNykge1xuICAgICAgICAgICAgLy8gZmcgY29sb3IgOFxuICAgICAgICAgICAgZmcgPSBwIC0gMzA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocCA+PSA0MCAmJiBwIDw9IDQ3KSB7XG4gICAgICAgICAgICAvLyBiZyBjb2xvciA4XG4gICAgICAgICAgICBiZyA9IHAgLSA0MDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwID49IDkwICYmIHAgPD0gOTcpIHtcbiAgICAgICAgICAgIC8vIGZnIGNvbG9yIDE2XG4gICAgICAgICAgICBwICs9IDg7XG4gICAgICAgICAgICBmZyA9IHAgLSA5MDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwID49IDEwMCAmJiBwIDw9IDEwNykge1xuICAgICAgICAgICAgLy8gYmcgY29sb3IgMTZcbiAgICAgICAgICAgIHAgKz0gODtcbiAgICAgICAgICAgIGJnID0gcCAtIDEwMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwID09PSAwKSB7XG4gICAgICAgICAgICAvLyBkZWZhdWx0XG4gICAgICAgICAgICBmbGFncyA9IHRoaXMuZGVmQXR0ciA+PiAxODtcbiAgICAgICAgICAgIGZnID0gKHRoaXMuZGVmQXR0ciA+PiA5KSAmIDB4MWZmO1xuICAgICAgICAgICAgYmcgPSB0aGlzLmRlZkF0dHIgJiAweDFmZjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwID09PSAxKSB7XG4gICAgICAgICAgICAvLyBib2xkIHRleHRcbiAgICAgICAgICAgIGZsYWdzIHw9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocCA9PT0gNCkge1xuICAgICAgICAgICAgLy8gdW5kZXJsaW5lZCB0ZXh0XG4gICAgICAgICAgICBmbGFncyB8PSAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHAgPT09IDUpIHtcbiAgICAgICAgICAgIC8vIGJsaW5rXG4gICAgICAgICAgICBmbGFncyB8PSA0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHAgPT09IDcpIHtcbiAgICAgICAgICAgIC8vIGludmVyc2UgYW5kIHBvc2l0aXZlXG4gICAgICAgICAgICAvLyB0ZXN0IHdpdGg6IGVjaG8gLWUgJ1xcZVszMW1cXGVbNDJtaGVsbG9cXGVbN213b3JsZFxcZVsyN21oaVxcZVttJ1xuICAgICAgICAgICAgZmxhZ3MgfD0gODtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwID09PSA4KSB7XG4gICAgICAgICAgICAvLyBpbnZpc2libGVcbiAgICAgICAgICAgIGZsYWdzIHw9IDE2O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHAgPT09IDIyKSB7XG4gICAgICAgICAgICAvLyBub3QgYm9sZFxuICAgICAgICAgICAgZmxhZ3MgJj0gfjE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocCA9PT0gMjQpIHtcbiAgICAgICAgICAgIC8vIG5vdCB1bmRlcmxpbmVkXG4gICAgICAgICAgICBmbGFncyAmPSB+MjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwID09PSAyNSkge1xuICAgICAgICAgICAgLy8gbm90IGJsaW5rXG4gICAgICAgICAgICBmbGFncyAmPSB+NDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwID09PSAyNykge1xuICAgICAgICAgICAgLy8gbm90IGludmVyc2VcbiAgICAgICAgICAgIGZsYWdzICY9IH44O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHAgPT09IDI4KSB7XG4gICAgICAgICAgICAvLyBub3QgaW52aXNpYmxlXG4gICAgICAgICAgICBmbGFncyAmPSB+MTY7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocCA9PT0gMzkpIHtcbiAgICAgICAgICAgIC8vIHJlc2V0IGZnXG4gICAgICAgICAgICBmZyA9ICh0aGlzLmRlZkF0dHIgPj4gOSkgJiAweDFmZjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwID09PSA0OSkge1xuICAgICAgICAgICAgLy8gcmVzZXQgYmdcbiAgICAgICAgICAgIGJnID0gdGhpcy5kZWZBdHRyICYgMHgxZmY7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocCA9PT0gMzgpIHtcbiAgICAgICAgICAgIC8vIGZnIGNvbG9yIDI1NlxuICAgICAgICAgICAgaWYgKHBhcmFtc1tpICsgMV0gPT09IDIpIHtcbiAgICAgICAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgICAgICAgZmcgPSBtYXRjaENvbG9yKHBhcmFtc1tpXSAmIDB4ZmYsIHBhcmFtc1tpICsgMV0gJiAweGZmLCBwYXJhbXNbaSArIDJdICYgMHhmZik7XG4gICAgICAgICAgICAgICAgaWYgKGZnID09PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgZmcgPSAweDFmZjtcbiAgICAgICAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJhbXNbaSArIDFdID09PSA1KSB7XG4gICAgICAgICAgICAgICAgaSArPSAyO1xuICAgICAgICAgICAgICAgIHAgPSBwYXJhbXNbaV0gJiAweGZmO1xuICAgICAgICAgICAgICAgIGZnID0gcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwID09PSA0OCkge1xuICAgICAgICAgICAgLy8gYmcgY29sb3IgMjU2XG4gICAgICAgICAgICBpZiAocGFyYW1zW2kgKyAxXSA9PT0gMikge1xuICAgICAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICAgICAgICBiZyA9IG1hdGNoQ29sb3IocGFyYW1zW2ldICYgMHhmZiwgcGFyYW1zW2kgKyAxXSAmIDB4ZmYsIHBhcmFtc1tpICsgMl0gJiAweGZmKTtcbiAgICAgICAgICAgICAgICBpZiAoYmcgPT09IC0xKVxuICAgICAgICAgICAgICAgICAgICBiZyA9IDB4MWZmO1xuICAgICAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtc1tpICsgMV0gPT09IDUpIHtcbiAgICAgICAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgICAgICAgcCA9IHBhcmFtc1tpXSAmIDB4ZmY7XG4gICAgICAgICAgICAgICAgYmcgPSBwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHAgPT09IDEwMCkge1xuICAgICAgICAgICAgLy8gcmVzZXQgZmcvYmdcbiAgICAgICAgICAgIGZnID0gKHRoaXMuZGVmQXR0ciA+PiA5KSAmIDB4MWZmO1xuICAgICAgICAgICAgYmcgPSB0aGlzLmRlZkF0dHIgJiAweDFmZjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoJ1Vua25vd24gU0dSIGF0dHJpYnV0ZTogJWQuJywgcCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jdXJBdHRyID0gKGZsYWdzIDw8IDE4KSB8IChmZyA8PCA5KSB8IGJnO1xufTtcbi8qKlxuICogQ1NJIFBzIG4gIERldmljZSBTdGF0dXMgUmVwb3J0IChEU1IpLlxuICogICAgIFBzID0gNSAgLT4gU3RhdHVzIFJlcG9ydC4gIFJlc3VsdCAoYGBPSycnKSBpc1xuICogICBDU0kgMCBuXG4gKiAgICAgUHMgPSA2ICAtPiBSZXBvcnQgQ3Vyc29yIFBvc2l0aW9uIChDUFIpIFtyb3c7Y29sdW1uXS5cbiAqICAgUmVzdWx0IGlzXG4gKiAgIENTSSByIDsgYyBSXG4gKiBDU0kgPyBQcyBuXG4gKiAgIERldmljZSBTdGF0dXMgUmVwb3J0IChEU1IsIERFQy1zcGVjaWZpYykuXG4gKiAgICAgUHMgPSA2ICAtPiBSZXBvcnQgQ3Vyc29yIFBvc2l0aW9uIChDUFIpIFtyb3c7Y29sdW1uXSBhcyBDU0lcbiAqICAgICA/IHIgOyBjIFIgKGFzc3VtZXMgcGFnZSBpcyB6ZXJvKS5cbiAqICAgICBQcyA9IDEgNSAgLT4gUmVwb3J0IFByaW50ZXIgc3RhdHVzIGFzIENTSSA/IDEgMCAgbiAgKHJlYWR5KS5cbiAqICAgICBvciBDU0kgPyAxIDEgIG4gIChub3QgcmVhZHkpLlxuICogICAgIFBzID0gMiA1ICAtPiBSZXBvcnQgVURLIHN0YXR1cyBhcyBDU0kgPyAyIDAgIG4gICh1bmxvY2tlZClcbiAqICAgICBvciBDU0kgPyAyIDEgIG4gIChsb2NrZWQpLlxuICogICAgIFBzID0gMiA2ICAtPiBSZXBvcnQgS2V5Ym9hcmQgc3RhdHVzIGFzXG4gKiAgIENTSSA/IDIgNyAgOyAgMSAgOyAgMCAgOyAgMCAgbiAgKE5vcnRoIEFtZXJpY2FuKS5cbiAqICAgVGhlIGxhc3QgdHdvIHBhcmFtZXRlcnMgYXBwbHkgdG8gVlQ0MDAgJiB1cCwgYW5kIGRlbm90ZSBrZXktXG4gKiAgIGJvYXJkIHJlYWR5IGFuZCBMSzAxIHJlc3BlY3RpdmVseS5cbiAqICAgICBQcyA9IDUgMyAgLT4gUmVwb3J0IExvY2F0b3Igc3RhdHVzIGFzXG4gKiAgIENTSSA/IDUgMyAgbiAgTG9jYXRvciBhdmFpbGFibGUsIGlmIGNvbXBpbGVkLWluLCBvclxuICogICBDU0kgPyA1IDAgIG4gIE5vIExvY2F0b3IsIGlmIG5vdC5cbiAqL1xuVGVybWluYWwucHJvdG90eXBlLmRldmljZVN0YXR1cyA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICBpZiAoIXRoaXMucHJlZml4KSB7XG4gICAgICAgIHN3aXRjaCAocGFyYW1zWzBdKSB7XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgLy8gc3RhdHVzIHJlcG9ydFxuICAgICAgICAgICAgICAgIHRoaXMuc2VuZCgnXFx4MWJbMG4nKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAvLyBjdXJzb3IgcG9zaXRpb25cbiAgICAgICAgICAgICAgICB0aGlzLnNlbmQoJ1xceDFiWydcbiAgICAgICAgICAgICAgICAgICAgKyAodGhpcy55ICsgMSlcbiAgICAgICAgICAgICAgICAgICAgKyAnOydcbiAgICAgICAgICAgICAgICAgICAgKyAodGhpcy54ICsgMSlcbiAgICAgICAgICAgICAgICAgICAgKyAnUicpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMucHJlZml4ID09PSAnPycpIHtcbiAgICAgICAgLy8gbW9kZXJuIHh0ZXJtIGRvZXNudCBzZWVtIHRvXG4gICAgICAgIC8vIHJlc3BvbmQgdG8gYW55IG9mIHRoZXNlIGV4Y2VwdCA/NiwgNiwgYW5kIDVcbiAgICAgICAgc3dpdGNoIChwYXJhbXNbMF0pIHtcbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAvLyBjdXJzb3IgcG9zaXRpb25cbiAgICAgICAgICAgICAgICB0aGlzLnNlbmQoJ1xceDFiWz8nXG4gICAgICAgICAgICAgICAgICAgICsgKHRoaXMueSArIDEpXG4gICAgICAgICAgICAgICAgICAgICsgJzsnXG4gICAgICAgICAgICAgICAgICAgICsgKHRoaXMueCArIDEpXG4gICAgICAgICAgICAgICAgICAgICsgJ1InKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgICAgLy8gbm8gcHJpbnRlclxuICAgICAgICAgICAgICAgIC8vIHRoaXMuc2VuZCgnXFx4MWJbPzExbicpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyNTpcbiAgICAgICAgICAgICAgICAvLyBkb250IHN1cHBvcnQgdXNlciBkZWZpbmVkIGtleXNcbiAgICAgICAgICAgICAgICAvLyB0aGlzLnNlbmQoJ1xceDFiWz8yMW4nKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjY6XG4gICAgICAgICAgICAgICAgLy8gbm9ydGggYW1lcmljYW4ga2V5Ym9hcmRcbiAgICAgICAgICAgICAgICAvLyB0aGlzLnNlbmQoJ1xceDFiWz8yNzsxOzA7MG4nKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNTM6XG4gICAgICAgICAgICAgICAgLy8gbm8gZGVjIGxvY2F0b3IvbW91c2VcbiAgICAgICAgICAgICAgICAvLyB0aGlzLnNlbmQoJ1xceDFiWz81MG4nKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn07XG4vKipcbiAqIEFkZGl0aW9uc1xuICovXG4vKipcbiAqIENTSSBQcyBAXG4gKiBJbnNlcnQgUHMgKEJsYW5rKSBDaGFyYWN0ZXIocykgKGRlZmF1bHQgPSAxKSAoSUNIKS5cbiAqL1xuVGVybWluYWwucHJvdG90eXBlLmluc2VydENoYXJzID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgIHZhciBwYXJhbSwgcm93LCBqLCBjaDtcbiAgICBwYXJhbSA9IHBhcmFtc1swXTtcbiAgICBpZiAocGFyYW0gPCAxKVxuICAgICAgICBwYXJhbSA9IDE7XG4gICAgcm93ID0gdGhpcy55ICsgdGhpcy55YmFzZTtcbiAgICBqID0gdGhpcy54O1xuICAgIGNoID0gW3RoaXMuZXJhc2VBdHRyKCksICcgJywgMV07IC8vIHh0ZXJtXG4gICAgd2hpbGUgKHBhcmFtLS0gJiYgaiA8IHRoaXMuY29scykge1xuICAgICAgICB0aGlzLmxpbmVzW3Jvd10uc3BsaWNlKGorKywgMCwgY2gpO1xuICAgICAgICB0aGlzLmxpbmVzW3Jvd10ucG9wKCk7XG4gICAgfVxufTtcbi8qKlxuICogQ1NJIFBzIEVcbiAqIEN1cnNvciBOZXh0IExpbmUgUHMgVGltZXMgKGRlZmF1bHQgPSAxKSAoQ05MKS5cbiAqIHNhbWUgYXMgQ1NJIFBzIEIgP1xuICovXG5UZXJtaW5hbC5wcm90b3R5cGUuY3Vyc29yTmV4dExpbmUgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgdmFyIHBhcmFtID0gcGFyYW1zWzBdO1xuICAgIGlmIChwYXJhbSA8IDEpXG4gICAgICAgIHBhcmFtID0gMTtcbiAgICB0aGlzLnkgKz0gcGFyYW07XG4gICAgaWYgKHRoaXMueSA+PSB0aGlzLnJvd3MpIHtcbiAgICAgICAgdGhpcy55ID0gdGhpcy5yb3dzIC0gMTtcbiAgICB9XG4gICAgdGhpcy54ID0gMDtcbn07XG4vKipcbiAqIENTSSBQcyBGXG4gKiBDdXJzb3IgUHJlY2VkaW5nIExpbmUgUHMgVGltZXMgKGRlZmF1bHQgPSAxKSAoQ05MKS5cbiAqIHJldXNlIENTSSBQcyBBID9cbiAqL1xuVGVybWluYWwucHJvdG90eXBlLmN1cnNvclByZWNlZGluZ0xpbmUgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgdmFyIHBhcmFtID0gcGFyYW1zWzBdO1xuICAgIGlmIChwYXJhbSA8IDEpXG4gICAgICAgIHBhcmFtID0gMTtcbiAgICB0aGlzLnkgLT0gcGFyYW07XG4gICAgaWYgKHRoaXMueSA8IDApXG4gICAgICAgIHRoaXMueSA9IDA7XG4gICAgdGhpcy54ID0gMDtcbn07XG4vKipcbiAqIENTSSBQcyBHXG4gKiBDdXJzb3IgQ2hhcmFjdGVyIEFic29sdXRlICBbY29sdW1uXSAoZGVmYXVsdCA9IFtyb3csMV0pIChDSEEpLlxuICovXG5UZXJtaW5hbC5wcm90b3R5cGUuY3Vyc29yQ2hhckFic29sdXRlID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgIHZhciBwYXJhbSA9IHBhcmFtc1swXTtcbiAgICBpZiAocGFyYW0gPCAxKVxuICAgICAgICBwYXJhbSA9IDE7XG4gICAgdGhpcy54ID0gcGFyYW0gLSAxO1xufTtcbi8qKlxuICogQ1NJIFBzIExcbiAqIEluc2VydCBQcyBMaW5lKHMpIChkZWZhdWx0ID0gMSkgKElMKS5cbiAqL1xuVGVybWluYWwucHJvdG90eXBlLmluc2VydExpbmVzID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgIHZhciBwYXJhbSwgcm93LCBqO1xuICAgIHBhcmFtID0gcGFyYW1zWzBdO1xuICAgIGlmIChwYXJhbSA8IDEpXG4gICAgICAgIHBhcmFtID0gMTtcbiAgICByb3cgPSB0aGlzLnkgKyB0aGlzLnliYXNlO1xuICAgIGogPSB0aGlzLnJvd3MgLSAxIC0gdGhpcy5zY3JvbGxCb3R0b207XG4gICAgaiA9IHRoaXMucm93cyAtIDEgKyB0aGlzLnliYXNlIC0gaiArIDE7XG4gICAgd2hpbGUgKHBhcmFtLS0pIHtcbiAgICAgICAgLy8gdGVzdDogZWNobyAtZSAnXFxlWzQ0bVxcZVsxTFxcZVswbSdcbiAgICAgICAgLy8gYmxhbmtMaW5lKHRydWUpIC0geHRlcm0vbGludXggYmVoYXZpb3JcbiAgICAgICAgdGhpcy5saW5lcy5zcGxpY2Uocm93LCAwLCB0aGlzLmJsYW5rTGluZSh0cnVlKSk7XG4gICAgICAgIHRoaXMubGluZXMuc3BsaWNlKGosIDEpO1xuICAgIH1cbiAgICAvLyB0aGlzLm1heFJhbmdlKCk7XG4gICAgdGhpcy51cGRhdGVSYW5nZSh0aGlzLnkpO1xuICAgIHRoaXMudXBkYXRlUmFuZ2UodGhpcy5zY3JvbGxCb3R0b20pO1xufTtcbi8qKlxuICogQ1NJIFBzIE1cbiAqIERlbGV0ZSBQcyBMaW5lKHMpIChkZWZhdWx0ID0gMSkgKERMKS5cbiAqL1xuVGVybWluYWwucHJvdG90eXBlLmRlbGV0ZUxpbmVzID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgIHZhciBwYXJhbSwgcm93LCBqO1xuICAgIHBhcmFtID0gcGFyYW1zWzBdO1xuICAgIGlmIChwYXJhbSA8IDEpXG4gICAgICAgIHBhcmFtID0gMTtcbiAgICByb3cgPSB0aGlzLnkgKyB0aGlzLnliYXNlO1xuICAgIGogPSB0aGlzLnJvd3MgLSAxIC0gdGhpcy5zY3JvbGxCb3R0b207XG4gICAgaiA9IHRoaXMucm93cyAtIDEgKyB0aGlzLnliYXNlIC0gajtcbiAgICB3aGlsZSAocGFyYW0tLSkge1xuICAgICAgICAvLyB0ZXN0OiBlY2hvIC1lICdcXGVbNDRtXFxlWzFNXFxlWzBtJ1xuICAgICAgICAvLyBibGFua0xpbmUodHJ1ZSkgLSB4dGVybS9saW51eCBiZWhhdmlvclxuICAgICAgICB0aGlzLmxpbmVzLnNwbGljZShqICsgMSwgMCwgdGhpcy5ibGFua0xpbmUodHJ1ZSkpO1xuICAgICAgICB0aGlzLmxpbmVzLnNwbGljZShyb3csIDEpO1xuICAgIH1cbiAgICAvLyB0aGlzLm1heFJhbmdlKCk7XG4gICAgdGhpcy51cGRhdGVSYW5nZSh0aGlzLnkpO1xuICAgIHRoaXMudXBkYXRlUmFuZ2UodGhpcy5zY3JvbGxCb3R0b20pO1xufTtcbi8qKlxuICogQ1NJIFBzIFBcbiAqIERlbGV0ZSBQcyBDaGFyYWN0ZXIocykgKGRlZmF1bHQgPSAxKSAoRENIKS5cbiAqL1xuVGVybWluYWwucHJvdG90eXBlLmRlbGV0ZUNoYXJzID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgIHZhciBwYXJhbSwgcm93LCBjaDtcbiAgICBwYXJhbSA9IHBhcmFtc1swXTtcbiAgICBpZiAocGFyYW0gPCAxKVxuICAgICAgICBwYXJhbSA9IDE7XG4gICAgcm93ID0gdGhpcy55ICsgdGhpcy55YmFzZTtcbiAgICBjaCA9IFt0aGlzLmVyYXNlQXR0cigpLCAnICcsIDFdOyAvLyB4dGVybVxuICAgIHdoaWxlIChwYXJhbS0tKSB7XG4gICAgICAgIHRoaXMubGluZXNbcm93XS5zcGxpY2UodGhpcy54LCAxKTtcbiAgICAgICAgdGhpcy5saW5lc1tyb3ddLnB1c2goY2gpO1xuICAgIH1cbn07XG4vKipcbiAqIENTSSBQcyBYXG4gKiBFcmFzZSBQcyBDaGFyYWN0ZXIocykgKGRlZmF1bHQgPSAxKSAoRUNIKS5cbiAqL1xuVGVybWluYWwucHJvdG90eXBlLmVyYXNlQ2hhcnMgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgdmFyIHBhcmFtLCByb3csIGosIGNoO1xuICAgIHBhcmFtID0gcGFyYW1zWzBdO1xuICAgIGlmIChwYXJhbSA8IDEpXG4gICAgICAgIHBhcmFtID0gMTtcbiAgICByb3cgPSB0aGlzLnkgKyB0aGlzLnliYXNlO1xuICAgIGogPSB0aGlzLng7XG4gICAgY2ggPSBbdGhpcy5lcmFzZUF0dHIoKSwgJyAnLCAxXTsgLy8geHRlcm1cbiAgICB3aGlsZSAocGFyYW0tLSAmJiBqIDwgdGhpcy5jb2xzKSB7XG4gICAgICAgIHRoaXMubGluZXNbcm93XVtqKytdID0gY2g7XG4gICAgfVxufTtcbi8qKlxuICogQ1NJIFBtIGAgIENoYXJhY3RlciBQb3NpdGlvbiBBYnNvbHV0ZVxuICogICBbY29sdW1uXSAoZGVmYXVsdCA9IFtyb3csMV0pIChIUEEpLlxuICovXG5UZXJtaW5hbC5wcm90b3R5cGUuY2hhclBvc0Fic29sdXRlID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgIHZhciBwYXJhbSA9IHBhcmFtc1swXTtcbiAgICBpZiAocGFyYW0gPCAxKVxuICAgICAgICBwYXJhbSA9IDE7XG4gICAgdGhpcy54ID0gcGFyYW0gLSAxO1xuICAgIGlmICh0aGlzLnggPj0gdGhpcy5jb2xzKSB7XG4gICAgICAgIHRoaXMueCA9IHRoaXMuY29scyAtIDE7XG4gICAgfVxufTtcbi8qKlxuICogMTQxIDYxIGEgKiBIUFIgLVxuICogSG9yaXpvbnRhbCBQb3NpdGlvbiBSZWxhdGl2ZVxuICogcmV1c2UgQ1NJIFBzIEMgP1xuICovXG5UZXJtaW5hbC5wcm90b3R5cGUuSFBvc2l0aW9uUmVsYXRpdmUgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgdmFyIHBhcmFtID0gcGFyYW1zWzBdO1xuICAgIGlmIChwYXJhbSA8IDEpXG4gICAgICAgIHBhcmFtID0gMTtcbiAgICB0aGlzLnggKz0gcGFyYW07XG4gICAgaWYgKHRoaXMueCA+PSB0aGlzLmNvbHMpIHtcbiAgICAgICAgdGhpcy54ID0gdGhpcy5jb2xzIC0gMTtcbiAgICB9XG59O1xuLyoqXG4gKiBDU0kgUHMgYyAgU2VuZCBEZXZpY2UgQXR0cmlidXRlcyAoUHJpbWFyeSBEQSkuXG4gKiAgICAgUHMgPSAwICBvciBvbWl0dGVkIC0+IHJlcXVlc3QgYXR0cmlidXRlcyBmcm9tIHRlcm1pbmFsLiAgVGhlXG4gKiAgICAgcmVzcG9uc2UgZGVwZW5kcyBvbiB0aGUgZGVjVGVybWluYWxJRCByZXNvdXJjZSBzZXR0aW5nLlxuICogICAgIC0+IENTSSA/IDEgOyAyIGMgIChgYFZUMTAwIHdpdGggQWR2YW5jZWQgVmlkZW8gT3B0aW9uJycpXG4gKiAgICAgLT4gQ1NJID8gMSA7IDAgYyAgKGBgVlQxMDEgd2l0aCBObyBPcHRpb25zJycpXG4gKiAgICAgLT4gQ1NJID8gNiBjICAoYGBWVDEwMicnKVxuICogICAgIC0+IENTSSA/IDYgMCA7IDEgOyAyIDsgNiA7IDggOyA5IDsgMSA1IDsgYyAgKGBgVlQyMjAnJylcbiAqICAgVGhlIFZUMTAwLXN0eWxlIHJlc3BvbnNlIHBhcmFtZXRlcnMgZG8gbm90IG1lYW4gYW55dGhpbmcgYnlcbiAqICAgdGhlbXNlbHZlcy4gIFZUMjIwIHBhcmFtZXRlcnMgZG8sIHRlbGxpbmcgdGhlIGhvc3Qgd2hhdCBmZWEtXG4gKiAgIHR1cmVzIHRoZSB0ZXJtaW5hbCBzdXBwb3J0czpcbiAqICAgICBQcyA9IDEgIC0+IDEzMi1jb2x1bW5zLlxuICogICAgIFBzID0gMiAgLT4gUHJpbnRlci5cbiAqICAgICBQcyA9IDYgIC0+IFNlbGVjdGl2ZSBlcmFzZS5cbiAqICAgICBQcyA9IDggIC0+IFVzZXItZGVmaW5lZCBrZXlzLlxuICogICAgIFBzID0gOSAgLT4gTmF0aW9uYWwgcmVwbGFjZW1lbnQgY2hhcmFjdGVyIHNldHMuXG4gKiAgICAgUHMgPSAxIDUgIC0+IFRlY2huaWNhbCBjaGFyYWN0ZXJzLlxuICogICAgIFBzID0gMiAyICAtPiBBTlNJIGNvbG9yLCBlLmcuLCBWVDUyNS5cbiAqICAgICBQcyA9IDIgOSAgLT4gQU5TSSB0ZXh0IGxvY2F0b3IgKGkuZS4sIERFQyBMb2NhdG9yIG1vZGUpLlxuICogQ1NJID4gUHMgY1xuICogICBTZW5kIERldmljZSBBdHRyaWJ1dGVzIChTZWNvbmRhcnkgREEpLlxuICogICAgIFBzID0gMCAgb3Igb21pdHRlZCAtPiByZXF1ZXN0IHRoZSB0ZXJtaW5hbCdzIGlkZW50aWZpY2F0aW9uXG4gKiAgICAgY29kZS4gIFRoZSByZXNwb25zZSBkZXBlbmRzIG9uIHRoZSBkZWNUZXJtaW5hbElEIHJlc291cmNlIHNldC1cbiAqICAgICB0aW5nLiAgSXQgc2hvdWxkIGFwcGx5IG9ubHkgdG8gVlQyMjAgYW5kIHVwLCBidXQgeHRlcm0gZXh0ZW5kc1xuICogICAgIHRoaXMgdG8gVlQxMDAuXG4gKiAgICAgLT4gQ1NJICA+IFBwIDsgUHYgOyBQYyBjXG4gKiAgIHdoZXJlIFBwIGRlbm90ZXMgdGhlIHRlcm1pbmFsIHR5cGVcbiAqICAgICBQcCA9IDAgIC0+IGBgVlQxMDAnJy5cbiAqICAgICBQcCA9IDEgIC0+IGBgVlQyMjAnJy5cbiAqICAgYW5kIFB2IGlzIHRoZSBmaXJtd2FyZSB2ZXJzaW9uIChmb3IgeHRlcm0sIHRoaXMgd2FzIG9yaWdpbmFsbHlcbiAqICAgdGhlIFhGcmVlODYgcGF0Y2ggbnVtYmVyLCBzdGFydGluZyB3aXRoIDk1KS4gIEluIGEgREVDIHRlcm1pLVxuICogICBuYWwsIFBjIGluZGljYXRlcyB0aGUgUk9NIGNhcnRyaWRnZSByZWdpc3RyYXRpb24gbnVtYmVyIGFuZCBpc1xuICogICBhbHdheXMgemVyby5cbiAqIE1vcmUgaW5mb3JtYXRpb246XG4gKiAgIHh0ZXJtL2NoYXJwcm9jLmMgLSBsaW5lIDIwMTIsIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICogICB2aW0gcmVzcG9uZHMgd2l0aCBeW1s/MGMgb3IgXltbPzFjIGFmdGVyIHRoZSB0ZXJtaW5hbCdzIHJlc3BvbnNlICg/KVxuICovXG5UZXJtaW5hbC5wcm90b3R5cGUuc2VuZERldmljZUF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgaWYgKHBhcmFtc1swXSA+IDApXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoIXRoaXMucHJlZml4KSB7XG4gICAgICAgIGlmICh0aGlzLmlzKCd4dGVybScpXG4gICAgICAgICAgICB8fCB0aGlzLmlzKCdyeHZ0LXVuaWNvZGUnKVxuICAgICAgICAgICAgfHwgdGhpcy5pcygnc2NyZWVuJykpIHtcbiAgICAgICAgICAgIHRoaXMuc2VuZCgnXFx4MWJbPzE7MmMnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmlzKCdsaW51eCcpKSB7XG4gICAgICAgICAgICB0aGlzLnNlbmQoJ1xceDFiWz82YycpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMucHJlZml4ID09PSAnPicpIHtcbiAgICAgICAgLy8geHRlcm0gYW5kIHVyeHZ0XG4gICAgICAgIC8vIHNlZW0gdG8gc3BpdCB0aGlzXG4gICAgICAgIC8vIG91dCBhcm91bmQgfjM3MCB0aW1lcyAoPykuXG4gICAgICAgIGlmICh0aGlzLmlzKCd4dGVybScpKSB7XG4gICAgICAgICAgICB0aGlzLnNlbmQoJ1xceDFiWz4wOzI3NjswYycpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuaXMoJ3J4dnQtdW5pY29kZScpKSB7XG4gICAgICAgICAgICB0aGlzLnNlbmQoJ1xceDFiWz44NTs5NTswYycpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuaXMoJ2xpbnV4JykpIHtcbiAgICAgICAgICAgIC8vIG5vdCBzdXBwb3J0ZWQgYnkgbGludXggY29uc29sZS5cbiAgICAgICAgICAgIC8vIGxpbnV4IGNvbnNvbGUgZWNob2VzIHBhcmFtZXRlcnMuXG4gICAgICAgICAgICB0aGlzLnNlbmQocGFyYW1zWzBdICsgJ2MnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmlzKCdzY3JlZW4nKSkge1xuICAgICAgICAgICAgdGhpcy5zZW5kKCdcXHgxYls+ODM7NDAwMDM7MGMnKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG4vKipcbiAqIENTSSBQbSBkXG4gKiBMaW5lIFBvc2l0aW9uIEFic29sdXRlICBbcm93XSAoZGVmYXVsdCA9IFsxLGNvbHVtbl0pIChWUEEpLlxuICovXG5UZXJtaW5hbC5wcm90b3R5cGUubGluZVBvc0Fic29sdXRlID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgIHZhciBwYXJhbSA9IHBhcmFtc1swXTtcbiAgICBpZiAocGFyYW0gPCAxKVxuICAgICAgICBwYXJhbSA9IDE7XG4gICAgdGhpcy55ID0gcGFyYW0gLSAxO1xuICAgIGlmICh0aGlzLnkgPj0gdGhpcy5yb3dzKSB7XG4gICAgICAgIHRoaXMueSA9IHRoaXMucm93cyAtIDE7XG4gICAgfVxufTtcbi8qKlxuICogMTQ1IDY1IGUgKiBWUFIgLSBWZXJ0aWNhbCBQb3NpdGlvbiBSZWxhdGl2ZVxuICogcmV1c2UgQ1NJIFBzIEIgP1xuICovXG5UZXJtaW5hbC5wcm90b3R5cGUuVlBvc2l0aW9uUmVsYXRpdmUgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgdmFyIHBhcmFtID0gcGFyYW1zWzBdO1xuICAgIGlmIChwYXJhbSA8IDEpXG4gICAgICAgIHBhcmFtID0gMTtcbiAgICB0aGlzLnkgKz0gcGFyYW07XG4gICAgaWYgKHRoaXMueSA+PSB0aGlzLnJvd3MpIHtcbiAgICAgICAgdGhpcy55ID0gdGhpcy5yb3dzIC0gMTtcbiAgICB9XG59O1xuLyoqXG4gKiBDU0kgUHMgOyBQcyBmXG4gKiAgIEhvcml6b250YWwgYW5kIFZlcnRpY2FsIFBvc2l0aW9uIFtyb3c7Y29sdW1uXSAoZGVmYXVsdCA9XG4gKiAgIFsxLDFdKSAoSFZQKS5cbiAqL1xuVGVybWluYWwucHJvdG90eXBlLkhWUG9zaXRpb24gPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgaWYgKHBhcmFtc1swXSA8IDEpXG4gICAgICAgIHBhcmFtc1swXSA9IDE7XG4gICAgaWYgKHBhcmFtc1sxXSA8IDEpXG4gICAgICAgIHBhcmFtc1sxXSA9IDE7XG4gICAgdGhpcy55ID0gcGFyYW1zWzBdIC0gMTtcbiAgICBpZiAodGhpcy55ID49IHRoaXMucm93cykge1xuICAgICAgICB0aGlzLnkgPSB0aGlzLnJvd3MgLSAxO1xuICAgIH1cbiAgICB0aGlzLnggPSBwYXJhbXNbMV0gLSAxO1xuICAgIGlmICh0aGlzLnggPj0gdGhpcy5jb2xzKSB7XG4gICAgICAgIHRoaXMueCA9IHRoaXMuY29scyAtIDE7XG4gICAgfVxufTtcbi8qKlxuICogQ1NJIFBtIGggIFNldCBNb2RlIChTTSkuXG4gKiAgICAgUHMgPSAyICAtPiBLZXlib2FyZCBBY3Rpb24gTW9kZSAoQU0pLlxuICogICAgIFBzID0gNCAgLT4gSW5zZXJ0IE1vZGUgKElSTSkuXG4gKiAgICAgUHMgPSAxIDIgIC0+IFNlbmQvcmVjZWl2ZSAoU1JNKS5cbiAqICAgICBQcyA9IDIgMCAgLT4gQXV0b21hdGljIE5ld2xpbmUgKExOTSkuXG4gKiBDU0kgPyBQbSBoXG4gKiAgIERFQyBQcml2YXRlIE1vZGUgU2V0IChERUNTRVQpLlxuICogICAgIFBzID0gMSAgLT4gQXBwbGljYXRpb24gQ3Vyc29yIEtleXMgKERFQ0NLTSkuXG4gKiAgICAgUHMgPSAyICAtPiBEZXNpZ25hdGUgVVNBU0NJSSBmb3IgY2hhcmFjdGVyIHNldHMgRzAtRzNcbiAqICAgICAoREVDQU5NKSwgYW5kIHNldCBWVDEwMCBtb2RlLlxuICogICAgIFBzID0gMyAgLT4gMTMyIENvbHVtbiBNb2RlIChERUNDT0xNKS5cbiAqICAgICBQcyA9IDQgIC0+IFNtb290aCAoU2xvdykgU2Nyb2xsIChERUNTQ0xNKS5cbiAqICAgICBQcyA9IDUgIC0+IFJldmVyc2UgVmlkZW8gKERFQ1NDTk0pLlxuICogICAgIFBzID0gNiAgLT4gT3JpZ2luIE1vZGUgKERFQ09NKS5cbiAqICAgICBQcyA9IDcgIC0+IFdyYXBhcm91bmQgTW9kZSAoREVDQVdNKS5cbiAqICAgICBQcyA9IDggIC0+IEF1dG8tcmVwZWF0IEtleXMgKERFQ0FSTSkuXG4gKiAgICAgUHMgPSA5ICAtPiBTZW5kIE1vdXNlIFggJiBZIG9uIGJ1dHRvbiBwcmVzcy4gIFNlZSB0aGUgc2VjLVxuICogICAgIHRpb24gTW91c2UgVHJhY2tpbmcuXG4gKiAgICAgUHMgPSAxIDAgIC0+IFNob3cgdG9vbGJhciAocnh2dCkuXG4gKiAgICAgUHMgPSAxIDIgIC0+IFN0YXJ0IEJsaW5raW5nIEN1cnNvciAoYXR0NjEwKS5cbiAqICAgICBQcyA9IDEgOCAgLT4gUHJpbnQgZm9ybSBmZWVkIChERUNQRkYpLlxuICogICAgIFBzID0gMSA5ICAtPiBTZXQgcHJpbnQgZXh0ZW50IHRvIGZ1bGwgc2NyZWVuIChERUNQRVgpLlxuICogICAgIFBzID0gMiA1ICAtPiBTaG93IEN1cnNvciAoREVDVENFTSkuXG4gKiAgICAgUHMgPSAzIDAgIC0+IFNob3cgc2Nyb2xsYmFyIChyeHZ0KS5cbiAqICAgICBQcyA9IDMgNSAgLT4gRW5hYmxlIGZvbnQtc2hpZnRpbmcgZnVuY3Rpb25zIChyeHZ0KS5cbiAqICAgICBQcyA9IDMgOCAgLT4gRW50ZXIgVGVrdHJvbml4IE1vZGUgKERFQ1RFSykuXG4gKiAgICAgUHMgPSA0IDAgIC0+IEFsbG93IDgwIC0+IDEzMiBNb2RlLlxuICogICAgIFBzID0gNCAxICAtPiBtb3JlKDEpIGZpeCAoc2VlIGN1cnNlcyByZXNvdXJjZSkuXG4gKiAgICAgUHMgPSA0IDIgIC0+IEVuYWJsZSBOYXRpb24gUmVwbGFjZW1lbnQgQ2hhcmFjdGVyIHNldHMgKERFQ04tXG4gKiAgICAgUkNNKS5cbiAqICAgICBQcyA9IDQgNCAgLT4gVHVybiBPbiBNYXJnaW4gQmVsbC5cbiAqICAgICBQcyA9IDQgNSAgLT4gUmV2ZXJzZS13cmFwYXJvdW5kIE1vZGUuXG4gKiAgICAgUHMgPSA0IDYgIC0+IFN0YXJ0IExvZ2dpbmcuICBUaGlzIGlzIG5vcm1hbGx5IGRpc2FibGVkIGJ5IGFcbiAqICAgICBjb21waWxlLXRpbWUgb3B0aW9uLlxuICogICAgIFBzID0gNCA3ICAtPiBVc2UgQWx0ZXJuYXRlIFNjcmVlbiBCdWZmZXIuICAoVGhpcyBtYXkgYmUgZGlzLVxuICogICAgIGFibGVkIGJ5IHRoZSB0aXRlSW5oaWJpdCByZXNvdXJjZSkuXG4gKiAgICAgUHMgPSA2IDYgIC0+IEFwcGxpY2F0aW9uIGtleXBhZCAoREVDTktNKS5cbiAqICAgICBQcyA9IDYgNyAgLT4gQmFja2Fycm93IGtleSBzZW5kcyBiYWNrc3BhY2UgKERFQ0JLTSkuXG4gKiAgICAgUHMgPSAxIDAgMCAwICAtPiBTZW5kIE1vdXNlIFggJiBZIG9uIGJ1dHRvbiBwcmVzcyBhbmRcbiAqICAgICByZWxlYXNlLiAgU2VlIHRoZSBzZWN0aW9uIE1vdXNlIFRyYWNraW5nLlxuICogICAgIFBzID0gMSAwIDAgMSAgLT4gVXNlIEhpbGl0ZSBNb3VzZSBUcmFja2luZy5cbiAqICAgICBQcyA9IDEgMCAwIDIgIC0+IFVzZSBDZWxsIE1vdGlvbiBNb3VzZSBUcmFja2luZy5cbiAqICAgICBQcyA9IDEgMCAwIDMgIC0+IFVzZSBBbGwgTW90aW9uIE1vdXNlIFRyYWNraW5nLlxuICogICAgIFBzID0gMSAwIDAgNCAgLT4gU2VuZCBGb2N1c0luL0ZvY3VzT3V0IGV2ZW50cy5cbiAqICAgICBQcyA9IDEgMCAwIDUgIC0+IEVuYWJsZSBFeHRlbmRlZCBNb3VzZSBNb2RlLlxuICogICAgIFBzID0gMSAwIDEgMCAgLT4gU2Nyb2xsIHRvIGJvdHRvbSBvbiB0dHkgb3V0cHV0IChyeHZ0KS5cbiAqICAgICBQcyA9IDEgMCAxIDEgIC0+IFNjcm9sbCB0byBib3R0b20gb24ga2V5IHByZXNzIChyeHZ0KS5cbiAqICAgICBQcyA9IDEgMCAzIDQgIC0+IEludGVycHJldCBcIm1ldGFcIiBrZXksIHNldHMgZWlnaHRoIGJpdC5cbiAqICAgICAoZW5hYmxlcyB0aGUgZWlnaHRCaXRJbnB1dCByZXNvdXJjZSkuXG4gKiAgICAgUHMgPSAxIDAgMyA1ICAtPiBFbmFibGUgc3BlY2lhbCBtb2RpZmllcnMgZm9yIEFsdCBhbmQgTnVtLVxuICogICAgIExvY2sga2V5cy4gIChUaGlzIGVuYWJsZXMgdGhlIG51bUxvY2sgcmVzb3VyY2UpLlxuICogICAgIFBzID0gMSAwIDMgNiAgLT4gU2VuZCBFU0MgICB3aGVuIE1ldGEgbW9kaWZpZXMgYSBrZXkuICAoVGhpc1xuICogICAgIGVuYWJsZXMgdGhlIG1ldGFTZW5kc0VzY2FwZSByZXNvdXJjZSkuXG4gKiAgICAgUHMgPSAxIDAgMyA3ICAtPiBTZW5kIERFTCBmcm9tIHRoZSBlZGl0aW5nLWtleXBhZCBEZWxldGVcbiAqICAgICBrZXkuXG4gKiAgICAgUHMgPSAxIDAgMyA5ICAtPiBTZW5kIEVTQyAgd2hlbiBBbHQgbW9kaWZpZXMgYSBrZXkuICAoVGhpc1xuICogICAgIGVuYWJsZXMgdGhlIGFsdFNlbmRzRXNjYXBlIHJlc291cmNlKS5cbiAqICAgICBQcyA9IDEgMCA0IDAgIC0+IEtlZXAgc2VsZWN0aW9uIGV2ZW4gaWYgbm90IGhpZ2hsaWdodGVkLlxuICogICAgIChUaGlzIGVuYWJsZXMgdGhlIGtlZXBTZWxlY3Rpb24gcmVzb3VyY2UpLlxuICogICAgIFBzID0gMSAwIDQgMSAgLT4gVXNlIHRoZSBDTElQQk9BUkQgc2VsZWN0aW9uLiAgKFRoaXMgZW5hYmxlc1xuICogICAgIHRoZSBzZWxlY3RUb0NsaXBib2FyZCByZXNvdXJjZSkuXG4gKiAgICAgUHMgPSAxIDAgNCAyICAtPiBFbmFibGUgVXJnZW5jeSB3aW5kb3cgbWFuYWdlciBoaW50IHdoZW5cbiAqICAgICBDb250cm9sLUcgaXMgcmVjZWl2ZWQuICAoVGhpcyBlbmFibGVzIHRoZSBiZWxsSXNVcmdlbnRcbiAqICAgICByZXNvdXJjZSkuXG4gKiAgICAgUHMgPSAxIDAgNCAzICAtPiBFbmFibGUgcmFpc2luZyBvZiB0aGUgd2luZG93IHdoZW4gQ29udHJvbC1HXG4gKiAgICAgaXMgcmVjZWl2ZWQuICAoZW5hYmxlcyB0aGUgcG9wT25CZWxsIHJlc291cmNlKS5cbiAqICAgICBQcyA9IDEgMCA0IDcgIC0+IFVzZSBBbHRlcm5hdGUgU2NyZWVuIEJ1ZmZlci4gIChUaGlzIG1heSBiZVxuICogICAgIGRpc2FibGVkIGJ5IHRoZSB0aXRlSW5oaWJpdCByZXNvdXJjZSkuXG4gKiAgICAgUHMgPSAxIDAgNCA4ICAtPiBTYXZlIGN1cnNvciBhcyBpbiBERUNTQy4gIChUaGlzIG1heSBiZSBkaXMtXG4gKiAgICAgYWJsZWQgYnkgdGhlIHRpdGVJbmhpYml0IHJlc291cmNlKS5cbiAqICAgICBQcyA9IDEgMCA0IDkgIC0+IFNhdmUgY3Vyc29yIGFzIGluIERFQ1NDIGFuZCB1c2UgQWx0ZXJuYXRlXG4gKiAgICAgU2NyZWVuIEJ1ZmZlciwgY2xlYXJpbmcgaXQgZmlyc3QuICAoVGhpcyBtYXkgYmUgZGlzYWJsZWQgYnlcbiAqICAgICB0aGUgdGl0ZUluaGliaXQgcmVzb3VyY2UpLiAgVGhpcyBjb21iaW5lcyB0aGUgZWZmZWN0cyBvZiB0aGUgMVxuICogICAgIDAgNCA3ICBhbmQgMSAwIDQgOCAgbW9kZXMuICBVc2UgdGhpcyB3aXRoIHRlcm1pbmZvLWJhc2VkXG4gKiAgICAgYXBwbGljYXRpb25zIHJhdGhlciB0aGFuIHRoZSA0IDcgIG1vZGUuXG4gKiAgICAgUHMgPSAxIDAgNSAwICAtPiBTZXQgdGVybWluZm8vdGVybWNhcCBmdW5jdGlvbi1rZXkgbW9kZS5cbiAqICAgICBQcyA9IDEgMCA1IDEgIC0+IFNldCBTdW4gZnVuY3Rpb24ta2V5IG1vZGUuXG4gKiAgICAgUHMgPSAxIDAgNSAyICAtPiBTZXQgSFAgZnVuY3Rpb24ta2V5IG1vZGUuXG4gKiAgICAgUHMgPSAxIDAgNSAzICAtPiBTZXQgU0NPIGZ1bmN0aW9uLWtleSBtb2RlLlxuICogICAgIFBzID0gMSAwIDYgMCAgLT4gU2V0IGxlZ2FjeSBrZXlib2FyZCBlbXVsYXRpb24gKFgxMVI2KS5cbiAqICAgICBQcyA9IDEgMCA2IDEgIC0+IFNldCBWVDIyMCBrZXlib2FyZCBlbXVsYXRpb24uXG4gKiAgICAgUHMgPSAyIDAgMCA0ICAtPiBTZXQgYnJhY2tldGVkIHBhc3RlIG1vZGUuXG4gKiBNb2RlczpcbiAqICAgaHR0cDogKnZ0MTAwLm5ldC9kb2NzL3Z0MjIwLXJtL2NoYXB0ZXI0Lmh0bWxcbiAqL1xuVGVybWluYWwucHJvdG90eXBlLnNldE1vZGUgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgaWYgKHR5cGVvZiBwYXJhbXMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHZhciBsID0gcGFyYW1zLmxlbmd0aCwgaSA9IDA7XG4gICAgICAgIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnNldE1vZGUocGFyYW1zW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy5wcmVmaXgpIHtcbiAgICAgICAgc3dpdGNoIChwYXJhbXMpIHtcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICB0aGlzLmluc2VydE1vZGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyMDpcbiAgICAgICAgICAgICAgICAvL3RoaXMuY29udmVydEVvbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5wcmVmaXggPT09ICc/Jykge1xuICAgICAgICBzd2l0Y2ggKHBhcmFtcykge1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHRoaXMuYXBwbGljYXRpb25DdXJzb3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHRoaXMuc2V0Z0NoYXJzZXQoMCwgVGVybWluYWwuY2hhcnNldHMuVVMpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0Z0NoYXJzZXQoMSwgVGVybWluYWwuY2hhcnNldHMuVVMpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0Z0NoYXJzZXQoMiwgVGVybWluYWwuY2hhcnNldHMuVVMpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0Z0NoYXJzZXQoMywgVGVybWluYWwuY2hhcnNldHMuVVMpO1xuICAgICAgICAgICAgICAgIC8vIHNldCBWVDEwMCBtb2RlIGhlcmVcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICB0aGlzLnNhdmVkQ29scyA9IHRoaXMuY29scztcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2l6ZSgxMzIsIHRoaXMucm93cyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgdGhpcy5vcmlnaW5Nb2RlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICB0aGlzLndyYXBhcm91bmRNb2RlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgICAgLy8gdGhpcy5jdXJzb3JCbGluayA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDY2OlxuICAgICAgICAgICAgICAgIHRoaXMubG9nKCdTZXJpYWwgcG9ydCByZXF1ZXN0ZWQgYXBwbGljYXRpb24ga2V5cGFkLicpO1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwbGljYXRpb25LZXlwYWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld3BvcnQuc3luY1Njcm9sbEFyZWEoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgOTogLy8gWDEwIE1vdXNlXG4gICAgICAgICAgICAvLyBubyByZWxlYXNlLCBubyBtb3Rpb24sIG5vIHdoZWVsLCBubyBtb2RpZmllcnMuXG4gICAgICAgICAgICBjYXNlIDEwMDA6IC8vIHZ0MjAwIG1vdXNlXG4gICAgICAgICAgICAvLyBubyBtb3Rpb24uXG4gICAgICAgICAgICAvLyBubyBtb2RpZmllcnMsIGV4Y2VwdCBjb250cm9sIG9uIHRoZSB3aGVlbC5cbiAgICAgICAgICAgIGNhc2UgMTAwMjogLy8gYnV0dG9uIGV2ZW50IG1vdXNlXG4gICAgICAgICAgICBjYXNlIDEwMDM6XG4gICAgICAgICAgICAgICAgLy8gYW55IGV2ZW50IC0gc2VuZHMgbW90aW9uIGV2ZW50cyxcbiAgICAgICAgICAgICAgICAvLyBldmVuIGlmIHRoZXJlIGlzIG5vIGJ1dHRvbiBoZWxkIGRvd24uXG4gICAgICAgICAgICAgICAgdGhpcy54MTBNb3VzZSA9IHBhcmFtcyA9PT0gOTtcbiAgICAgICAgICAgICAgICB0aGlzLnZ0MjAwTW91c2UgPSBwYXJhbXMgPT09IDEwMDA7XG4gICAgICAgICAgICAgICAgdGhpcy5ub3JtYWxNb3VzZSA9IHBhcmFtcyA+IDEwMDA7XG4gICAgICAgICAgICAgICAgdGhpcy5tb3VzZUV2ZW50cyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmN1cnNvciA9ICdkZWZhdWx0JztcbiAgICAgICAgICAgICAgICB0aGlzLmxvZygnQmluZGluZyB0byBtb3VzZSBldmVudHMuJyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDEwMDQ6XG4gICAgICAgICAgICAgICAgLy8gZm9jdXNpbjogXltbSVxuICAgICAgICAgICAgICAgIC8vIGZvY3Vzb3V0OiBeW1tPXG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kRm9jdXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxMDA1OlxuICAgICAgICAgICAgICAgIHRoaXMudXRmTW91c2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vIGZvciB3aWRlIHRlcm1pbmFsc1xuICAgICAgICAgICAgICAgIC8vIHNpbXBseSBlbmNvZGVzIGxhcmdlIHZhbHVlcyBhcyB1dGY4IGNoYXJhY3RlcnNcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTAwNjpcbiAgICAgICAgICAgICAgICB0aGlzLnNnck1vdXNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvLyBmb3Igd2lkZSB0ZXJtaW5hbHNcbiAgICAgICAgICAgICAgICAvLyBkb2VzIG5vdCBhZGQgMzIgdG8gZmllbGRzXG4gICAgICAgICAgICAgICAgLy8gcHJlc3M6IF5bWzxiO3g7eU1cbiAgICAgICAgICAgICAgICAvLyByZWxlYXNlOiBeW1s8Yjt4O3ltXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDEwMTU6XG4gICAgICAgICAgICAgICAgdGhpcy51cnh2dE1vdXNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvLyBmb3Igd2lkZSB0ZXJtaW5hbHNcbiAgICAgICAgICAgICAgICAvLyBudW1iZXJzIGZvciBmaWVsZHNcbiAgICAgICAgICAgICAgICAvLyBwcmVzczogXltbYjt4O3lNXG4gICAgICAgICAgICAgICAgLy8gbW90aW9uOiBeW1tiO3g7eVRcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjU6XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJzb3JIaWRkZW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTA0OTpcbiAgICAgICAgICAgICAgICAvL3RoaXMuc2F2ZUN1cnNvcigpO1xuICAgICAgICAgICAgICAgIDsgLy8gRkFMTC1USFJPVUdIXG4gICAgICAgICAgICBjYXNlIDQ3OiAvLyBhbHQgc2NyZWVuIGJ1ZmZlclxuICAgICAgICAgICAgY2FzZSAxMDQ3OlxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5ub3JtYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vcm1hbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVzOiB0aGlzLmxpbmVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgeWJhc2U6IHRoaXMueWJhc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB5ZGlzcDogdGhpcy55ZGlzcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHRoaXMueCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHRoaXMueSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbFRvcDogdGhpcy5zY3JvbGxUb3AsXG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxCb3R0b206IHRoaXMuc2Nyb2xsQm90dG9tLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFiczogdGhpcy50YWJzXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3JtYWwgPSBub3JtYWw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvd0N1cnNvcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn07XG4vKipcbiAqIENTSSBQbSBsICBSZXNldCBNb2RlIChSTSkuXG4gKiAgICAgUHMgPSAyICAtPiBLZXlib2FyZCBBY3Rpb24gTW9kZSAoQU0pLlxuICogICAgIFBzID0gNCAgLT4gUmVwbGFjZSBNb2RlIChJUk0pLlxuICogICAgIFBzID0gMSAyICAtPiBTZW5kL3JlY2VpdmUgKFNSTSkuXG4gKiAgICAgUHMgPSAyIDAgIC0+IE5vcm1hbCBMaW5lZmVlZCAoTE5NKS5cbiAqIENTSSA/IFBtIGxcbiAqICAgREVDIFByaXZhdGUgTW9kZSBSZXNldCAoREVDUlNUKS5cbiAqICAgICBQcyA9IDEgIC0+IE5vcm1hbCBDdXJzb3IgS2V5cyAoREVDQ0tNKS5cbiAqICAgICBQcyA9IDIgIC0+IERlc2lnbmF0ZSBWVDUyIG1vZGUgKERFQ0FOTSkuXG4gKiAgICAgUHMgPSAzICAtPiA4MCBDb2x1bW4gTW9kZSAoREVDQ09MTSkuXG4gKiAgICAgUHMgPSA0ICAtPiBKdW1wIChGYXN0KSBTY3JvbGwgKERFQ1NDTE0pLlxuICogICAgIFBzID0gNSAgLT4gTm9ybWFsIFZpZGVvIChERUNTQ05NKS5cbiAqICAgICBQcyA9IDYgIC0+IE5vcm1hbCBDdXJzb3IgTW9kZSAoREVDT00pLlxuICogICAgIFBzID0gNyAgLT4gTm8gV3JhcGFyb3VuZCBNb2RlIChERUNBV00pLlxuICogICAgIFBzID0gOCAgLT4gTm8gQXV0by1yZXBlYXQgS2V5cyAoREVDQVJNKS5cbiAqICAgICBQcyA9IDkgIC0+IERvbid0IHNlbmQgTW91c2UgWCAmIFkgb24gYnV0dG9uIHByZXNzLlxuICogICAgIFBzID0gMSAwICAtPiBIaWRlIHRvb2xiYXIgKHJ4dnQpLlxuICogICAgIFBzID0gMSAyICAtPiBTdG9wIEJsaW5raW5nIEN1cnNvciAoYXR0NjEwKS5cbiAqICAgICBQcyA9IDEgOCAgLT4gRG9uJ3QgcHJpbnQgZm9ybSBmZWVkIChERUNQRkYpLlxuICogICAgIFBzID0gMSA5ICAtPiBMaW1pdCBwcmludCB0byBzY3JvbGxpbmcgcmVnaW9uIChERUNQRVgpLlxuICogICAgIFBzID0gMiA1ICAtPiBIaWRlIEN1cnNvciAoREVDVENFTSkuXG4gKiAgICAgUHMgPSAzIDAgIC0+IERvbid0IHNob3cgc2Nyb2xsYmFyIChyeHZ0KS5cbiAqICAgICBQcyA9IDMgNSAgLT4gRGlzYWJsZSBmb250LXNoaWZ0aW5nIGZ1bmN0aW9ucyAocnh2dCkuXG4gKiAgICAgUHMgPSA0IDAgIC0+IERpc2FsbG93IDgwIC0+IDEzMiBNb2RlLlxuICogICAgIFBzID0gNCAxICAtPiBObyBtb3JlKDEpIGZpeCAoc2VlIGN1cnNlcyByZXNvdXJjZSkuXG4gKiAgICAgUHMgPSA0IDIgIC0+IERpc2FibGUgTmF0aW9uIFJlcGxhY2VtZW50IENoYXJhY3RlciBzZXRzIChERUMtXG4gKiAgICAgTlJDTSkuXG4gKiAgICAgUHMgPSA0IDQgIC0+IFR1cm4gT2ZmIE1hcmdpbiBCZWxsLlxuICogICAgIFBzID0gNCA1ICAtPiBObyBSZXZlcnNlLXdyYXBhcm91bmQgTW9kZS5cbiAqICAgICBQcyA9IDQgNiAgLT4gU3RvcCBMb2dnaW5nLiAgKFRoaXMgaXMgbm9ybWFsbHkgZGlzYWJsZWQgYnkgYVxuICogICAgIGNvbXBpbGUtdGltZSBvcHRpb24pLlxuICogICAgIFBzID0gNCA3ICAtPiBVc2UgTm9ybWFsIFNjcmVlbiBCdWZmZXIuXG4gKiAgICAgUHMgPSA2IDYgIC0+IE51bWVyaWMga2V5cGFkIChERUNOS00pLlxuICogICAgIFBzID0gNiA3ICAtPiBCYWNrYXJyb3cga2V5IHNlbmRzIGRlbGV0ZSAoREVDQktNKS5cbiAqICAgICBQcyA9IDEgMCAwIDAgIC0+IERvbid0IHNlbmQgTW91c2UgWCAmIFkgb24gYnV0dG9uIHByZXNzIGFuZFxuICogICAgIHJlbGVhc2UuICBTZWUgdGhlIHNlY3Rpb24gTW91c2UgVHJhY2tpbmcuXG4gKiAgICAgUHMgPSAxIDAgMCAxICAtPiBEb24ndCB1c2UgSGlsaXRlIE1vdXNlIFRyYWNraW5nLlxuICogICAgIFBzID0gMSAwIDAgMiAgLT4gRG9uJ3QgdXNlIENlbGwgTW90aW9uIE1vdXNlIFRyYWNraW5nLlxuICogICAgIFBzID0gMSAwIDAgMyAgLT4gRG9uJ3QgdXNlIEFsbCBNb3Rpb24gTW91c2UgVHJhY2tpbmcuXG4gKiAgICAgUHMgPSAxIDAgMCA0ICAtPiBEb24ndCBzZW5kIEZvY3VzSW4vRm9jdXNPdXQgZXZlbnRzLlxuICogICAgIFBzID0gMSAwIDAgNSAgLT4gRGlzYWJsZSBFeHRlbmRlZCBNb3VzZSBNb2RlLlxuICogICAgIFBzID0gMSAwIDEgMCAgLT4gRG9uJ3Qgc2Nyb2xsIHRvIGJvdHRvbSBvbiB0dHkgb3V0cHV0XG4gKiAgICAgKHJ4dnQpLlxuICogICAgIFBzID0gMSAwIDEgMSAgLT4gRG9uJ3Qgc2Nyb2xsIHRvIGJvdHRvbSBvbiBrZXkgcHJlc3MgKHJ4dnQpLlxuICogICAgIFBzID0gMSAwIDMgNCAgLT4gRG9uJ3QgaW50ZXJwcmV0IFwibWV0YVwiIGtleS4gIChUaGlzIGRpc2FibGVzXG4gKiAgICAgdGhlIGVpZ2h0Qml0SW5wdXQgcmVzb3VyY2UpLlxuICogICAgIFBzID0gMSAwIDMgNSAgLT4gRGlzYWJsZSBzcGVjaWFsIG1vZGlmaWVycyBmb3IgQWx0IGFuZCBOdW0tXG4gKiAgICAgTG9jayBrZXlzLiAgKFRoaXMgZGlzYWJsZXMgdGhlIG51bUxvY2sgcmVzb3VyY2UpLlxuICogICAgIFBzID0gMSAwIDMgNiAgLT4gRG9uJ3Qgc2VuZCBFU0MgIHdoZW4gTWV0YSBtb2RpZmllcyBhIGtleS5cbiAqICAgICAoVGhpcyBkaXNhYmxlcyB0aGUgbWV0YVNlbmRzRXNjYXBlIHJlc291cmNlKS5cbiAqICAgICBQcyA9IDEgMCAzIDcgIC0+IFNlbmQgVlQyMjAgUmVtb3ZlIGZyb20gdGhlIGVkaXRpbmcta2V5cGFkXG4gKiAgICAgRGVsZXRlIGtleS5cbiAqICAgICBQcyA9IDEgMCAzIDkgIC0+IERvbid0IHNlbmQgRVNDICB3aGVuIEFsdCBtb2RpZmllcyBhIGtleS5cbiAqICAgICAoVGhpcyBkaXNhYmxlcyB0aGUgYWx0U2VuZHNFc2NhcGUgcmVzb3VyY2UpLlxuICogICAgIFBzID0gMSAwIDQgMCAgLT4gRG8gbm90IGtlZXAgc2VsZWN0aW9uIHdoZW4gbm90IGhpZ2hsaWdodGVkLlxuICogICAgIChUaGlzIGRpc2FibGVzIHRoZSBrZWVwU2VsZWN0aW9uIHJlc291cmNlKS5cbiAqICAgICBQcyA9IDEgMCA0IDEgIC0+IFVzZSB0aGUgUFJJTUFSWSBzZWxlY3Rpb24uICAoVGhpcyBkaXNhYmxlc1xuICogICAgIHRoZSBzZWxlY3RUb0NsaXBib2FyZCByZXNvdXJjZSkuXG4gKiAgICAgUHMgPSAxIDAgNCAyICAtPiBEaXNhYmxlIFVyZ2VuY3kgd2luZG93IG1hbmFnZXIgaGludCB3aGVuXG4gKiAgICAgQ29udHJvbC1HIGlzIHJlY2VpdmVkLiAgKFRoaXMgZGlzYWJsZXMgdGhlIGJlbGxJc1VyZ2VudFxuICogICAgIHJlc291cmNlKS5cbiAqICAgICBQcyA9IDEgMCA0IDMgIC0+IERpc2FibGUgcmFpc2luZyBvZiB0aGUgd2luZG93IHdoZW4gQ29udHJvbC1cbiAqICAgICBHIGlzIHJlY2VpdmVkLiAgKFRoaXMgZGlzYWJsZXMgdGhlIHBvcE9uQmVsbCByZXNvdXJjZSkuXG4gKiAgICAgUHMgPSAxIDAgNCA3ICAtPiBVc2UgTm9ybWFsIFNjcmVlbiBCdWZmZXIsIGNsZWFyaW5nIHNjcmVlblxuICogICAgIGZpcnN0IGlmIGluIHRoZSBBbHRlcm5hdGUgU2NyZWVuLiAgKFRoaXMgbWF5IGJlIGRpc2FibGVkIGJ5XG4gKiAgICAgdGhlIHRpdGVJbmhpYml0IHJlc291cmNlKS5cbiAqICAgICBQcyA9IDEgMCA0IDggIC0+IFJlc3RvcmUgY3Vyc29yIGFzIGluIERFQ1JDLiAgKFRoaXMgbWF5IGJlXG4gKiAgICAgZGlzYWJsZWQgYnkgdGhlIHRpdGVJbmhpYml0IHJlc291cmNlKS5cbiAqICAgICBQcyA9IDEgMCA0IDkgIC0+IFVzZSBOb3JtYWwgU2NyZWVuIEJ1ZmZlciBhbmQgcmVzdG9yZSBjdXJzb3JcbiAqICAgICBhcyBpbiBERUNSQy4gIChUaGlzIG1heSBiZSBkaXNhYmxlZCBieSB0aGUgdGl0ZUluaGliaXRcbiAqICAgICByZXNvdXJjZSkuICBUaGlzIGNvbWJpbmVzIHRoZSBlZmZlY3RzIG9mIHRoZSAxIDAgNCA3ICBhbmQgMSAwXG4gKiAgICAgNCA4ICBtb2Rlcy4gIFVzZSB0aGlzIHdpdGggdGVybWluZm8tYmFzZWQgYXBwbGljYXRpb25zIHJhdGhlclxuICogICAgIHRoYW4gdGhlIDQgNyAgbW9kZS5cbiAqICAgICBQcyA9IDEgMCA1IDAgIC0+IFJlc2V0IHRlcm1pbmZvL3Rlcm1jYXAgZnVuY3Rpb24ta2V5IG1vZGUuXG4gKiAgICAgUHMgPSAxIDAgNSAxICAtPiBSZXNldCBTdW4gZnVuY3Rpb24ta2V5IG1vZGUuXG4gKiAgICAgUHMgPSAxIDAgNSAyICAtPiBSZXNldCBIUCBmdW5jdGlvbi1rZXkgbW9kZS5cbiAqICAgICBQcyA9IDEgMCA1IDMgIC0+IFJlc2V0IFNDTyBmdW5jdGlvbi1rZXkgbW9kZS5cbiAqICAgICBQcyA9IDEgMCA2IDAgIC0+IFJlc2V0IGxlZ2FjeSBrZXlib2FyZCBlbXVsYXRpb24gKFgxMVI2KS5cbiAqICAgICBQcyA9IDEgMCA2IDEgIC0+IFJlc2V0IGtleWJvYXJkIGVtdWxhdGlvbiB0byBTdW4vUEMgc3R5bGUuXG4gKiAgICAgUHMgPSAyIDAgMCA0ICAtPiBSZXNldCBicmFja2V0ZWQgcGFzdGUgbW9kZS5cbiAqL1xuVGVybWluYWwucHJvdG90eXBlLnJlc2V0TW9kZSA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICBpZiAodHlwZW9mIHBhcmFtcyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgdmFyIGwgPSBwYXJhbXMubGVuZ3RoLCBpID0gMDtcbiAgICAgICAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXRNb2RlKHBhcmFtc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMucHJlZml4KSB7XG4gICAgICAgIHN3aXRjaCAocGFyYW1zKSB7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgdGhpcy5pbnNlcnRNb2RlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDIwOlxuICAgICAgICAgICAgICAgIC8vdGhpcy5jb252ZXJ0RW9sID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5wcmVmaXggPT09ICc/Jykge1xuICAgICAgICBzd2l0Y2ggKHBhcmFtcykge1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHRoaXMuYXBwbGljYXRpb25DdXJzb3IgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb2xzID09PSAxMzIgJiYgdGhpcy5zYXZlZENvbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNpemUodGhpcy5zYXZlZENvbHMsIHRoaXMucm93cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnNhdmVkQ29scztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICB0aGlzLm9yaWdpbk1vZGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICB0aGlzLndyYXBhcm91bmRNb2RlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgIC8vIHRoaXMuY3Vyc29yQmxpbmsgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNjY6XG4gICAgICAgICAgICAgICAgdGhpcy5sb2coJ1N3aXRjaGluZyBiYWNrIHRvIG5vcm1hbCBrZXlwYWQuJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBsaWNhdGlvbktleXBhZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld3BvcnQuc3luY1Njcm9sbEFyZWEoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgOTogLy8gWDEwIE1vdXNlXG4gICAgICAgICAgICBjYXNlIDEwMDA6IC8vIHZ0MjAwIG1vdXNlXG4gICAgICAgICAgICBjYXNlIDEwMDI6IC8vIGJ1dHRvbiBldmVudCBtb3VzZVxuICAgICAgICAgICAgY2FzZSAxMDAzOlxuICAgICAgICAgICAgICAgIHRoaXMueDEwTW91c2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLnZ0MjAwTW91c2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLm5vcm1hbE1vdXNlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5tb3VzZUV2ZW50cyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5jdXJzb3IgPSAnJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTAwNDpcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmRGb2N1cyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxMDA1OlxuICAgICAgICAgICAgICAgIHRoaXMudXRmTW91c2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTAwNjpcbiAgICAgICAgICAgICAgICB0aGlzLnNnck1vdXNlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDEwMTU6XG4gICAgICAgICAgICAgICAgdGhpcy51cnh2dE1vdXNlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI1OlxuICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29ySGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTA0OTpcbiAgICAgICAgICAgICAgICA7IC8vIEZBTEwtVEhST1VHSFxuICAgICAgICAgICAgY2FzZSA0NzogLy8gbm9ybWFsIHNjcmVlbiBidWZmZXJcbiAgICAgICAgICAgIGNhc2UgMTA0NzpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ub3JtYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5lcyA9IHRoaXMubm9ybWFsLmxpbmVzO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnliYXNlID0gdGhpcy5ub3JtYWwueWJhc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMueWRpc3AgPSB0aGlzLm5vcm1hbC55ZGlzcDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy54ID0gdGhpcy5ub3JtYWwueDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy55ID0gdGhpcy5ub3JtYWwueTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxUb3AgPSB0aGlzLm5vcm1hbC5zY3JvbGxUb3A7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsQm90dG9tID0gdGhpcy5ub3JtYWwuc2Nyb2xsQm90dG9tO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRhYnMgPSB0aGlzLm5vcm1hbC50YWJzO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vcm1hbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIChwYXJhbXMgPT09IDEwNDkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gICB0aGlzLnggPSB0aGlzLnNhdmVkWDtcbiAgICAgICAgICAgICAgICAgICAgLy8gICB0aGlzLnkgPSB0aGlzLnNhdmVkWTtcbiAgICAgICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2goMCwgdGhpcy5yb3dzIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvd0N1cnNvcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn07XG4vKipcbiAqIENTSSBQcyA7IFBzIHJcbiAqICAgU2V0IFNjcm9sbGluZyBSZWdpb24gW3RvcDtib3R0b21dIChkZWZhdWx0ID0gZnVsbCBzaXplIG9mIHdpbi1cbiAqICAgZG93KSAoREVDU1RCTSkuXG4gKiBDU0kgPyBQbSByXG4gKi9cblRlcm1pbmFsLnByb3RvdHlwZS5zZXRTY3JvbGxSZWdpb24gPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgaWYgKHRoaXMucHJlZml4KVxuICAgICAgICByZXR1cm47XG4gICAgdGhpcy5zY3JvbGxUb3AgPSAocGFyYW1zWzBdIHx8IDEpIC0gMTtcbiAgICB0aGlzLnNjcm9sbEJvdHRvbSA9IChwYXJhbXNbMV0gfHwgdGhpcy5yb3dzKSAtIDE7XG4gICAgdGhpcy54ID0gMDtcbiAgICB0aGlzLnkgPSAwO1xufTtcbi8qKlxuICogQ1NJIHNcbiAqICAgU2F2ZSBjdXJzb3IgKEFOU0kuU1lTKS5cbiAqL1xuVGVybWluYWwucHJvdG90eXBlLnNhdmVDdXJzb3IgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgdGhpcy5zYXZlZFggPSB0aGlzLng7XG4gICAgdGhpcy5zYXZlZFkgPSB0aGlzLnk7XG59O1xuLyoqXG4gKiBDU0kgdVxuICogICBSZXN0b3JlIGN1cnNvciAoQU5TSS5TWVMpLlxuICovXG5UZXJtaW5hbC5wcm90b3R5cGUucmVzdG9yZUN1cnNvciA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICB0aGlzLnggPSB0aGlzLnNhdmVkWCB8fCAwO1xuICAgIHRoaXMueSA9IHRoaXMuc2F2ZWRZIHx8IDA7XG59O1xuLyoqXG4gKiBMZXNzZXIgVXNlZFxuICovXG4vKipcbiAqIENTSSBQcyBJXG4gKiAgIEN1cnNvciBGb3J3YXJkIFRhYnVsYXRpb24gUHMgdGFiIHN0b3BzIChkZWZhdWx0ID0gMSkgKENIVCkuXG4gKi9cblRlcm1pbmFsLnByb3RvdHlwZS5jdXJzb3JGb3J3YXJkVGFiID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgIHZhciBwYXJhbSA9IHBhcmFtc1swXSB8fCAxO1xuICAgIHdoaWxlIChwYXJhbS0tKSB7XG4gICAgICAgIHRoaXMueCA9IHRoaXMubmV4dFN0b3AoKTtcbiAgICB9XG59O1xuLyoqXG4gKiBDU0kgUHMgUyAgU2Nyb2xsIHVwIFBzIGxpbmVzIChkZWZhdWx0ID0gMSkgKFNVKS5cbiAqL1xuVGVybWluYWwucHJvdG90eXBlLnNjcm9sbFVwID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgIHZhciBwYXJhbSA9IHBhcmFtc1swXSB8fCAxO1xuICAgIHdoaWxlIChwYXJhbS0tKSB7XG4gICAgICAgIHRoaXMubGluZXMuc3BsaWNlKHRoaXMueWJhc2UgKyB0aGlzLnNjcm9sbFRvcCwgMSk7XG4gICAgICAgIHRoaXMubGluZXMuc3BsaWNlKHRoaXMueWJhc2UgKyB0aGlzLnNjcm9sbEJvdHRvbSwgMCwgdGhpcy5ibGFua0xpbmUoKSk7XG4gICAgfVxuICAgIC8vIHRoaXMubWF4UmFuZ2UoKTtcbiAgICB0aGlzLnVwZGF0ZVJhbmdlKHRoaXMuc2Nyb2xsVG9wKTtcbiAgICB0aGlzLnVwZGF0ZVJhbmdlKHRoaXMuc2Nyb2xsQm90dG9tKTtcbn07XG4vKipcbiAqIENTSSBQcyBUICBTY3JvbGwgZG93biBQcyBsaW5lcyAoZGVmYXVsdCA9IDEpIChTRCkuXG4gKi9cblRlcm1pbmFsLnByb3RvdHlwZS5zY3JvbGxEb3duID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgIHZhciBwYXJhbSA9IHBhcmFtc1swXSB8fCAxO1xuICAgIHdoaWxlIChwYXJhbS0tKSB7XG4gICAgICAgIHRoaXMubGluZXMuc3BsaWNlKHRoaXMueWJhc2UgKyB0aGlzLnNjcm9sbEJvdHRvbSwgMSk7XG4gICAgICAgIHRoaXMubGluZXMuc3BsaWNlKHRoaXMueWJhc2UgKyB0aGlzLnNjcm9sbFRvcCwgMCwgdGhpcy5ibGFua0xpbmUoKSk7XG4gICAgfVxuICAgIC8vIHRoaXMubWF4UmFuZ2UoKTtcbiAgICB0aGlzLnVwZGF0ZVJhbmdlKHRoaXMuc2Nyb2xsVG9wKTtcbiAgICB0aGlzLnVwZGF0ZVJhbmdlKHRoaXMuc2Nyb2xsQm90dG9tKTtcbn07XG4vKipcbiAqIENTSSBQcyA7IFBzIDsgUHMgOyBQcyA7IFBzIFRcbiAqICAgSW5pdGlhdGUgaGlnaGxpZ2h0IG1vdXNlIHRyYWNraW5nLiAgUGFyYW1ldGVycyBhcmVcbiAqICAgW2Z1bmM7c3RhcnR4O3N0YXJ0eTtmaXJzdHJvdztsYXN0cm93XS4gIFNlZSB0aGUgc2VjdGlvbiBNb3VzZVxuICogICBUcmFja2luZy5cbiAqL1xuVGVybWluYWwucHJvdG90eXBlLmluaXRNb3VzZVRyYWNraW5nID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgIC8vIFJlbGV2YW50OiBERUNTRVQgMTAwMVxufTtcbi8qKlxuICogQ1NJID4gUHM7IFBzIFRcbiAqICAgUmVzZXQgb25lIG9yIG1vcmUgZmVhdHVyZXMgb2YgdGhlIHRpdGxlIG1vZGVzIHRvIHRoZSBkZWZhdWx0XG4gKiAgIHZhbHVlLiAgTm9ybWFsbHksIFwicmVzZXRcIiBkaXNhYmxlcyB0aGUgZmVhdHVyZS4gIEl0IGlzIHBvc3NpLVxuICogICBibGUgdG8gZGlzYWJsZSB0aGUgYWJpbGl0eSB0byByZXNldCBmZWF0dXJlcyBieSBjb21waWxpbmcgYVxuICogICBkaWZmZXJlbnQgZGVmYXVsdCBmb3IgdGhlIHRpdGxlIG1vZGVzIGludG8geHRlcm0uXG4gKiAgICAgUHMgPSAwICAtPiBEbyBub3Qgc2V0IHdpbmRvdy9pY29uIGxhYmVscyB1c2luZyBoZXhhZGVjaW1hbC5cbiAqICAgICBQcyA9IDEgIC0+IERvIG5vdCBxdWVyeSB3aW5kb3cvaWNvbiBsYWJlbHMgdXNpbmcgaGV4YWRlY2ktXG4gKiAgICAgbWFsLlxuICogICAgIFBzID0gMiAgLT4gRG8gbm90IHNldCB3aW5kb3cvaWNvbiBsYWJlbHMgdXNpbmcgVVRGLTguXG4gKiAgICAgUHMgPSAzICAtPiBEbyBub3QgcXVlcnkgd2luZG93L2ljb24gbGFiZWxzIHVzaW5nIFVURi04LlxuICogICAoU2VlIGRpc2N1c3Npb24gb2YgXCJUaXRsZSBNb2Rlc1wiKS5cbiAqL1xuVGVybWluYWwucHJvdG90eXBlLnJlc2V0VGl0bGVNb2RlcyA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICA7XG59O1xuLyoqXG4gKiBDU0kgUHMgWiAgQ3Vyc29yIEJhY2t3YXJkIFRhYnVsYXRpb24gUHMgdGFiIHN0b3BzIChkZWZhdWx0ID0gMSkgKENCVCkuXG4gKi9cblRlcm1pbmFsLnByb3RvdHlwZS5jdXJzb3JCYWNrd2FyZFRhYiA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICB2YXIgcGFyYW0gPSBwYXJhbXNbMF0gfHwgMTtcbiAgICB3aGlsZSAocGFyYW0tLSkge1xuICAgICAgICB0aGlzLnggPSB0aGlzLnByZXZTdG9wKCk7XG4gICAgfVxufTtcbi8qKlxuICogQ1NJIFBzIGIgIFJlcGVhdCB0aGUgcHJlY2VkaW5nIGdyYXBoaWMgY2hhcmFjdGVyIFBzIHRpbWVzIChSRVApLlxuICovXG5UZXJtaW5hbC5wcm90b3R5cGUucmVwZWF0UHJlY2VkaW5nQ2hhcmFjdGVyID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgIHZhciBwYXJhbSA9IHBhcmFtc1swXSB8fCAxLCBsaW5lID0gdGhpcy5saW5lc1t0aGlzLnliYXNlICsgdGhpcy55XSwgY2ggPSBsaW5lW3RoaXMueCAtIDFdIHx8IFt0aGlzLmRlZkF0dHIsICcgJywgMV07XG4gICAgd2hpbGUgKHBhcmFtLS0pXG4gICAgICAgIGxpbmVbdGhpcy54KytdID0gY2g7XG59O1xuLyoqXG4gKiBDU0kgUHMgZyAgVGFiIENsZWFyIChUQkMpLlxuICogICAgIFBzID0gMCAgLT4gQ2xlYXIgQ3VycmVudCBDb2x1bW4gKGRlZmF1bHQpLlxuICogICAgIFBzID0gMyAgLT4gQ2xlYXIgQWxsLlxuICogUG90ZW50aWFsbHk6XG4gKiAgIFBzID0gMiAgLT4gQ2xlYXIgU3RvcHMgb24gTGluZS5cbiAqICAgaHR0cDovL3Z0MTAwLm5ldC9hbm5hcmJvci9hYWEtdWcvc2VjdGlvbjYuaHRtbFxuICovXG5UZXJtaW5hbC5wcm90b3R5cGUudGFiQ2xlYXIgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgdmFyIHBhcmFtID0gcGFyYW1zWzBdO1xuICAgIGlmIChwYXJhbSA8PSAwKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnRhYnNbdGhpcy54XTtcbiAgICB9XG4gICAgZWxzZSBpZiAocGFyYW0gPT09IDMpIHtcbiAgICAgICAgdGhpcy50YWJzID0ge307XG4gICAgfVxufTtcbi8qKlxuICogQ1NJIFBtIGkgIE1lZGlhIENvcHkgKE1DKS5cbiAqICAgICBQcyA9IDAgIC0+IFByaW50IHNjcmVlbiAoZGVmYXVsdCkuXG4gKiAgICAgUHMgPSA0ICAtPiBUdXJuIG9mZiBwcmludGVyIGNvbnRyb2xsZXIgbW9kZS5cbiAqICAgICBQcyA9IDUgIC0+IFR1cm4gb24gcHJpbnRlciBjb250cm9sbGVyIG1vZGUuXG4gKiBDU0kgPyBQbSBpXG4gKiAgIE1lZGlhIENvcHkgKE1DLCBERUMtc3BlY2lmaWMpLlxuICogICAgIFBzID0gMSAgLT4gUHJpbnQgbGluZSBjb250YWluaW5nIGN1cnNvci5cbiAqICAgICBQcyA9IDQgIC0+IFR1cm4gb2ZmIGF1dG9wcmludCBtb2RlLlxuICogICAgIFBzID0gNSAgLT4gVHVybiBvbiBhdXRvcHJpbnQgbW9kZS5cbiAqICAgICBQcyA9IDEgIDAgIC0+IFByaW50IGNvbXBvc2VkIGRpc3BsYXksIGlnbm9yZXMgREVDUEVYLlxuICogICAgIFBzID0gMSAgMSAgLT4gUHJpbnQgYWxsIHBhZ2VzLlxuICovXG5UZXJtaW5hbC5wcm90b3R5cGUubWVkaWFDb3B5ID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgIDtcbn07XG4vKipcbiAqIENTSSA+IFBzOyBQcyBtXG4gKiAgIFNldCBvciByZXNldCByZXNvdXJjZS12YWx1ZXMgdXNlZCBieSB4dGVybSB0byBkZWNpZGUgd2hldGhlclxuICogICB0byBjb25zdHJ1Y3QgZXNjYXBlIHNlcXVlbmNlcyBob2xkaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZVxuICogICBtb2RpZmllcnMgcHJlc3NlZCB3aXRoIGEgZ2l2ZW4ga2V5LiAgVGhlIGZpcnN0IHBhcmFtZXRlciBpZGVuLVxuICogICB0aWZpZXMgdGhlIHJlc291cmNlIHRvIHNldC9yZXNldC4gIFRoZSBzZWNvbmQgcGFyYW1ldGVyIGlzIHRoZVxuICogICB2YWx1ZSB0byBhc3NpZ24gdG8gdGhlIHJlc291cmNlLiAgSWYgdGhlIHNlY29uZCBwYXJhbWV0ZXIgaXNcbiAqICAgb21pdHRlZCwgdGhlIHJlc291cmNlIGlzIHJlc2V0IHRvIGl0cyBpbml0aWFsIHZhbHVlLlxuICogICAgIFBzID0gMSAgLT4gbW9kaWZ5Q3Vyc29yS2V5cy5cbiAqICAgICBQcyA9IDIgIC0+IG1vZGlmeUZ1bmN0aW9uS2V5cy5cbiAqICAgICBQcyA9IDQgIC0+IG1vZGlmeU90aGVyS2V5cy5cbiAqICAgSWYgbm8gcGFyYW1ldGVycyBhcmUgZ2l2ZW4sIGFsbCByZXNvdXJjZXMgYXJlIHJlc2V0IHRvIHRoZWlyXG4gKiAgIGluaXRpYWwgdmFsdWVzLlxuICovXG5UZXJtaW5hbC5wcm90b3R5cGUuc2V0UmVzb3VyY2VzID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgIDtcbn07XG4vKipcbiAqIENTSSA+IFBzIG5cbiAqICAgRGlzYWJsZSBtb2RpZmllcnMgd2hpY2ggbWF5IGJlIGVuYWJsZWQgdmlhIHRoZSBDU0kgPiBQczsgUHMgbVxuICogICBzZXF1ZW5jZS4gIFRoaXMgY29ycmVzcG9uZHMgdG8gYSByZXNvdXJjZSB2YWx1ZSBvZiBcIi0xXCIsIHdoaWNoXG4gKiAgIGNhbm5vdCBiZSBzZXQgd2l0aCB0aGUgb3RoZXIgc2VxdWVuY2UuICBUaGUgcGFyYW1ldGVyIGlkZW50aS1cbiAqICAgZmllcyB0aGUgcmVzb3VyY2UgdG8gYmUgZGlzYWJsZWQ6XG4gKiAgICAgUHMgPSAxICAtPiBtb2RpZnlDdXJzb3JLZXlzLlxuICogICAgIFBzID0gMiAgLT4gbW9kaWZ5RnVuY3Rpb25LZXlzLlxuICogICAgIFBzID0gNCAgLT4gbW9kaWZ5T3RoZXJLZXlzLlxuICogICBJZiB0aGUgcGFyYW1ldGVyIGlzIG9taXR0ZWQsIG1vZGlmeUZ1bmN0aW9uS2V5cyBpcyBkaXNhYmxlZC5cbiAqICAgV2hlbiBtb2RpZnlGdW5jdGlvbktleXMgaXMgZGlzYWJsZWQsIHh0ZXJtIHVzZXMgdGhlIG1vZGlmaWVyXG4gKiAgIGtleXMgdG8gbWFrZSBhbiBleHRlbmRlZCBzZXF1ZW5jZSBvZiBmdW5jdGlvbnMgcmF0aGVyIHRoYW5cbiAqICAgYWRkaW5nIGEgcGFyYW1ldGVyIHRvIGVhY2ggZnVuY3Rpb24ga2V5IHRvIGRlbm90ZSB0aGUgbW9kaS1cbiAqICAgZmllcnMuXG4gKi9cblRlcm1pbmFsLnByb3RvdHlwZS5kaXNhYmxlTW9kaWZpZXJzID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgIDtcbn07XG4vKipcbiAqIENTSSA+IFBzIHBcbiAqICAgU2V0IHJlc291cmNlIHZhbHVlIHBvaW50ZXJNb2RlLiAgVGhpcyBpcyB1c2VkIGJ5IHh0ZXJtIHRvXG4gKiAgIGRlY2lkZSB3aGV0aGVyIHRvIGhpZGUgdGhlIHBvaW50ZXIgY3Vyc29yIGFzIHRoZSB1c2VyIHR5cGVzLlxuICogICBWYWxpZCB2YWx1ZXMgZm9yIHRoZSBwYXJhbWV0ZXI6XG4gKiAgICAgUHMgPSAwICAtPiBuZXZlciBoaWRlIHRoZSBwb2ludGVyLlxuICogICAgIFBzID0gMSAgLT4gaGlkZSBpZiB0aGUgbW91c2UgdHJhY2tpbmcgbW9kZSBpcyBub3QgZW5hYmxlZC5cbiAqICAgICBQcyA9IDIgIC0+IGFsd2F5cyBoaWRlIHRoZSBwb2ludGVyLiAgSWYgbm8gcGFyYW1ldGVyIGlzXG4gKiAgICAgZ2l2ZW4sIHh0ZXJtIHVzZXMgdGhlIGRlZmF1bHQsIHdoaWNoIGlzIDEgLlxuICovXG5UZXJtaW5hbC5wcm90b3R5cGUuc2V0UG9pbnRlck1vZGUgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgO1xufTtcbi8qKlxuICogQ1NJICEgcCAgIFNvZnQgdGVybWluYWwgcmVzZXQgKERFQ1NUUikuXG4gKiBodHRwOi8vdnQxMDAubmV0L2RvY3MvdnQyMjAtcm0vdGFibGU0LTEwLmh0bWxcbiAqL1xuVGVybWluYWwucHJvdG90eXBlLnNvZnRSZXNldCA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICB0aGlzLmN1cnNvckhpZGRlbiA9IGZhbHNlO1xuICAgIHRoaXMuaW5zZXJ0TW9kZSA9IGZhbHNlO1xuICAgIHRoaXMub3JpZ2luTW9kZSA9IGZhbHNlO1xuICAgIHRoaXMud3JhcGFyb3VuZE1vZGUgPSBmYWxzZTsgLy8gYXV0b3dyYXBcbiAgICB0aGlzLmFwcGxpY2F0aW9uS2V5cGFkID0gZmFsc2U7IC8vID9cbiAgICB0aGlzLnZpZXdwb3J0LnN5bmNTY3JvbGxBcmVhKCk7XG4gICAgdGhpcy5hcHBsaWNhdGlvbkN1cnNvciA9IGZhbHNlO1xuICAgIHRoaXMuc2Nyb2xsVG9wID0gMDtcbiAgICB0aGlzLnNjcm9sbEJvdHRvbSA9IHRoaXMucm93cyAtIDE7XG4gICAgdGhpcy5jdXJBdHRyID0gdGhpcy5kZWZBdHRyO1xuICAgIHRoaXMueCA9IHRoaXMueSA9IDA7IC8vID9cbiAgICB0aGlzLmNoYXJzZXQgPSBudWxsO1xuICAgIHRoaXMuZ2xldmVsID0gMDsgLy8gPz9cbiAgICB0aGlzLmNoYXJzZXRzID0gW251bGxdOyAvLyA/P1xufTtcbi8qKlxuICogQ1NJIFBzJCBwXG4gKiAgIFJlcXVlc3QgQU5TSSBtb2RlIChERUNSUU0pLiAgRm9yIFZUMzAwIGFuZCB1cCwgcmVwbHkgaXNcbiAqICAgICBDU0kgUHM7IFBtJCB5XG4gKiAgIHdoZXJlIFBzIGlzIHRoZSBtb2RlIG51bWJlciBhcyBpbiBSTSwgYW5kIFBtIGlzIHRoZSBtb2RlXG4gKiAgIHZhbHVlOlxuICogICAgIDAgLSBub3QgcmVjb2duaXplZFxuICogICAgIDEgLSBzZXRcbiAqICAgICAyIC0gcmVzZXRcbiAqICAgICAzIC0gcGVybWFuZW50bHkgc2V0XG4gKiAgICAgNCAtIHBlcm1hbmVudGx5IHJlc2V0XG4gKi9cblRlcm1pbmFsLnByb3RvdHlwZS5yZXF1ZXN0QW5zaU1vZGUgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgO1xufTtcbi8qKlxuICogQ1NJID8gUHMkIHBcbiAqICAgUmVxdWVzdCBERUMgcHJpdmF0ZSBtb2RlIChERUNSUU0pLiAgRm9yIFZUMzAwIGFuZCB1cCwgcmVwbHkgaXNcbiAqICAgICBDU0kgPyBQczsgUG0kIHBcbiAqICAgd2hlcmUgUHMgaXMgdGhlIG1vZGUgbnVtYmVyIGFzIGluIERFQ1NFVCwgUG0gaXMgdGhlIG1vZGUgdmFsdWVcbiAqICAgYXMgaW4gdGhlIEFOU0kgREVDUlFNLlxuICovXG5UZXJtaW5hbC5wcm90b3R5cGUucmVxdWVzdFByaXZhdGVNb2RlID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgIDtcbn07XG4vKipcbiAqIENTSSBQcyA7IFBzIFwiIHBcbiAqICAgU2V0IGNvbmZvcm1hbmNlIGxldmVsIChERUNTQ0wpLiAgVmFsaWQgdmFsdWVzIGZvciB0aGUgZmlyc3RcbiAqICAgcGFyYW1ldGVyOlxuICogICAgIFBzID0gNiAxICAtPiBWVDEwMC5cbiAqICAgICBQcyA9IDYgMiAgLT4gVlQyMDAuXG4gKiAgICAgUHMgPSA2IDMgIC0+IFZUMzAwLlxuICogICBWYWxpZCB2YWx1ZXMgZm9yIHRoZSBzZWNvbmQgcGFyYW1ldGVyOlxuICogICAgIFBzID0gMCAgLT4gOC1iaXQgY29udHJvbHMuXG4gKiAgICAgUHMgPSAxICAtPiA3LWJpdCBjb250cm9scyAoYWx3YXlzIHNldCBmb3IgVlQxMDApLlxuICogICAgIFBzID0gMiAgLT4gOC1iaXQgY29udHJvbHMuXG4gKi9cblRlcm1pbmFsLnByb3RvdHlwZS5zZXRDb25mb3JtYW5jZUxldmVsID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgIDtcbn07XG4vKipcbiAqIENTSSBQcyBxICBMb2FkIExFRHMgKERFQ0xMKS5cbiAqICAgICBQcyA9IDAgIC0+IENsZWFyIGFsbCBMRURTIChkZWZhdWx0KS5cbiAqICAgICBQcyA9IDEgIC0+IExpZ2h0IE51bSBMb2NrLlxuICogICAgIFBzID0gMiAgLT4gTGlnaHQgQ2FwcyBMb2NrLlxuICogICAgIFBzID0gMyAgLT4gTGlnaHQgU2Nyb2xsIExvY2suXG4gKiAgICAgUHMgPSAyICAxICAtPiBFeHRpbmd1aXNoIE51bSBMb2NrLlxuICogICAgIFBzID0gMiAgMiAgLT4gRXh0aW5ndWlzaCBDYXBzIExvY2suXG4gKiAgICAgUHMgPSAyICAzICAtPiBFeHRpbmd1aXNoIFNjcm9sbCBMb2NrLlxuICovXG5UZXJtaW5hbC5wcm90b3R5cGUubG9hZExFRHMgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgO1xufTtcbi8qKlxuICogQ1NJIFBzIFNQIHFcbiAqICAgU2V0IGN1cnNvciBzdHlsZSAoREVDU0NVU1IsIFZUNTIwKS5cbiAqICAgICBQcyA9IDAgIC0+IGJsaW5raW5nIGJsb2NrLlxuICogICAgIFBzID0gMSAgLT4gYmxpbmtpbmcgYmxvY2sgKGRlZmF1bHQpLlxuICogICAgIFBzID0gMiAgLT4gc3RlYWR5IGJsb2NrLlxuICogICAgIFBzID0gMyAgLT4gYmxpbmtpbmcgdW5kZXJsaW5lLlxuICogICAgIFBzID0gNCAgLT4gc3RlYWR5IHVuZGVybGluZS5cbiAqL1xuVGVybWluYWwucHJvdG90eXBlLnNldEN1cnNvclN0eWxlID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgIDtcbn07XG4vKipcbiAqIENTSSBQcyBcIiBxXG4gKiAgIFNlbGVjdCBjaGFyYWN0ZXIgcHJvdGVjdGlvbiBhdHRyaWJ1dGUgKERFQ1NDQSkuICBWYWxpZCB2YWx1ZXNcbiAqICAgZm9yIHRoZSBwYXJhbWV0ZXI6XG4gKiAgICAgUHMgPSAwICAtPiBERUNTRUQgYW5kIERFQ1NFTCBjYW4gZXJhc2UgKGRlZmF1bHQpLlxuICogICAgIFBzID0gMSAgLT4gREVDU0VEIGFuZCBERUNTRUwgY2Fubm90IGVyYXNlLlxuICogICAgIFBzID0gMiAgLT4gREVDU0VEIGFuZCBERUNTRUwgY2FuIGVyYXNlLlxuICovXG5UZXJtaW5hbC5wcm90b3R5cGUuc2V0Q2hhclByb3RlY3Rpb25BdHRyID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgIDtcbn07XG4vKipcbiAqIENTSSA/IFBtIHJcbiAqICAgUmVzdG9yZSBERUMgUHJpdmF0ZSBNb2RlIFZhbHVlcy4gIFRoZSB2YWx1ZSBvZiBQcyBwcmV2aW91c2x5XG4gKiAgIHNhdmVkIGlzIHJlc3RvcmVkLiAgUHMgdmFsdWVzIGFyZSB0aGUgc2FtZSBhcyBmb3IgREVDU0VULlxuICovXG5UZXJtaW5hbC5wcm90b3R5cGUucmVzdG9yZVByaXZhdGVWYWx1ZXMgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgO1xufTtcbi8qKlxuICogQ1NJIFB0OyBQbDsgUGI7IFByOyBQcyQgclxuICogICBDaGFuZ2UgQXR0cmlidXRlcyBpbiBSZWN0YW5ndWxhciBBcmVhIChERUNDQVJBKSwgVlQ0MDAgYW5kIHVwLlxuICogICAgIFB0OyBQbDsgUGI7IFByIGRlbm90ZXMgdGhlIHJlY3RhbmdsZS5cbiAqICAgICBQcyBkZW5vdGVzIHRoZSBTR1IgYXR0cmlidXRlcyB0byBjaGFuZ2U6IDAsIDEsIDQsIDUsIDcuXG4gKiBOT1RFOiB4dGVybSBkb2Vzbid0IGVuYWJsZSB0aGlzIGNvZGUgYnkgZGVmYXVsdC5cbiAqL1xuVGVybWluYWwucHJvdG90eXBlLnNldEF0dHJJblJlY3RhbmdsZSA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICB2YXIgdCA9IHBhcmFtc1swXSwgbCA9IHBhcmFtc1sxXSwgYiA9IHBhcmFtc1syXSwgciA9IHBhcmFtc1szXSwgYXR0ciA9IHBhcmFtc1s0XTtcbiAgICB2YXIgbGluZSwgaTtcbiAgICBmb3IgKDsgdCA8IGIgKyAxOyB0KyspIHtcbiAgICAgICAgbGluZSA9IHRoaXMubGluZXNbdGhpcy55YmFzZSArIHRdO1xuICAgICAgICBmb3IgKGkgPSBsOyBpIDwgcjsgaSsrKSB7XG4gICAgICAgICAgICBsaW5lW2ldID0gW2F0dHIsIGxpbmVbaV1bMV1dO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHRoaXMubWF4UmFuZ2UoKTtcbiAgICB0aGlzLnVwZGF0ZVJhbmdlKHBhcmFtc1swXSk7XG4gICAgdGhpcy51cGRhdGVSYW5nZShwYXJhbXNbMl0pO1xufTtcbi8qKlxuICogQ1NJIFBjOyBQdDsgUGw7IFBiOyBQciQgeFxuICogICBGaWxsIFJlY3Rhbmd1bGFyIEFyZWEgKERFQ0ZSQSksIFZUNDIwIGFuZCB1cC5cbiAqICAgICBQYyBpcyB0aGUgY2hhcmFjdGVyIHRvIHVzZS5cbiAqICAgICBQdDsgUGw7IFBiOyBQciBkZW5vdGVzIHRoZSByZWN0YW5nbGUuXG4gKiBOT1RFOiB4dGVybSBkb2Vzbid0IGVuYWJsZSB0aGlzIGNvZGUgYnkgZGVmYXVsdC5cbiAqL1xuVGVybWluYWwucHJvdG90eXBlLmZpbGxSZWN0YW5nbGUgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgdmFyIGNoID0gcGFyYW1zWzBdLCB0ID0gcGFyYW1zWzFdLCBsID0gcGFyYW1zWzJdLCBiID0gcGFyYW1zWzNdLCByID0gcGFyYW1zWzRdO1xuICAgIHZhciBsaW5lLCBpO1xuICAgIGZvciAoOyB0IDwgYiArIDE7IHQrKykge1xuICAgICAgICBsaW5lID0gdGhpcy5saW5lc1t0aGlzLnliYXNlICsgdF07XG4gICAgICAgIGZvciAoaSA9IGw7IGkgPCByOyBpKyspIHtcbiAgICAgICAgICAgIGxpbmVbaV0gPSBbbGluZVtpXVswXSwgU3RyaW5nLmZyb21DaGFyQ29kZShjaCldO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHRoaXMubWF4UmFuZ2UoKTtcbiAgICB0aGlzLnVwZGF0ZVJhbmdlKHBhcmFtc1sxXSk7XG4gICAgdGhpcy51cGRhdGVSYW5nZShwYXJhbXNbM10pO1xufTtcbi8qKlxuICogQ1NJIFBzIDsgUHUgJyB6XG4gKiAgIEVuYWJsZSBMb2NhdG9yIFJlcG9ydGluZyAoREVDRUxSKS5cbiAqICAgVmFsaWQgdmFsdWVzIGZvciB0aGUgZmlyc3QgcGFyYW1ldGVyOlxuICogICAgIFBzID0gMCAgLT4gTG9jYXRvciBkaXNhYmxlZCAoZGVmYXVsdCkuXG4gKiAgICAgUHMgPSAxICAtPiBMb2NhdG9yIGVuYWJsZWQuXG4gKiAgICAgUHMgPSAyICAtPiBMb2NhdG9yIGVuYWJsZWQgZm9yIG9uZSByZXBvcnQsIHRoZW4gZGlzYWJsZWQuXG4gKiAgIFRoZSBzZWNvbmQgcGFyYW1ldGVyIHNwZWNpZmllcyB0aGUgY29vcmRpbmF0ZSB1bml0IGZvciBsb2NhdG9yXG4gKiAgIHJlcG9ydHMuXG4gKiAgIFZhbGlkIHZhbHVlcyBmb3IgdGhlIHNlY29uZCBwYXJhbWV0ZXI6XG4gKiAgICAgUHUgPSAwICA8LSBvciBvbWl0dGVkIC0+IGRlZmF1bHQgdG8gY2hhcmFjdGVyIGNlbGxzLlxuICogICAgIFB1ID0gMSAgPC0gZGV2aWNlIHBoeXNpY2FsIHBpeGVscy5cbiAqICAgICBQdSA9IDIgIDwtIGNoYXJhY3RlciBjZWxscy5cbiAqL1xuVGVybWluYWwucHJvdG90eXBlLmVuYWJsZUxvY2F0b3JSZXBvcnRpbmcgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgdmFyIHZhbCA9IHBhcmFtc1swXSA+IDA7XG4gICAgLy90aGlzLm1vdXNlRXZlbnRzID0gdmFsO1xuICAgIC8vdGhpcy5kZWNMb2NhdG9yID0gdmFsO1xufTtcbi8qKlxuICogQ1NJIFB0OyBQbDsgUGI7IFByJCB6XG4gKiAgIEVyYXNlIFJlY3Rhbmd1bGFyIEFyZWEgKERFQ0VSQSksIFZUNDAwIGFuZCB1cC5cbiAqICAgICBQdDsgUGw7IFBiOyBQciBkZW5vdGVzIHRoZSByZWN0YW5nbGUuXG4gKiBOT1RFOiB4dGVybSBkb2Vzbid0IGVuYWJsZSB0aGlzIGNvZGUgYnkgZGVmYXVsdC5cbiAqL1xuVGVybWluYWwucHJvdG90eXBlLmVyYXNlUmVjdGFuZ2xlID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgIHZhciB0ID0gcGFyYW1zWzBdLCBsID0gcGFyYW1zWzFdLCBiID0gcGFyYW1zWzJdLCByID0gcGFyYW1zWzNdO1xuICAgIHZhciBsaW5lLCBpLCBjaDtcbiAgICBjaCA9IFt0aGlzLmVyYXNlQXR0cigpLCAnICcsIDFdOyAvLyB4dGVybT9cbiAgICBmb3IgKDsgdCA8IGIgKyAxOyB0KyspIHtcbiAgICAgICAgbGluZSA9IHRoaXMubGluZXNbdGhpcy55YmFzZSArIHRdO1xuICAgICAgICBmb3IgKGkgPSBsOyBpIDwgcjsgaSsrKSB7XG4gICAgICAgICAgICBsaW5lW2ldID0gY2g7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gdGhpcy5tYXhSYW5nZSgpO1xuICAgIHRoaXMudXBkYXRlUmFuZ2UocGFyYW1zWzBdKTtcbiAgICB0aGlzLnVwZGF0ZVJhbmdlKHBhcmFtc1syXSk7XG59O1xuLyoqXG4gKiBDU0kgUCBtIFNQIH1cbiAqIEluc2VydCBQIHMgQ29sdW1uKHMpIChkZWZhdWx0ID0gMSkgKERFQ0lDKSwgVlQ0MjAgYW5kIHVwLlxuICogTk9URTogeHRlcm0gZG9lc24ndCBlbmFibGUgdGhpcyBjb2RlIGJ5IGRlZmF1bHQuXG4gKi9cblRlcm1pbmFsLnByb3RvdHlwZS5pbnNlcnRDb2x1bW5zID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwYXJhbSA9IHBhcmFtc1swXSwgbCA9IHRoaXMueWJhc2UgKyB0aGlzLnJvd3MsIGNoID0gW3RoaXMuZXJhc2VBdHRyKCksICcgJywgMV0gLy8geHRlcm0/XG4gICAgLCBpO1xuICAgIHdoaWxlIChwYXJhbS0tKSB7XG4gICAgICAgIGZvciAoaSA9IHRoaXMueWJhc2U7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMubGluZXNbaV0uc3BsaWNlKHRoaXMueCArIDEsIDAsIGNoKTtcbiAgICAgICAgICAgIHRoaXMubGluZXNbaV0ucG9wKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5tYXhSYW5nZSgpO1xufTtcbi8qKlxuICogQ1NJIFAgbSBTUCB+XG4gKiBEZWxldGUgUCBzIENvbHVtbihzKSAoZGVmYXVsdCA9IDEpIChERUNEQyksIFZUNDIwIGFuZCB1cFxuICogTk9URTogeHRlcm0gZG9lc24ndCBlbmFibGUgdGhpcyBjb2RlIGJ5IGRlZmF1bHQuXG4gKi9cblRlcm1pbmFsLnByb3RvdHlwZS5kZWxldGVDb2x1bW5zID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwYXJhbSA9IHBhcmFtc1swXSwgbCA9IHRoaXMueWJhc2UgKyB0aGlzLnJvd3MsIGNoID0gW3RoaXMuZXJhc2VBdHRyKCksICcgJywgMV0gLy8geHRlcm0/XG4gICAgLCBpO1xuICAgIHdoaWxlIChwYXJhbS0tKSB7XG4gICAgICAgIGZvciAoaSA9IHRoaXMueWJhc2U7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMubGluZXNbaV0uc3BsaWNlKHRoaXMueCwgMSk7XG4gICAgICAgICAgICB0aGlzLmxpbmVzW2ldLnB1c2goY2gpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMubWF4UmFuZ2UoKTtcbn07XG4vKipcbiAqIENoYXJhY3RlciBTZXRzXG4gKi9cblRlcm1pbmFsLmNoYXJzZXRzID0ge307XG4vLyBERUMgU3BlY2lhbCBDaGFyYWN0ZXIgYW5kIExpbmUgRHJhd2luZyBTZXQuXG4vLyBodHRwOi8vdnQxMDAubmV0L2RvY3MvdnQxMDItdWcvdGFibGU1LTEzLmh0bWxcbi8vIEEgbG90IG9mIGN1cnNlcyBhcHBzIHVzZSB0aGlzIGlmIHRoZXkgc2VlIFRFUk09eHRlcm0uXG4vLyB0ZXN0aW5nOiBlY2hvIC1lICdcXGUoMGFcXGUoQidcbi8vIFRoZSB4dGVybSBvdXRwdXQgc29tZXRpbWVzIHNlZW1zIHRvIGNvbmZsaWN0IHdpdGggdGhlXG4vLyByZWZlcmVuY2UgYWJvdmUuIHh0ZXJtIHNlZW1zIGluIGxpbmUgd2l0aCB0aGUgcmVmZXJlbmNlXG4vLyB3aGVuIHJ1bm5pbmcgdnR0ZXN0IGhvd2V2ZXIuXG4vLyBUaGUgdGFibGUgYmVsb3cgbm93IHVzZXMgeHRlcm0ncyBvdXRwdXQgZnJvbSB2dHRlc3QuXG5UZXJtaW5hbC5jaGFyc2V0cy5TQ0xEID0ge1xuICAgICdgJzogJ1xcdTI1YzYnLFxuICAgICdhJzogJ1xcdTI1OTInLFxuICAgICdiJzogJ1xcdTAwMDknLFxuICAgICdjJzogJ1xcdTAwMGMnLFxuICAgICdkJzogJ1xcdTAwMGQnLFxuICAgICdlJzogJ1xcdTAwMGEnLFxuICAgICdmJzogJ1xcdTAwYjAnLFxuICAgICdnJzogJ1xcdTAwYjEnLFxuICAgICdoJzogJ1xcdTI0MjQnLFxuICAgICdpJzogJ1xcdTAwMGInLFxuICAgICdqJzogJ1xcdTI1MTgnLFxuICAgICdrJzogJ1xcdTI1MTAnLFxuICAgICdsJzogJ1xcdTI1MGMnLFxuICAgICdtJzogJ1xcdTI1MTQnLFxuICAgICduJzogJ1xcdTI1M2MnLFxuICAgICdvJzogJ1xcdTIzYmEnLFxuICAgICdwJzogJ1xcdTIzYmInLFxuICAgICdxJzogJ1xcdTI1MDAnLFxuICAgICdyJzogJ1xcdTIzYmMnLFxuICAgICdzJzogJ1xcdTIzYmQnLFxuICAgICd0JzogJ1xcdTI1MWMnLFxuICAgICd1JzogJ1xcdTI1MjQnLFxuICAgICd2JzogJ1xcdTI1MzQnLFxuICAgICd3JzogJ1xcdTI1MmMnLFxuICAgICd4JzogJ1xcdTI1MDInLFxuICAgICd5JzogJ1xcdTIyNjQnLFxuICAgICd6JzogJ1xcdTIyNjUnLFxuICAgICd7JzogJ1xcdTAzYzAnLFxuICAgICd8JzogJ1xcdTIyNjAnLFxuICAgICd9JzogJ1xcdTAwYTMnLFxuICAgICd+JzogJ1xcdTAwYjcnIC8vICfCtydcbn07XG5UZXJtaW5hbC5jaGFyc2V0cy5VSyA9IG51bGw7IC8vIChBXG5UZXJtaW5hbC5jaGFyc2V0cy5VUyA9IG51bGw7IC8vIChCIChVU0FTQ0lJKVxuVGVybWluYWwuY2hhcnNldHMuRHV0Y2ggPSBudWxsOyAvLyAoNFxuVGVybWluYWwuY2hhcnNldHMuRmlubmlzaCA9IG51bGw7IC8vIChDIG9yICg1XG5UZXJtaW5hbC5jaGFyc2V0cy5GcmVuY2ggPSBudWxsOyAvLyAoUlxuVGVybWluYWwuY2hhcnNldHMuRnJlbmNoQ2FuYWRpYW4gPSBudWxsOyAvLyAoUVxuVGVybWluYWwuY2hhcnNldHMuR2VybWFuID0gbnVsbDsgLy8gKEtcblRlcm1pbmFsLmNoYXJzZXRzLkl0YWxpYW4gPSBudWxsOyAvLyAoWVxuVGVybWluYWwuY2hhcnNldHMuTm9yd2VnaWFuRGFuaXNoID0gbnVsbDsgLy8gKEUgb3IgKDZcblRlcm1pbmFsLmNoYXJzZXRzLlNwYW5pc2ggPSBudWxsOyAvLyAoWlxuVGVybWluYWwuY2hhcnNldHMuU3dlZGlzaCA9IG51bGw7IC8vIChIIG9yICg3XG5UZXJtaW5hbC5jaGFyc2V0cy5Td2lzcyA9IG51bGw7IC8vICg9XG5UZXJtaW5hbC5jaGFyc2V0cy5JU09MYXRpbiA9IG51bGw7IC8vIC9BXG4vKipcbiAqIEhlbHBlcnNcbiAqL1xuZnVuY3Rpb24gb24oZWwsIHR5cGUsIGhhbmRsZXIsIGNhcHR1cmUpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZWwpKSB7XG4gICAgICAgIGVsID0gW2VsXTtcbiAgICB9XG4gICAgZWwuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgY2FwdHVyZSB8fCBmYWxzZSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBvZmYoZWwsIHR5cGUsIGhhbmRsZXIsIGNhcHR1cmUpIHtcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGNhcHR1cmUgfHwgZmFsc2UpO1xufVxuZnVuY3Rpb24gY2FuY2VsKGV2LCBmb3JjZSkge1xuICAgIGlmICghdGhpcy5jYW5jZWxFdmVudHMgJiYgIWZvcmNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpbmhlcml0cyhjaGlsZCwgcGFyZW50KSB7XG4gICAgZnVuY3Rpb24gZigpIHtcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkO1xuICAgIH1cbiAgICBmLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7XG4gICAgY2hpbGQucHJvdG90eXBlID0gbmV3IGY7XG59XG4vLyBpZiBib2xkIGlzIGJyb2tlbiwgd2UgY2FuJ3Rcbi8vIHVzZSBpdCBpbiB0aGUgdGVybWluYWwuXG5mdW5jdGlvbiBpc0JvbGRCcm9rZW4oZG9jdW1lbnQpIHtcbiAgICB2YXIgYm9keSA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdib2R5JylbMF07XG4gICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgIGVsLmlubmVySFRNTCA9ICdoZWxsbyB3b3JsZCc7XG4gICAgYm9keS5hcHBlbmRDaGlsZChlbCk7XG4gICAgdmFyIHcxID0gZWwuc2Nyb2xsV2lkdGg7XG4gICAgZWwuc3R5bGUuZm9udFdlaWdodCA9ICdib2xkJztcbiAgICB2YXIgdzIgPSBlbC5zY3JvbGxXaWR0aDtcbiAgICBib2R5LnJlbW92ZUNoaWxkKGVsKTtcbiAgICByZXR1cm4gdzEgIT09IHcyO1xufVxuZnVuY3Rpb24gaW5kZXhPZihvYmosIGVsKSB7XG4gICAgdmFyIGkgPSBvYmoubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgaWYgKG9ialtpXSA9PT0gZWwpXG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuZnVuY3Rpb24gaXNUaGlyZExldmVsU2hpZnQodGVybSwgZXYpIHtcbiAgICB2YXIgdGhpcmRMZXZlbEtleSA9ICh0ZXJtLmJyb3dzZXIuaXNNYWMgJiYgZXYuYWx0S2V5ICYmICFldi5jdHJsS2V5ICYmICFldi5tZXRhS2V5KSB8fFxuICAgICAgICAodGVybS5icm93c2VyLmlzTVNXaW5kb3dzICYmIGV2LmFsdEtleSAmJiBldi5jdHJsS2V5ICYmICFldi5tZXRhS2V5KTtcbiAgICBpZiAoZXYudHlwZSA9PSAna2V5cHJlc3MnKSB7XG4gICAgICAgIHJldHVybiB0aGlyZExldmVsS2V5O1xuICAgIH1cbiAgICAvLyBEb24ndCBpbnZva2UgZm9yIGFycm93cywgcGFnZURvd24sIGhvbWUsIGJhY2tzcGFjZSwgZXRjLiAob24gbm9uLWtleXByZXNzIGV2ZW50cylcbiAgICByZXR1cm4gdGhpcmRMZXZlbEtleSAmJiAoIWV2LmtleUNvZGUgfHwgZXYua2V5Q29kZSA+IDQ3KTtcbn1cbmZ1bmN0aW9uIG1hdGNoQ29sb3IocjEsIGcxLCBiMSkge1xuICAgIHZhciBoYXNoID0gKHIxIDw8IDE2KSB8IChnMSA8PCA4KSB8IGIxO1xuICAgIGlmIChtYXRjaENvbG9yLl9jYWNoZVtoYXNoXSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBtYXRjaENvbG9yLl9jYWNoZVtoYXNoXTtcbiAgICB9XG4gICAgdmFyIGxkaWZmID0gSW5maW5pdHksIGxpID0gLTEsIGkgPSAwLCBjLCByMiwgZzIsIGIyLCBkaWZmO1xuICAgIGZvciAoOyBpIDwgVGVybWluYWwudmNvbG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjID0gVGVybWluYWwudmNvbG9yc1tpXTtcbiAgICAgICAgcjIgPSBjWzBdO1xuICAgICAgICBnMiA9IGNbMV07XG4gICAgICAgIGIyID0gY1syXTtcbiAgICAgICAgZGlmZiA9IG1hdGNoQ29sb3IuZGlzdGFuY2UocjEsIGcxLCBiMSwgcjIsIGcyLCBiMik7XG4gICAgICAgIGlmIChkaWZmID09PSAwKSB7XG4gICAgICAgICAgICBsaSA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlmZiA8IGxkaWZmKSB7XG4gICAgICAgICAgICBsZGlmZiA9IGRpZmY7XG4gICAgICAgICAgICBsaSA9IGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hdGNoQ29sb3IuX2NhY2hlW2hhc2hdID0gbGk7XG59XG5tYXRjaENvbG9yLl9jYWNoZSA9IHt9O1xuLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xNjMzODI4XG5tYXRjaENvbG9yLmRpc3RhbmNlID0gZnVuY3Rpb24gKHIxLCBnMSwgYjEsIHIyLCBnMiwgYjIpIHtcbiAgICByZXR1cm4gTWF0aC5wb3coMzAgKiAocjEgLSByMiksIDIpXG4gICAgICAgICsgTWF0aC5wb3coNTkgKiAoZzEgLSBnMiksIDIpXG4gICAgICAgICsgTWF0aC5wb3coMTEgKiAoYjEgLSBiMiksIDIpO1xufTtcbmZ1bmN0aW9uIGVhY2gob2JqLCBpdGVyLCBjb24pIHtcbiAgICBpZiAob2JqLmZvckVhY2gpXG4gICAgICAgIHJldHVybiBvYmouZm9yRWFjaChpdGVyLCBjb24pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZXIuY2FsbChjb24sIG9ialtpXSwgaSwgb2JqKTtcbiAgICB9XG59XG5mdW5jdGlvbiBrZXlzKG9iaikge1xuICAgIGlmIChPYmplY3Qua2V5cylcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaik7XG4gICAgdmFyIGtleSwga2V5cyA9IFtdO1xuICAgIGZvciAoa2V5IGluIG9iaikge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGtleXM7XG59XG52YXIgd2N3aWR0aCA9IChmdW5jdGlvbiAob3B0cykge1xuICAgIC8vIGV4dHJhY3RlZCBmcm9tIGh0dHBzOi8vd3d3LmNsLmNhbS5hYy51ay8lN0VtZ2syNS91Y3Mvd2N3aWR0aC5jXG4gICAgLy8gY29tYmluaW5nIGNoYXJhY3RlcnNcbiAgICB2YXIgQ09NQklOSU5HID0gW1xuICAgICAgICBbMHgwMzAwLCAweDAzNkZdLCBbMHgwNDgzLCAweDA0ODZdLCBbMHgwNDg4LCAweDA0ODldLFxuICAgICAgICBbMHgwNTkxLCAweDA1QkRdLCBbMHgwNUJGLCAweDA1QkZdLCBbMHgwNUMxLCAweDA1QzJdLFxuICAgICAgICBbMHgwNUM0LCAweDA1QzVdLCBbMHgwNUM3LCAweDA1QzddLCBbMHgwNjAwLCAweDA2MDNdLFxuICAgICAgICBbMHgwNjEwLCAweDA2MTVdLCBbMHgwNjRCLCAweDA2NUVdLCBbMHgwNjcwLCAweDA2NzBdLFxuICAgICAgICBbMHgwNkQ2LCAweDA2RTRdLCBbMHgwNkU3LCAweDA2RThdLCBbMHgwNkVBLCAweDA2RURdLFxuICAgICAgICBbMHgwNzBGLCAweDA3MEZdLCBbMHgwNzExLCAweDA3MTFdLCBbMHgwNzMwLCAweDA3NEFdLFxuICAgICAgICBbMHgwN0E2LCAweDA3QjBdLCBbMHgwN0VCLCAweDA3RjNdLCBbMHgwOTAxLCAweDA5MDJdLFxuICAgICAgICBbMHgwOTNDLCAweDA5M0NdLCBbMHgwOTQxLCAweDA5NDhdLCBbMHgwOTRELCAweDA5NERdLFxuICAgICAgICBbMHgwOTUxLCAweDA5NTRdLCBbMHgwOTYyLCAweDA5NjNdLCBbMHgwOTgxLCAweDA5ODFdLFxuICAgICAgICBbMHgwOUJDLCAweDA5QkNdLCBbMHgwOUMxLCAweDA5QzRdLCBbMHgwOUNELCAweDA5Q0RdLFxuICAgICAgICBbMHgwOUUyLCAweDA5RTNdLCBbMHgwQTAxLCAweDBBMDJdLCBbMHgwQTNDLCAweDBBM0NdLFxuICAgICAgICBbMHgwQTQxLCAweDBBNDJdLCBbMHgwQTQ3LCAweDBBNDhdLCBbMHgwQTRCLCAweDBBNERdLFxuICAgICAgICBbMHgwQTcwLCAweDBBNzFdLCBbMHgwQTgxLCAweDBBODJdLCBbMHgwQUJDLCAweDBBQkNdLFxuICAgICAgICBbMHgwQUMxLCAweDBBQzVdLCBbMHgwQUM3LCAweDBBQzhdLCBbMHgwQUNELCAweDBBQ0RdLFxuICAgICAgICBbMHgwQUUyLCAweDBBRTNdLCBbMHgwQjAxLCAweDBCMDFdLCBbMHgwQjNDLCAweDBCM0NdLFxuICAgICAgICBbMHgwQjNGLCAweDBCM0ZdLCBbMHgwQjQxLCAweDBCNDNdLCBbMHgwQjRELCAweDBCNERdLFxuICAgICAgICBbMHgwQjU2LCAweDBCNTZdLCBbMHgwQjgyLCAweDBCODJdLCBbMHgwQkMwLCAweDBCQzBdLFxuICAgICAgICBbMHgwQkNELCAweDBCQ0RdLCBbMHgwQzNFLCAweDBDNDBdLCBbMHgwQzQ2LCAweDBDNDhdLFxuICAgICAgICBbMHgwQzRBLCAweDBDNERdLCBbMHgwQzU1LCAweDBDNTZdLCBbMHgwQ0JDLCAweDBDQkNdLFxuICAgICAgICBbMHgwQ0JGLCAweDBDQkZdLCBbMHgwQ0M2LCAweDBDQzZdLCBbMHgwQ0NDLCAweDBDQ0RdLFxuICAgICAgICBbMHgwQ0UyLCAweDBDRTNdLCBbMHgwRDQxLCAweDBENDNdLCBbMHgwRDRELCAweDBENERdLFxuICAgICAgICBbMHgwRENBLCAweDBEQ0FdLCBbMHgwREQyLCAweDBERDRdLCBbMHgwREQ2LCAweDBERDZdLFxuICAgICAgICBbMHgwRTMxLCAweDBFMzFdLCBbMHgwRTM0LCAweDBFM0FdLCBbMHgwRTQ3LCAweDBFNEVdLFxuICAgICAgICBbMHgwRUIxLCAweDBFQjFdLCBbMHgwRUI0LCAweDBFQjldLCBbMHgwRUJCLCAweDBFQkNdLFxuICAgICAgICBbMHgwRUM4LCAweDBFQ0RdLCBbMHgwRjE4LCAweDBGMTldLCBbMHgwRjM1LCAweDBGMzVdLFxuICAgICAgICBbMHgwRjM3LCAweDBGMzddLCBbMHgwRjM5LCAweDBGMzldLCBbMHgwRjcxLCAweDBGN0VdLFxuICAgICAgICBbMHgwRjgwLCAweDBGODRdLCBbMHgwRjg2LCAweDBGODddLCBbMHgwRjkwLCAweDBGOTddLFxuICAgICAgICBbMHgwRjk5LCAweDBGQkNdLCBbMHgwRkM2LCAweDBGQzZdLCBbMHgxMDJELCAweDEwMzBdLFxuICAgICAgICBbMHgxMDMyLCAweDEwMzJdLCBbMHgxMDM2LCAweDEwMzddLCBbMHgxMDM5LCAweDEwMzldLFxuICAgICAgICBbMHgxMDU4LCAweDEwNTldLCBbMHgxMTYwLCAweDExRkZdLCBbMHgxMzVGLCAweDEzNUZdLFxuICAgICAgICBbMHgxNzEyLCAweDE3MTRdLCBbMHgxNzMyLCAweDE3MzRdLCBbMHgxNzUyLCAweDE3NTNdLFxuICAgICAgICBbMHgxNzcyLCAweDE3NzNdLCBbMHgxN0I0LCAweDE3QjVdLCBbMHgxN0I3LCAweDE3QkRdLFxuICAgICAgICBbMHgxN0M2LCAweDE3QzZdLCBbMHgxN0M5LCAweDE3RDNdLCBbMHgxN0RELCAweDE3RERdLFxuICAgICAgICBbMHgxODBCLCAweDE4MERdLCBbMHgxOEE5LCAweDE4QTldLCBbMHgxOTIwLCAweDE5MjJdLFxuICAgICAgICBbMHgxOTI3LCAweDE5MjhdLCBbMHgxOTMyLCAweDE5MzJdLCBbMHgxOTM5LCAweDE5M0JdLFxuICAgICAgICBbMHgxQTE3LCAweDFBMThdLCBbMHgxQjAwLCAweDFCMDNdLCBbMHgxQjM0LCAweDFCMzRdLFxuICAgICAgICBbMHgxQjM2LCAweDFCM0FdLCBbMHgxQjNDLCAweDFCM0NdLCBbMHgxQjQyLCAweDFCNDJdLFxuICAgICAgICBbMHgxQjZCLCAweDFCNzNdLCBbMHgxREMwLCAweDFEQ0FdLCBbMHgxREZFLCAweDFERkZdLFxuICAgICAgICBbMHgyMDBCLCAweDIwMEZdLCBbMHgyMDJBLCAweDIwMkVdLCBbMHgyMDYwLCAweDIwNjNdLFxuICAgICAgICBbMHgyMDZBLCAweDIwNkZdLCBbMHgyMEQwLCAweDIwRUZdLCBbMHgzMDJBLCAweDMwMkZdLFxuICAgICAgICBbMHgzMDk5LCAweDMwOUFdLCBbMHhBODA2LCAweEE4MDZdLCBbMHhBODBCLCAweEE4MEJdLFxuICAgICAgICBbMHhBODI1LCAweEE4MjZdLCBbMHhGQjFFLCAweEZCMUVdLCBbMHhGRTAwLCAweEZFMEZdLFxuICAgICAgICBbMHhGRTIwLCAweEZFMjNdLCBbMHhGRUZGLCAweEZFRkZdLCBbMHhGRkY5LCAweEZGRkJdLFxuICAgICAgICBbMHgxMEEwMSwgMHgxMEEwM10sIFsweDEwQTA1LCAweDEwQTA2XSwgWzB4MTBBMEMsIDB4MTBBMEZdLFxuICAgICAgICBbMHgxMEEzOCwgMHgxMEEzQV0sIFsweDEwQTNGLCAweDEwQTNGXSwgWzB4MUQxNjcsIDB4MUQxNjldLFxuICAgICAgICBbMHgxRDE3MywgMHgxRDE4Ml0sIFsweDFEMTg1LCAweDFEMThCXSwgWzB4MUQxQUEsIDB4MUQxQURdLFxuICAgICAgICBbMHgxRDI0MiwgMHgxRDI0NF0sIFsweEUwMDAxLCAweEUwMDAxXSwgWzB4RTAwMjAsIDB4RTAwN0ZdLFxuICAgICAgICBbMHhFMDEwMCwgMHhFMDFFRl1cbiAgICBdO1xuICAgIC8vIGJpbmFyeSBzZWFyY2hcbiAgICBmdW5jdGlvbiBiaXNlYXJjaCh1Y3MpIHtcbiAgICAgICAgdmFyIG1pbiA9IDA7XG4gICAgICAgIHZhciBtYXggPSBDT01CSU5JTkcubGVuZ3RoIC0gMTtcbiAgICAgICAgdmFyIG1pZDtcbiAgICAgICAgaWYgKHVjcyA8IENPTUJJTklOR1swXVswXSB8fCB1Y3MgPiBDT01CSU5JTkdbbWF4XVsxXSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgd2hpbGUgKG1heCA+PSBtaW4pIHtcbiAgICAgICAgICAgIG1pZCA9IE1hdGguZmxvb3IoKG1pbiArIG1heCkgLyAyKTtcbiAgICAgICAgICAgIGlmICh1Y3MgPiBDT01CSU5JTkdbbWlkXVsxXSlcbiAgICAgICAgICAgICAgICBtaW4gPSBtaWQgKyAxO1xuICAgICAgICAgICAgZWxzZSBpZiAodWNzIDwgQ09NQklOSU5HW21pZF1bMF0pXG4gICAgICAgICAgICAgICAgbWF4ID0gbWlkIC0gMTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdjd2lkdGgodWNzKSB7XG4gICAgICAgIC8vIHRlc3QgZm9yIDgtYml0IGNvbnRyb2wgY2hhcmFjdGVyc1xuICAgICAgICBpZiAodWNzID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIG9wdHMubnVsO1xuICAgICAgICBpZiAodWNzIDwgMzIgfHwgKHVjcyA+PSAweDdmICYmIHVjcyA8IDB4YTApKVxuICAgICAgICAgICAgcmV0dXJuIG9wdHMuY29udHJvbDtcbiAgICAgICAgLy8gYmluYXJ5IHNlYXJjaCBpbiB0YWJsZSBvZiBub24tc3BhY2luZyBjaGFyYWN0ZXJzXG4gICAgICAgIGlmIChiaXNlYXJjaCh1Y3MpKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIC8vIGlmIHdlIGFycml2ZSBoZXJlLCB1Y3MgaXMgbm90IGEgY29tYmluaW5nIG9yIEMwL0MxIGNvbnRyb2wgY2hhcmFjdGVyXG4gICAgICAgIHJldHVybiAxICtcbiAgICAgICAgICAgICh1Y3MgPj0gMHgxMTAwICYmXG4gICAgICAgICAgICAgICAgKHVjcyA8PSAweDExNWYgfHxcbiAgICAgICAgICAgICAgICAgICAgdWNzID09IDB4MjMyOSB8fFxuICAgICAgICAgICAgICAgICAgICB1Y3MgPT0gMHgyMzJhIHx8XG4gICAgICAgICAgICAgICAgICAgICh1Y3MgPj0gMHgyZTgwICYmIHVjcyA8PSAweGE0Y2YgJiYgdWNzICE9IDB4MzAzZikgfHxcbiAgICAgICAgICAgICAgICAgICAgKHVjcyA+PSAweGFjMDAgJiYgdWNzIDw9IDB4ZDdhMykgfHxcbiAgICAgICAgICAgICAgICAgICAgKHVjcyA+PSAweGY5MDAgJiYgdWNzIDw9IDB4ZmFmZikgfHxcbiAgICAgICAgICAgICAgICAgICAgKHVjcyA+PSAweGZlMTAgJiYgdWNzIDw9IDB4ZmUxOSkgfHxcbiAgICAgICAgICAgICAgICAgICAgKHVjcyA+PSAweGZlMzAgJiYgdWNzIDw9IDB4ZmU2ZikgfHxcbiAgICAgICAgICAgICAgICAgICAgKHVjcyA+PSAweGZmMDAgJiYgdWNzIDw9IDB4ZmY2MCkgfHxcbiAgICAgICAgICAgICAgICAgICAgKHVjcyA+PSAweGZmZTAgJiYgdWNzIDw9IDB4ZmZlNikgfHxcbiAgICAgICAgICAgICAgICAgICAgKHVjcyA+PSAweDIwMDAwICYmIHVjcyA8PSAweDJmZmZkKSB8fFxuICAgICAgICAgICAgICAgICAgICAodWNzID49IDB4MzAwMDAgJiYgdWNzIDw9IDB4M2ZmZmQpKSk7XG4gICAgfVxuICAgIHJldHVybiB3Y3dpZHRoO1xufSkoeyBudWw6IDAsIGNvbnRyb2w6IDAgfSk7IC8vIGNvbmZpZ3VyYWJsZSBvcHRpb25zXG4vKipcbiAqIEV4cG9zZVxuICovXG5UZXJtaW5hbC5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXJfanNfMS5FdmVudEVtaXR0ZXI7XG5UZXJtaW5hbC5pbmhlcml0cyA9IGluaGVyaXRzO1xuLyoqXG4gKiBBZGRzIGFuIGV2ZW50IGxpc3RlbmVyIHRvIHRoZSB0ZXJtaW5hbC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQgVGhlIG5hbWUgb2YgdGhlIGV2ZW50LiBUT0RPOiBEb2N1bWVudCBhbGwgZXZlbnQgdHlwZXNcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIGV2ZW50IGlzIHRyaWdnZXJlZC5cbiAqL1xuVGVybWluYWwub24gPSBvbjtcblRlcm1pbmFsLm9mZiA9IG9mZjtcblRlcm1pbmFsLmNhbmNlbCA9IGNhbmNlbDtcbm1vZHVsZS5leHBvcnRzID0gVGVybWluYWw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD14dGVybS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi94dGVybS9saWIveHRlcm0uanNcbiAqKiBtb2R1bGUgaWQgPSAxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogRW5jYXBzdWxhdGVzIHRoZSBsb2dpYyBmb3IgaGFuZGxpbmcgY29tcG9zaXRpb25zdGFydCwgY29tcG9zaXRpb251cGRhdGUgYW5kIGNvbXBvc2l0aW9uZW5kXG4gKiBldmVudHMsIGRpc3BsYXlpbmcgdGhlIGluLXByb2dyZXNzIGNvbXBvc2l0aW9uIHRvIHRoZSBVSSBhbmQgZm9yd2FyZGluZyB0aGUgZmluYWwgY29tcG9zaXRpb25cbiAqIHRvIHRoZSBoYW5kbGVyLlxuICovXG52YXIgQ29tcG9zaXRpb25IZWxwZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgQ29tcG9zaXRpb25IZWxwZXIuXG4gICAgICogQHBhcmFtIHRleHRhcmVhIFRoZSB0ZXh0YXJlYSB0aGF0IHh0ZXJtIHVzZXMgZm9yIGlucHV0LlxuICAgICAqIEBwYXJhbSBjb21wb3NpdGlvblZpZXcgVGhlIGVsZW1lbnQgdG8gZGlzcGxheSB0aGUgaW4tcHJvZ3Jlc3MgY29tcG9zaXRpb24gaW4uXG4gICAgICogQHBhcmFtIHRlcm1pbmFsIFRoZSBUZXJtaW5hbCB0byBmb3J3YXJkIHRoZSBmaW5pc2hlZCBjb21wb3NpdGlvbiB0by5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDb21wb3NpdGlvbkhlbHBlcih0ZXh0YXJlYSwgY29tcG9zaXRpb25WaWV3LCB0ZXJtaW5hbCkge1xuICAgICAgICB0aGlzLnRleHRhcmVhID0gdGV4dGFyZWE7XG4gICAgICAgIHRoaXMuY29tcG9zaXRpb25WaWV3ID0gY29tcG9zaXRpb25WaWV3O1xuICAgICAgICB0aGlzLnRlcm1pbmFsID0gdGVybWluYWw7XG4gICAgICAgIHRoaXMuaXNDb21wb3NpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1NlbmRpbmdDb21wb3NpdGlvbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNvbXBvc2l0aW9uUG9zaXRpb24gPSB7IHN0YXJ0OiBudWxsLCBlbmQ6IG51bGwgfTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgdGhlIGNvbXBvc2l0aW9uc3RhcnQgZXZlbnQsIGFjdGl2YXRpbmcgdGhlIGNvbXBvc2l0aW9uIHZpZXcuXG4gICAgICovXG4gICAgQ29tcG9zaXRpb25IZWxwZXIucHJvdG90eXBlLmNvbXBvc2l0aW9uc3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaXNDb21wb3NpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLmNvbXBvc2l0aW9uUG9zaXRpb24uc3RhcnQgPSB0aGlzLnRleHRhcmVhLnZhbHVlLmxlbmd0aDtcbiAgICAgICAgdGhpcy5jb21wb3NpdGlvblZpZXcudGV4dENvbnRlbnQgPSAnJztcbiAgICAgICAgdGhpcy5jb21wb3NpdGlvblZpZXcuY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHRoZSBjb21wb3NpdGlvbnVwZGF0ZSBldmVudCwgdXBkYXRpbmcgdGhlIGNvbXBvc2l0aW9uIHZpZXcuXG4gICAgICogQHBhcmFtIHtDb21wb3NpdGlvbkV2ZW50fSBldiBUaGUgZXZlbnQuXG4gICAgICovXG4gICAgQ29tcG9zaXRpb25IZWxwZXIucHJvdG90eXBlLmNvbXBvc2l0aW9udXBkYXRlID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgIHRoaXMuY29tcG9zaXRpb25WaWV3LnRleHRDb250ZW50ID0gZXYuZGF0YTtcbiAgICAgICAgdGhpcy51cGRhdGVDb21wb3NpdGlvbkVsZW1lbnRzKCk7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZWxmLmNvbXBvc2l0aW9uUG9zaXRpb24uZW5kID0gc2VsZi50ZXh0YXJlYS52YWx1ZS5sZW5ndGg7XG4gICAgICAgIH0sIDApO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyB0aGUgY29tcG9zaXRpb25lbmQgZXZlbnQsIGhpZGluZyB0aGUgY29tcG9zaXRpb24gdmlldyBhbmQgc2VuZGluZyB0aGUgY29tcG9zaXRpb24gdG9cbiAgICAgKiB0aGUgaGFuZGxlci5cbiAgICAgKi9cbiAgICBDb21wb3NpdGlvbkhlbHBlci5wcm90b3R5cGUuY29tcG9zaXRpb25lbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZmluYWxpemVDb21wb3NpdGlvbih0cnVlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgdGhlIGtleWRvd24gZXZlbnQsIHJvdXRpbmcgYW55IG5lY2Vzc2FyeSBldmVudHMgdG8gdGhlIENvbXBvc2l0aW9uSGVscGVyIGZ1bmN0aW9ucy5cbiAgICAgKiBAcGFyYW0gZXYgVGhlIGtleWRvd24gZXZlbnQuXG4gICAgICogQHJldHVybiBXaGV0aGVyIHRoZSBUZXJtaW5hbCBzaG91bGQgY29udGludWUgcHJvY2Vzc2luZyB0aGUga2V5ZG93biBldmVudC5cbiAgICAgKi9cbiAgICBDb21wb3NpdGlvbkhlbHBlci5wcm90b3R5cGUua2V5ZG93biA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICBpZiAodGhpcy5pc0NvbXBvc2luZyB8fCB0aGlzLmlzU2VuZGluZ0NvbXBvc2l0aW9uKSB7XG4gICAgICAgICAgICBpZiAoZXYua2V5Q29kZSA9PT0gMjI5KSB7XG4gICAgICAgICAgICAgICAgLy8gQ29udGludWUgY29tcG9zaW5nIGlmIHRoZSBrZXlDb2RlIGlzIHRoZSBcImNvbXBvc2l0aW9uIGNoYXJhY3RlclwiXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXYua2V5Q29kZSA9PT0gMTYgfHwgZXYua2V5Q29kZSA9PT0gMTcgfHwgZXYua2V5Q29kZSA9PT0gMTgpIHtcbiAgICAgICAgICAgICAgICAvLyBDb250aW51ZSBjb21wb3NpbmcgaWYgdGhlIGtleUNvZGUgaXMgYSBtb2RpZmllciBrZXlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBGaW5pc2ggY29tcG9zaXRpb24gaW1tZWRpYXRlbHkuIFRoaXMgaXMgbWFpbmx5IGhlcmUgZm9yIHRoZSBjYXNlIHdoZXJlIGVudGVyIGlzXG4gICAgICAgICAgICAgICAgLy8gcHJlc3NlZCBhbmQgdGhlIGhhbmRsZXIgbmVlZHMgdG8gYmUgdHJpZ2dlcmVkIGJlZm9yZSB0aGUgY29tbWFuZCBpcyBleGVjdXRlZC5cbiAgICAgICAgICAgICAgICB0aGlzLmZpbmFsaXplQ29tcG9zaXRpb24oZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChldi5rZXlDb2RlID09PSAyMjkpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBcImNvbXBvc2l0aW9uIGNoYXJhY3RlclwiIGlzIHVzZWQgYnV0IGdldHMgdG8gdGhpcyBwb2ludCBpdCBtZWFucyBhIG5vbi1jb21wb3NpdGlvblxuICAgICAgICAgICAgLy8gY2hhcmFjdGVyIChlZy4gbnVtYmVycyBhbmQgcHVuY3R1YXRpb24pIHdhcyBwcmVzc2VkIHdoZW4gdGhlIElNRSB3YXMgYWN0aXZlLlxuICAgICAgICAgICAgdGhpcy5oYW5kbGVBbnlUZXh0YXJlYUNoYW5nZXMoKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEZpbmFsaXplcyB0aGUgY29tcG9zaXRpb24sIHJlc3VtaW5nIHJlZ3VsYXIgaW5wdXQgYWN0aW9ucy4gVGhpcyBpcyBjYWxsZWQgd2hlbiBhIGNvbXBvc2l0aW9uXG4gICAgICogaXMgZW5kaW5nLlxuICAgICAqIEBwYXJhbSB3YWl0Rm9yUHJvcG9nYXRpb24gV2hldGhlciB0byB3YWl0IGZvciBldmVudHMgdG8gcHJvcG9nYXRlIGJlZm9yZSBzZW5kaW5nXG4gICAgICogICB0aGUgaW5wdXQuIFRoaXMgc2hvdWxkIGJlIGZhbHNlIGlmIGEgbm9uLWNvbXBvc2l0aW9uIGtleXN0cm9rZSBpcyBlbnRlcmVkIGJlZm9yZSB0aGVcbiAgICAgKiAgIGNvbXBvc2l0aW9uZW5kIGV2ZW50IGlzIHRyaWdnZXJlZCwgc3VjaCBhcyBlbnRlciwgc28gdGhhdCB0aGUgY29tcG9zaXRpb24gaXMgc2VuZCBiZWZvcmVcbiAgICAgKiAgIHRoZSBjb21tYW5kIGlzIGV4ZWN1dGVkLlxuICAgICAqL1xuICAgIENvbXBvc2l0aW9uSGVscGVyLnByb3RvdHlwZS5maW5hbGl6ZUNvbXBvc2l0aW9uID0gZnVuY3Rpb24gKHdhaXRGb3JQcm9wb2dhdGlvbikge1xuICAgICAgICB0aGlzLmNvbXBvc2l0aW9uVmlldy5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcbiAgICAgICAgdGhpcy5pc0NvbXBvc2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNsZWFyVGV4dGFyZWFQb3NpdGlvbigpO1xuICAgICAgICBpZiAoIXdhaXRGb3JQcm9wb2dhdGlvbikge1xuICAgICAgICAgICAgLy8gQ2FuY2VsIGFueSBkZWxheWVkIGNvbXBvc2l0aW9uIHNlbmQgcmVxdWVzdHMgYW5kIHNlbmQgdGhlIGlucHV0IGltbWVkaWF0ZWx5LlxuICAgICAgICAgICAgdGhpcy5pc1NlbmRpbmdDb21wb3NpdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGlucHV0ID0gdGhpcy50ZXh0YXJlYS52YWx1ZS5zdWJzdHJpbmcodGhpcy5jb21wb3NpdGlvblBvc2l0aW9uLnN0YXJ0LCB0aGlzLmNvbXBvc2l0aW9uUG9zaXRpb24uZW5kKTtcbiAgICAgICAgICAgIHRoaXMudGVybWluYWwuaGFuZGxlcihpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBNYWtlIGEgZGVlcCBjb3B5IG9mIHRoZSBjb21wb3NpdGlvbiBwb3NpdGlvbiBoZXJlIGFzIGEgbmV3IGNvbXBvc2l0aW9uc3RhcnQgZXZlbnQgbWF5XG4gICAgICAgICAgICAvLyBmaXJlIGJlZm9yZSB0aGUgc2V0VGltZW91dCBleGVjdXRlcy5cbiAgICAgICAgICAgIHZhciBjdXJyZW50Q29tcG9zaXRpb25Qb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBzdGFydDogdGhpcy5jb21wb3NpdGlvblBvc2l0aW9uLnN0YXJ0LFxuICAgICAgICAgICAgICAgIGVuZDogdGhpcy5jb21wb3NpdGlvblBvc2l0aW9uLmVuZCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBTaW5jZSBjb21wb3NpdGlvbiogZXZlbnRzIGhhcHBlbiBiZWZvcmUgdGhlIGNoYW5nZXMgdGFrZSBwbGFjZSBpbiB0aGUgdGV4dGFyZWEgb24gbW9zdFxuICAgICAgICAgICAgLy8gYnJvd3NlcnMsIHVzZSBhIHNldFRpbWVvdXQgd2l0aCAwbXMgdGltZSB0byBhbGxvdyB0aGUgbmF0aXZlIGNvbXBvc2l0aW9uZW5kIGV2ZW50IHRvXG4gICAgICAgICAgICAvLyBjb21wbGV0ZS4gVGhpcyBlbnN1cmVzIHRoZSBjb3JyZWN0IGNoYXJhY3RlciBpcyByZXRyaWV2ZWQsIHRoaXMgc29sdXRpb24gd2FzIHVzZWRcbiAgICAgICAgICAgIC8vIGJlY2F1c2U6XG4gICAgICAgICAgICAvLyAtIFRoZSBjb21wb3NpdGlvbmVuZCBldmVudCdzIGRhdGEgcHJvcGVydHkgaXMgdW5yZWxpYWJsZSwgYXQgbGVhc3Qgb24gQ2hyb21pdW1cbiAgICAgICAgICAgIC8vIC0gVGhlIGxhc3QgY29tcG9zaXRpb251cGRhdGUgZXZlbnQncyBkYXRhIHByb3BlcnR5IGRvZXMgbm90IGFsd2F5cyBhY2N1cmF0ZWx5IGRlc2NyaWJlXG4gICAgICAgICAgICAvLyAgIHRoZSBjaGFyYWN0ZXIsIGEgY291bnRlciBleGFtcGxlIGJlaW5nIEtvcmVhbiB3aGVyZSBhbiBlbmRpbmcgY29uc29uc2FudCBjYW4gbW92ZSB0b1xuICAgICAgICAgICAgLy8gICB0aGUgZm9sbG93aW5nIGNoYXJhY3RlciBpZiB0aGUgZm9sbG93aW5nIGlucHV0IGlzIGEgdm93ZWwuXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmlzU2VuZGluZ0NvbXBvc2l0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBpbnB1dCBoYXMgbm90IGFscmVhZHkgYmVlbiBzZW50XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuaXNTZW5kaW5nQ29tcG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5pc1NlbmRpbmdDb21wb3NpdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5wdXQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmlzQ29tcG9zaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIGVuZCBwb3NpdGlvbiB0byBnZXQgdGhlIHN0cmluZyBpZiBhIG5ldyBjb21wb3NpdGlvbiBoYXMgc3RhcnRlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0ID0gc2VsZi50ZXh0YXJlYS52YWx1ZS5zdWJzdHJpbmcoY3VycmVudENvbXBvc2l0aW9uUG9zaXRpb24uc3RhcnQsIGN1cnJlbnRDb21wb3NpdGlvblBvc2l0aW9uLmVuZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCB1c2UgdGhlIGVuZCBwb3NpdGlvbiBoZXJlIGluIG9yZGVyIHRvIHBpY2sgdXAgYW55IGNoYXJhY3RlcnMgYWZ0ZXIgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb21wb3NpdGlvbiBoYXMgZmluaXNoZWQsIGZvciBleGFtcGxlIHdoZW4gdHlwaW5nIGEgbm9uLWNvbXBvc2l0aW9uIGNoYXJhY3RlclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gKGVnLiAyKSBhZnRlciBhIGNvbXBvc2l0aW9uIGNoYXJhY3Rlci5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0ID0gc2VsZi50ZXh0YXJlYS52YWx1ZS5zdWJzdHJpbmcoY3VycmVudENvbXBvc2l0aW9uUG9zaXRpb24uc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNlbGYudGVybWluYWwuaGFuZGxlcihpbnB1dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFwcGx5IGFueSBjaGFuZ2VzIG1hZGUgdG8gdGhlIHRleHRhcmVhIGFmdGVyIHRoZSBjdXJyZW50IGV2ZW50IGNoYWluIGlzIGFsbG93ZWQgdG8gY29tcGxldGUuXG4gICAgICogVGhpcyBzaG91bGQgYmUgY2FsbGVkIHdoZW4gbm90IGN1cnJlbnRseSBjb21wb3NpbmcgYnV0IGEga2V5ZG93biBldmVudCB3aXRoIHRoZSBcImNvbXBvc2l0aW9uXG4gICAgICogY2hhcmFjdGVyXCIgKDIyOSkgaXMgdHJpZ2dlcmVkLCBpbiBvcmRlciB0byBhbGxvdyBub24tY29tcG9zaXRpb24gdGV4dCB0byBiZSBlbnRlcmVkIHdoZW4gYW5cbiAgICAgKiBJTUUgaXMgYWN0aXZlLlxuICAgICAqL1xuICAgIENvbXBvc2l0aW9uSGVscGVyLnByb3RvdHlwZS5oYW5kbGVBbnlUZXh0YXJlYUNoYW5nZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMudGV4dGFyZWEudmFsdWU7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBJZ25vcmUgaWYgYSBjb21wb3NpdGlvbiBoYXMgc3RhcnRlZCBzaW5jZSB0aGUgdGltZW91dFxuICAgICAgICAgICAgaWYgKCFzZWxmLmlzQ29tcG9zaW5nKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1ZhbHVlID0gc2VsZi50ZXh0YXJlYS52YWx1ZTtcbiAgICAgICAgICAgICAgICB2YXIgZGlmZiA9IG5ld1ZhbHVlLnJlcGxhY2Uob2xkVmFsdWUsICcnKTtcbiAgICAgICAgICAgICAgICBpZiAoZGlmZi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYudGVybWluYWwuaGFuZGxlcihkaWZmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIDApO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUG9zaXRpb25zIHRoZSBjb21wb3NpdGlvbiB2aWV3IG9uIHRvcCBvZiB0aGUgY3Vyc29yIGFuZCB0aGUgdGV4dGFyZWEganVzdCBiZWxvdyBpdCAoc28gdGhlXG4gICAgICogSU1FIGhlbHBlciBkaWFsb2cgaXMgcG9zaXRpb25lZCBjb3JyZWN0bHkpLlxuICAgICAqIEBwYXJhbSBkb250UmVjdXJzZSBXaGV0aGVyIHRvIHVzZSBzZXRUaW1lb3V0IHRvIHJlY3Vyc2l2ZWx5IHRyaWdnZXIgYW5vdGhlciB1cGRhdGUsIHRoaXMgaXNcbiAgICAgKiAgIG5lY2Vzc2FyeSBhcyB0aGUgSU1FIGV2ZW50cyBhY3Jvc3MgYnJvd3NlcnMgYXJlIG5vdCBjb25zaXN0ZW50bHkgdHJpZ2dlcmVkLlxuICAgICAqL1xuICAgIENvbXBvc2l0aW9uSGVscGVyLnByb3RvdHlwZS51cGRhdGVDb21wb3NpdGlvbkVsZW1lbnRzID0gZnVuY3Rpb24gKGRvbnRSZWN1cnNlKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0NvbXBvc2luZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjdXJzb3IgPSB0aGlzLnRlcm1pbmFsLmVsZW1lbnQucXVlcnlTZWxlY3RvcignLnRlcm1pbmFsLWN1cnNvcicpO1xuICAgICAgICBpZiAoY3Vyc29yKSB7XG4gICAgICAgICAgICAvLyBUYWtlIC54dGVybS1yb3dzIG9mZnNldFRvcCBpbnRvIGFjY291bnQgYXMgd2VsbCBpbiBjYXNlIGl0J3MgcG9zaXRpb25lZCBhYnNvbHV0ZWx5IHdpdGhpblxuICAgICAgICAgICAgLy8gdGhlIC54dGVybSBlbGVtZW50LlxuICAgICAgICAgICAgdmFyIHh0ZXJtUm93cyA9IHRoaXMudGVybWluYWwuZWxlbWVudC5xdWVyeVNlbGVjdG9yKCcueHRlcm0tcm93cycpO1xuICAgICAgICAgICAgdmFyIGN1cnNvclRvcCA9IHh0ZXJtUm93cy5vZmZzZXRUb3AgKyBjdXJzb3Iub2Zmc2V0VG9wO1xuICAgICAgICAgICAgdGhpcy5jb21wb3NpdGlvblZpZXcuc3R5bGUubGVmdCA9IGN1cnNvci5vZmZzZXRMZWZ0ICsgJ3B4JztcbiAgICAgICAgICAgIHRoaXMuY29tcG9zaXRpb25WaWV3LnN0eWxlLnRvcCA9IGN1cnNvclRvcCArICdweCc7XG4gICAgICAgICAgICB0aGlzLmNvbXBvc2l0aW9uVmlldy5zdHlsZS5oZWlnaHQgPSBjdXJzb3Iub2Zmc2V0SGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgICAgIHRoaXMuY29tcG9zaXRpb25WaWV3LnN0eWxlLmxpbmVIZWlnaHQgPSBjdXJzb3Iub2Zmc2V0SGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgICAgIC8vIFN5bmMgdGhlIHRleHRhcmVhIHRvIHRoZSBleGFjdCBwb3NpdGlvbiBvZiB0aGUgY29tcG9zaXRpb24gdmlldyBzbyB0aGUgSU1FIGtub3dzIHdoZXJlIHRoZVxuICAgICAgICAgICAgLy8gdGV4dCBpcy5cbiAgICAgICAgICAgIHZhciBjb21wb3NpdGlvblZpZXdCb3VuZHMgPSB0aGlzLmNvbXBvc2l0aW9uVmlldy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIHRoaXMudGV4dGFyZWEuc3R5bGUubGVmdCA9IGN1cnNvci5vZmZzZXRMZWZ0ICsgJ3B4JztcbiAgICAgICAgICAgIHRoaXMudGV4dGFyZWEuc3R5bGUudG9wID0gY3Vyc29yVG9wICsgJ3B4JztcbiAgICAgICAgICAgIHRoaXMudGV4dGFyZWEuc3R5bGUud2lkdGggPSBjb21wb3NpdGlvblZpZXdCb3VuZHMud2lkdGggKyAncHgnO1xuICAgICAgICAgICAgdGhpcy50ZXh0YXJlYS5zdHlsZS5oZWlnaHQgPSBjb21wb3NpdGlvblZpZXdCb3VuZHMuaGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgICAgIHRoaXMudGV4dGFyZWEuc3R5bGUubGluZUhlaWdodCA9IGNvbXBvc2l0aW9uVmlld0JvdW5kcy5oZWlnaHQgKyAncHgnO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZG9udFJlY3Vyc2UpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQodGhpcy51cGRhdGVDb21wb3NpdGlvbkVsZW1lbnRzLmJpbmQodGhpcywgdHJ1ZSksIDApO1xuICAgICAgICB9XG4gICAgfTtcbiAgICA7XG4gICAgLyoqXG4gICAgICogQ2xlYXJzIHRoZSB0ZXh0YXJlYSdzIHBvc2l0aW9uIHNvIHRoYXQgdGhlIGN1cnNvciBkb2VzIG5vdCBibGluayBvbiBJRS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIENvbXBvc2l0aW9uSGVscGVyLnByb3RvdHlwZS5jbGVhclRleHRhcmVhUG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudGV4dGFyZWEuc3R5bGUubGVmdCA9ICcnO1xuICAgICAgICB0aGlzLnRleHRhcmVhLnN0eWxlLnRvcCA9ICcnO1xuICAgIH07XG4gICAgO1xuICAgIHJldHVybiBDb21wb3NpdGlvbkhlbHBlcjtcbn0oKSk7XG5leHBvcnRzLkNvbXBvc2l0aW9uSGVscGVyID0gQ29tcG9zaXRpb25IZWxwZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db21wb3NpdGlvbkhlbHBlci5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi94dGVybS9saWIvQ29tcG9zaXRpb25IZWxwZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG59XG5leHBvcnRzLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiAodHlwZSwgbGlzdGVuZXIpIHtcbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSB0aGlzLl9ldmVudHNbdHlwZV0gfHwgW107XG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xufTtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uICh0eXBlLCBsaXN0ZW5lcikge1xuICAgIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgICAgICByZXR1cm47XG4gICAgdmFyIG9iaiA9IHRoaXMuX2V2ZW50c1t0eXBlXSwgaSA9IG9iai5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgICBpZiAob2JqW2ldID09PSBsaXN0ZW5lciB8fCBvYmpbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBvYmouc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxufTtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBpZiAodGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xufTtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uICh0eXBlLCBsaXN0ZW5lcikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBmdW5jdGlvbiBvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIG9uKTtcbiAgICAgICAgcmV0dXJuIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgICBvbi5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgIHJldHVybiB0aGlzLm9uKHR5cGUsIG9uKTtcbn07XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgICAgICByZXR1cm47XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLCBvYmogPSB0aGlzLl9ldmVudHNbdHlwZV0sIGwgPSBvYmoubGVuZ3RoLCBpID0gMDtcbiAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgICAgICBvYmpbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxufTtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICByZXR1cm4gdGhpcy5fZXZlbnRzW3R5cGVdID0gdGhpcy5fZXZlbnRzW3R5cGVdIHx8IFtdO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUV2ZW50RW1pdHRlci5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi94dGVybS9saWIvRXZlbnRFbWl0dGVyLmpzXG4gKiogbW9kdWxlIGlkID0gM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIHZpZXdwb3J0IG9mIGEgdGVybWluYWwsIHRoZSB2aXNpYmxlIGFyZWEgd2l0aGluIHRoZSBsYXJnZXIgYnVmZmVyIG9mIG91dHB1dC5cbiAqIExvZ2ljIGZvciB0aGUgdmlydHVhbCBzY3JvbGwgYmFyIGlzIGluY2x1ZGVkIGluIHRoaXMgb2JqZWN0LlxuICovXG52YXIgVmlld3BvcnQgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgVmlld3BvcnQuXG4gICAgICogQHBhcmFtIHRlcm1pbmFsIFRoZSB0ZXJtaW5hbCB0aGlzIHZpZXdwb3J0IGJlbG9uZ3MgdG8uXG4gICAgICogQHBhcmFtIHZpZXdwb3J0RWxlbWVudCBUaGUgRE9NIGVsZW1lbnQgYWN0aW5nIGFzIHRoZSB2aWV3cG9ydC5cbiAgICAgKiBAcGFyYW0gc2Nyb2xsQXJlYSBUaGUgRE9NIGVsZW1lbnQgYWN0aW5nIGFzIHRoZSBzY3JvbGwgYXJlYS5cbiAgICAgKiBAcGFyYW0gY2hhck1lYXN1cmVFbGVtZW50IEEgRE9NIGVsZW1lbnQgdXNlZCB0byBtZWFzdXJlIHRoZSBjaGFyYWN0ZXIgc2l6ZSBvZi4gdGhlIHRlcm1pbmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFZpZXdwb3J0KHRlcm1pbmFsLCB2aWV3cG9ydEVsZW1lbnQsIHNjcm9sbEFyZWEsIGNoYXJNZWFzdXJlRWxlbWVudCkge1xuICAgICAgICB0aGlzLnRlcm1pbmFsID0gdGVybWluYWw7XG4gICAgICAgIHRoaXMudmlld3BvcnRFbGVtZW50ID0gdmlld3BvcnRFbGVtZW50O1xuICAgICAgICB0aGlzLnNjcm9sbEFyZWEgPSBzY3JvbGxBcmVhO1xuICAgICAgICB0aGlzLmNoYXJNZWFzdXJlRWxlbWVudCA9IGNoYXJNZWFzdXJlRWxlbWVudDtcbiAgICAgICAgdGhpcy5jdXJyZW50Um93SGVpZ2h0ID0gMDtcbiAgICAgICAgdGhpcy5sYXN0UmVjb3JkZWRCdWZmZXJMZW5ndGggPSAwO1xuICAgICAgICB0aGlzLmxhc3RSZWNvcmRlZFZpZXdwb3J0SGVpZ2h0ID0gMDtcbiAgICAgICAgdGhpcy50ZXJtaW5hbC5vbignc2Nyb2xsJywgdGhpcy5zeW5jU2Nyb2xsQXJlYS5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy50ZXJtaW5hbC5vbigncmVzaXplJywgdGhpcy5zeW5jU2Nyb2xsQXJlYS5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy52aWV3cG9ydEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5vblNjcm9sbC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5zeW5jU2Nyb2xsQXJlYSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWZyZXNoZXMgcm93IGhlaWdodCwgc2V0dGluZyBsaW5lLWhlaWdodCwgdmlld3BvcnQgaGVpZ2h0IGFuZCBzY3JvbGwgYXJlYSBoZWlnaHQgaWZcbiAgICAgKiBuZWNlc3NhcnkuXG4gICAgICogQHBhcmFtIGNoYXJTaXplIEEgY2hhcmFjdGVyIHNpemUgbWVhc3VyZW1lbnQgYm91bmRpbmcgcmVjdCBvYmplY3QsIGlmIGl0IGRvZXNuJ3QgZXhpc3QgaXQgd2lsbFxuICAgICAqICAgYmUgY3JlYXRlZC5cbiAgICAgKi9cbiAgICBWaWV3cG9ydC5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uIChjaGFyU2l6ZSkge1xuICAgICAgICB2YXIgc2l6ZSA9IGNoYXJTaXplIHx8IHRoaXMuY2hhck1lYXN1cmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAoc2l6ZS5oZWlnaHQgPiAwKSB7XG4gICAgICAgICAgICB2YXIgcm93SGVpZ2h0Q2hhbmdlZCA9IHNpemUuaGVpZ2h0ICE9PSB0aGlzLmN1cnJlbnRSb3dIZWlnaHQ7XG4gICAgICAgICAgICBpZiAocm93SGVpZ2h0Q2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFJvd0hlaWdodCA9IHNpemUuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIHRoaXMudmlld3BvcnRFbGVtZW50LnN0eWxlLmxpbmVIZWlnaHQgPSBzaXplLmhlaWdodCArICdweCc7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXJtaW5hbC5yb3dDb250YWluZXIuc3R5bGUubGluZUhlaWdodCA9IHNpemUuaGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB2aWV3cG9ydEhlaWdodENoYW5nZWQgPSB0aGlzLmxhc3RSZWNvcmRlZFZpZXdwb3J0SGVpZ2h0ICE9PSB0aGlzLnRlcm1pbmFsLnJvd3M7XG4gICAgICAgICAgICBpZiAocm93SGVpZ2h0Q2hhbmdlZCB8fCB2aWV3cG9ydEhlaWdodENoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RSZWNvcmRlZFZpZXdwb3J0SGVpZ2h0ID0gdGhpcy50ZXJtaW5hbC5yb3dzO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld3BvcnRFbGVtZW50LnN0eWxlLmhlaWdodCA9IHNpemUuaGVpZ2h0ICogdGhpcy50ZXJtaW5hbC5yb3dzICsgJ3B4JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQXJlYS5zdHlsZS5oZWlnaHQgPSAoc2l6ZS5oZWlnaHQgKiB0aGlzLmxhc3RSZWNvcmRlZEJ1ZmZlckxlbmd0aCkgKyAncHgnO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGRpbWVuc2lvbnMgYW5kIHN5bmNocm9uaXplcyB0aGUgc2Nyb2xsIGFyZWEgaWYgbmVjZXNzYXJ5LlxuICAgICAqL1xuICAgIFZpZXdwb3J0LnByb3RvdHlwZS5zeW5jU2Nyb2xsQXJlYSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubGFzdFJlY29yZGVkQnVmZmVyTGVuZ3RoICE9PSB0aGlzLnRlcm1pbmFsLmxpbmVzLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gSWYgYnVmZmVyIGhlaWdodCBjaGFuZ2VkXG4gICAgICAgICAgICB0aGlzLmxhc3RSZWNvcmRlZEJ1ZmZlckxlbmd0aCA9IHRoaXMudGVybWluYWwubGluZXMubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5sYXN0UmVjb3JkZWRWaWV3cG9ydEhlaWdodCAhPT0gdGhpcy50ZXJtaW5hbC5yb3dzKSB7XG4gICAgICAgICAgICAvLyBJZiB2aWV3cG9ydCBoZWlnaHQgY2hhbmdlZFxuICAgICAgICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiBzaXplIGhhcyBjaGFuZ2VkLCByZWZyZXNoIHZpZXdwb3J0XG4gICAgICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuY2hhck1lYXN1cmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgaWYgKHNpemUuaGVpZ2h0ICE9PSB0aGlzLmN1cnJlbnRSb3dIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2goc2l6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3luYyBzY3JvbGxUb3BcbiAgICAgICAgdmFyIHNjcm9sbFRvcCA9IHRoaXMudGVybWluYWwueWRpc3AgKiB0aGlzLmN1cnJlbnRSb3dIZWlnaHQ7XG4gICAgICAgIGlmICh0aGlzLnZpZXdwb3J0RWxlbWVudC5zY3JvbGxUb3AgIT09IHNjcm9sbFRvcCkge1xuICAgICAgICAgICAgdGhpcy52aWV3cG9ydEVsZW1lbnQuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHNjcm9sbCBldmVudHMgb24gdGhlIHZpZXdwb3J0LCBjYWxjdWxhdGluZyB0aGUgbmV3IHZpZXdwb3J0IGFuZCByZXF1ZXN0aW5nIHRoZVxuICAgICAqIHRlcm1pbmFsIHRvIHNjcm9sbCB0byBpdC5cbiAgICAgKiBAcGFyYW0gZXYgVGhlIHNjcm9sbCBldmVudC5cbiAgICAgKi9cbiAgICBWaWV3cG9ydC5wcm90b3R5cGUub25TY3JvbGwgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgdmFyIG5ld1JvdyA9IE1hdGgucm91bmQodGhpcy52aWV3cG9ydEVsZW1lbnQuc2Nyb2xsVG9wIC8gdGhpcy5jdXJyZW50Um93SGVpZ2h0KTtcbiAgICAgICAgdmFyIGRpZmYgPSBuZXdSb3cgLSB0aGlzLnRlcm1pbmFsLnlkaXNwO1xuICAgICAgICB0aGlzLnRlcm1pbmFsLnNjcm9sbERpc3AoZGlmZiwgdHJ1ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIG1vdXNlIHdoZWVsIGV2ZW50cyBieSBhZGp1c3RpbmcgdGhlIHZpZXdwb3J0J3Mgc2Nyb2xsVG9wIGFuZCBkZWxlZ2F0aW5nIHRoZSBhY3R1YWxcbiAgICAgKiBzY3JvbGxpbmcgdG8gYG9uU2Nyb2xsYCwgdGhpcyBldmVudCBuZWVkcyB0byBiZSBhdHRhY2hlZCBtYW51YWxseSBieSB0aGUgY29uc3VtZXIgb2ZcbiAgICAgKiBgVmlld3BvcnRgLlxuICAgICAqIEBwYXJhbSBldiBUaGUgbW91c2Ugd2hlZWwgZXZlbnQuXG4gICAgICovXG4gICAgVmlld3BvcnQucHJvdG90eXBlLm9uV2hlZWwgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgaWYgKGV2LmRlbHRhWSA9PT0gMCkge1xuICAgICAgICAgICAgLy8gRG8gbm90aGluZyBpZiBpdCdzIG5vdCBhIHZlcnRpY2FsIHNjcm9sbCBldmVudFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZhbGxiYWNrIHRvIFdoZWVsRXZlbnQuRE9NX0RFTFRBX1BJWEVMXG4gICAgICAgIHZhciBtdWx0aXBsaWVyID0gMTtcbiAgICAgICAgaWYgKGV2LmRlbHRhTW9kZSA9PT0gV2hlZWxFdmVudC5ET01fREVMVEFfTElORSkge1xuICAgICAgICAgICAgbXVsdGlwbGllciA9IHRoaXMuY3VycmVudFJvd0hlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChldi5kZWx0YU1vZGUgPT09IFdoZWVsRXZlbnQuRE9NX0RFTFRBX1BBR0UpIHtcbiAgICAgICAgICAgIG11bHRpcGxpZXIgPSB0aGlzLmN1cnJlbnRSb3dIZWlnaHQgKiB0aGlzLnRlcm1pbmFsLnJvd3M7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52aWV3cG9ydEVsZW1lbnQuc2Nyb2xsVG9wICs9IGV2LmRlbHRhWSAqIG11bHRpcGxpZXI7XG4gICAgICAgIC8vIFByZXZlbnQgdGhlIHBhZ2UgZnJvbSBzY3JvbGxpbmcgd2hlbiB0aGUgdGVybWluYWwgc2Nyb2xsc1xuICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH07XG4gICAgO1xuICAgIHJldHVybiBWaWV3cG9ydDtcbn0oKSk7XG5leHBvcnRzLlZpZXdwb3J0ID0gVmlld3BvcnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1WaWV3cG9ydC5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi94dGVybS9saWIvVmlld3BvcnQuanNcbiAqKiBtb2R1bGUgaWQgPSA0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENsaXBib2FyZCBoYW5kbGVyIG1vZHVsZTogZXhwb3J0cyBtZXRob2RzIGZvciBoYW5kbGluZyBhbGwgY2xpcGJvYXJkLXJlbGF0ZWQgZXZlbnRzIGluIHRoZVxuICogdGVybWluYWwuXG4gKiBAbW9kdWxlIHh0ZXJtL2hhbmRsZXJzL0NsaXBib2FyZFxuICogQGxpY2Vuc2UgTUlUXG4gKi9cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBQcmVwYXJlcyB0ZXh0IGNvcGllZCBmcm9tIHRlcm1pbmFsIHNlbGVjdGlvbiwgdG8gYmUgc2F2ZWQgaW4gdGhlIGNsaXBib2FyZCBieTpcbiAqICAgMS4gc3RyaXBwaW5nIGFsbCB0cmFpbGluZyB3aGl0ZSBzcGFjZXNcbiAqICAgMi4gY29udmVydGluZyBhbGwgbm9uLWJyZWFraW5nIHNwYWNlcyB0byByZWd1bGFyIHNwYWNlc1xuICogQHBhcmFtIHtzdHJpbmd9IHRleHQgVGhlIGNvcGllZCB0ZXh0IHRoYXQgbmVlZHMgcHJvY2Vzc2luZyBmb3Igc3RvcmluZyBpbiBjbGlwYm9hcmRcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHByZXBhcmVUZXh0Rm9yQ2xpcGJvYXJkKHRleHQpIHtcbiAgICB2YXIgc3BhY2UgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDMyKSwgbm9uQnJlYWtpbmdTcGFjZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMTYwKSwgYWxsTm9uQnJlYWtpbmdTcGFjZXMgPSBuZXcgUmVnRXhwKG5vbkJyZWFraW5nU3BhY2UsICdnJyksIHByb2Nlc3NlZFRleHQgPSB0ZXh0LnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgLy8gU3RyaXAgYWxsIHRyYWlsaW5nIHdoaXRlIHNwYWNlcyBhbmQgY29udmVydCBhbGwgbm9uLWJyZWFraW5nIHNwYWNlc1xuICAgICAgICAvLyB0byByZWd1bGFyIHNwYWNlcy5cbiAgICAgICAgdmFyIHByb2Nlc3NlZExpbmUgPSBsaW5lLnJlcGxhY2UoL1xccyskL2csICcnKS5yZXBsYWNlKGFsbE5vbkJyZWFraW5nU3BhY2VzLCBzcGFjZSk7XG4gICAgICAgIHJldHVybiBwcm9jZXNzZWRMaW5lO1xuICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgIHJldHVybiBwcm9jZXNzZWRUZXh0O1xufVxuZXhwb3J0cy5wcmVwYXJlVGV4dEZvckNsaXBib2FyZCA9IHByZXBhcmVUZXh0Rm9yQ2xpcGJvYXJkO1xuLyoqXG4gKiBCaW5kcyBjb3B5IGZ1bmN0aW9uYWxpdHkgdG8gdGhlIGdpdmVuIHRlcm1pbmFsLlxuICogQHBhcmFtIHtDbGlwYm9hcmRFdmVudH0gZXYgVGhlIG9yaWdpbmFsIGNvcHkgZXZlbnQgdG8gYmUgaGFuZGxlZFxuICovXG5mdW5jdGlvbiBjb3B5SGFuZGxlcihldiwgdGVybSkge1xuICAgIC8vIFdlIGNhc3QgYHdpbmRvd2AgdG8gYGFueWAgdHlwZSwgYmVjYXVzZSBUeXBlU2NyaXB0IGhhcyBub3QgZGVjbGFyZWQgdGhlIGBjbGlwYm9hcmREYXRhYFxuICAgIC8vIHByb3BlcnR5IHRoYXQgd2UgdXNlIGJlbG93IGZvciBJbnRlcm5ldCBFeHBsb3Jlci5cbiAgICB2YXIgY29waWVkVGV4dCA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKS50b1N0cmluZygpLCB0ZXh0ID0gcHJlcGFyZVRleHRGb3JDbGlwYm9hcmQoY29waWVkVGV4dCk7XG4gICAgaWYgKHRlcm0uYnJvd3Nlci5pc01TSUUpIHtcbiAgICAgICAgd2luZG93LmNsaXBib2FyZERhdGEuc2V0RGF0YSgnVGV4dCcsIHRleHQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZXYuY2xpcGJvYXJkRGF0YS5zZXREYXRhKCd0ZXh0L3BsYWluJywgdGV4dCk7XG4gICAgfVxuICAgIGV2LnByZXZlbnREZWZhdWx0KCk7IC8vIFByZXZlbnQgb3IgdGhlIG9yaWdpbmFsIHRleHQgd2lsbCBiZSBjb3BpZWQuXG59XG5leHBvcnRzLmNvcHlIYW5kbGVyID0gY29weUhhbmRsZXI7XG4vKipcbiAqIFJlZGlyZWN0IHRoZSBjbGlwYm9hcmQncyBkYXRhIHRvIHRoZSB0ZXJtaW5hbCdzIGlucHV0IGhhbmRsZXIuXG4gKiBAcGFyYW0ge0NsaXBib2FyZEV2ZW50fSBldiBUaGUgb3JpZ2luYWwgcGFzdGUgZXZlbnQgdG8gYmUgaGFuZGxlZFxuICogQHBhcmFtIHtUZXJtaW5hbH0gdGVybSBUaGUgdGVybWluYWwgb24gd2hpY2ggdG8gYXBwbHkgdGhlIGhhbmRsZWQgcGFzdGUgZXZlbnRcbiAqL1xuZnVuY3Rpb24gcGFzdGVIYW5kbGVyKGV2LCB0ZXJtKSB7XG4gICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgdmFyIHRleHQ7XG4gICAgdmFyIGRpc3BhdGNoUGFzdGUgPSBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICB0ZXJtLmhhbmRsZXIodGV4dCk7XG4gICAgICAgIHRlcm0udGV4dGFyZWEudmFsdWUgPSAnJztcbiAgICAgICAgcmV0dXJuIHRlcm0uY2FuY2VsKGV2KTtcbiAgICB9O1xuICAgIGlmICh0ZXJtLmJyb3dzZXIuaXNNU0lFKSB7XG4gICAgICAgIGlmICh3aW5kb3cuY2xpcGJvYXJkRGF0YSkge1xuICAgICAgICAgICAgdGV4dCA9IHdpbmRvdy5jbGlwYm9hcmREYXRhLmdldERhdGEoJ1RleHQnKTtcbiAgICAgICAgICAgIGRpc3BhdGNoUGFzdGUodGV4dCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChldi5jbGlwYm9hcmREYXRhKSB7XG4gICAgICAgICAgICB0ZXh0ID0gZXYuY2xpcGJvYXJkRGF0YS5nZXREYXRhKCd0ZXh0L3BsYWluJyk7XG4gICAgICAgICAgICBkaXNwYXRjaFBhc3RlKHRleHQpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5wYXN0ZUhhbmRsZXIgPSBwYXN0ZUhhbmRsZXI7XG4vKipcbiAqIEJpbmQgdG8gcmlnaHQtY2xpY2sgZXZlbnQgYW5kIGFsbG93IHJpZ2h0LWNsaWNrIGNvcHkgYW5kIHBhc3RlLlxuICpcbiAqICoqTG9naWMqKlxuICogSWYgdGV4dCBpcyBzZWxlY3RlZCBhbmQgcmlnaHQtY2xpY2sgaGFwcGVucyBvbiBzZWxlY3RlZCB0ZXh0LCB0aGVuXG4gKiBkbyBub3RoaW5nIHRvIGFsbG93IHNlYW1sZXNzIGNvcHlpbmcuXG4gKiBJZiBubyB0ZXh0IGlzIHNlbGVjdGVkIG9yIHJpZ2h0LWNsaWNrIGlzIG91dHNpZGUgb2YgdGhlIHNlbGVjdGlvblxuICogYXJlYSwgdGhlbiBicmluZyB0aGUgdGVybWluYWwncyBpbnB1dCBiZWxvdyB0aGUgY3Vyc29yLCBpbiBvcmRlciB0b1xuICogdHJpZ2dlciB0aGUgZXZlbnQgb24gdGhlIHRleHRhcmVhIGFuZCBhbGxvdy1yaWdodCBjbGljayBwYXN0ZSwgd2l0aG91dFxuICogY2FyaW5nIGFib3V0IGRpc2FwcGVhcmluZyBzZWxlY3Rpb24uXG4gKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2IFRoZSBvcmlnaW5hbCByaWdodCBjbGljayBldmVudCB0byBiZSBoYW5kbGVkXG4gKiBAcGFyYW0ge1Rlcm1pbmFsfSB0ZXJtIFRoZSB0ZXJtaW5hbCBvbiB3aGljaCB0byBhcHBseSB0aGUgaGFuZGxlZCBwYXN0ZSBldmVudFxuICovXG5mdW5jdGlvbiByaWdodENsaWNrSGFuZGxlcihldiwgdGVybSkge1xuICAgIHZhciBzID0gZG9jdW1lbnQuZ2V0U2VsZWN0aW9uKCksIHNlbGVjdGVkVGV4dCA9IHByZXBhcmVUZXh0Rm9yQ2xpcGJvYXJkKHMudG9TdHJpbmcoKSksIGNsaWNrSXNPblNlbGVjdGlvbiA9IGZhbHNlLCB4ID0gZXYuY2xpZW50WCwgeSA9IGV2LmNsaWVudFk7XG4gICAgaWYgKHMucmFuZ2VDb3VudCkge1xuICAgICAgICB2YXIgciA9IHMuZ2V0UmFuZ2VBdCgwKSwgY3IgPSByLmdldENsaWVudFJlY3RzKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3IubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciByZWN0ID0gY3JbaV07XG4gICAgICAgICAgICBjbGlja0lzT25TZWxlY3Rpb24gPSAoKHggPiByZWN0LmxlZnQpICYmICh4IDwgcmVjdC5yaWdodCkgJiZcbiAgICAgICAgICAgICAgICAoeSA+IHJlY3QudG9wKSAmJiAoeSA8IHJlY3QuYm90dG9tKSk7XG4gICAgICAgICAgICBpZiAoY2xpY2tJc09uU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgY2xpY2tlZCBvbiBzZWxlY3Rpb24gYW5kIHNlbGVjdGlvbiBpcyBub3QgYSBzaW5nbGUgc3BhY2UsXG4gICAgICAgIC8vIHRoZW4gbWFyayB0aGUgcmlnaHQgY2xpY2sgYXMgY29weS1vbmx5LiBXZSBjaGVjayBmb3IgdGhlIHNpbmdsZVxuICAgICAgICAvLyBzcGFjZSBzZWxlY3Rpb24sIGFzIHRoaXMgY2FuIGhhcHBlbiB3aGVuIGNsaWNraW5nIG9uIGFuICZuYnNwO1xuICAgICAgICAvLyBhbmQgdGhlcmUgaXMgbm90IG11Y2ggcG9pbnRpbmcgaW4gY29weWluZyBhIHNpbmdsZSBzcGFjZS5cbiAgICAgICAgaWYgKHNlbGVjdGVkVGV4dC5tYXRjaCgvXlxccyQvKSB8fCAhc2VsZWN0ZWRUZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgY2xpY2tJc09uU2VsZWN0aW9uID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQnJpbmcgdGV4dGFyZWEgYXQgdGhlIGN1cnNvciBwb3NpdGlvblxuICAgIGlmICghY2xpY2tJc09uU2VsZWN0aW9uKSB7XG4gICAgICAgIHRlcm0udGV4dGFyZWEuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuICAgICAgICB0ZXJtLnRleHRhcmVhLnN0eWxlLndpZHRoID0gJzIwcHgnO1xuICAgICAgICB0ZXJtLnRleHRhcmVhLnN0eWxlLmhlaWdodCA9ICcyMHB4JztcbiAgICAgICAgdGVybS50ZXh0YXJlYS5zdHlsZS5sZWZ0ID0gKHggLSAxMCkgKyAncHgnO1xuICAgICAgICB0ZXJtLnRleHRhcmVhLnN0eWxlLnRvcCA9ICh5IC0gMTApICsgJ3B4JztcbiAgICAgICAgdGVybS50ZXh0YXJlYS5zdHlsZS56SW5kZXggPSAnMTAwMCc7XG4gICAgICAgIHRlcm0udGV4dGFyZWEuZm9jdXMoKTtcbiAgICAgICAgLy8gUmVzZXQgdGhlIHRlcm1pbmFsIHRleHRhcmVhJ3Mgc3R5bGluZ1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRlcm0udGV4dGFyZWEuc3R5bGUucG9zaXRpb24gPSBudWxsO1xuICAgICAgICAgICAgdGVybS50ZXh0YXJlYS5zdHlsZS53aWR0aCA9IG51bGw7XG4gICAgICAgICAgICB0ZXJtLnRleHRhcmVhLnN0eWxlLmhlaWdodCA9IG51bGw7XG4gICAgICAgICAgICB0ZXJtLnRleHRhcmVhLnN0eWxlLmxlZnQgPSBudWxsO1xuICAgICAgICAgICAgdGVybS50ZXh0YXJlYS5zdHlsZS50b3AgPSBudWxsO1xuICAgICAgICAgICAgdGVybS50ZXh0YXJlYS5zdHlsZS56SW5kZXggPSBudWxsO1xuICAgICAgICB9LCA0KTtcbiAgICB9XG59XG5leHBvcnRzLnJpZ2h0Q2xpY2tIYW5kbGVyID0gcmlnaHRDbGlja0hhbmRsZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DbGlwYm9hcmQuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34veHRlcm0vbGliL2hhbmRsZXJzL0NsaXBib2FyZC5qc1xuICoqIG1vZHVsZSBpZCA9IDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQXR0cmlidXRlcyBhbmQgbWV0aG9kcyB0byBoZWxwIHdpdGggaWRlbnRpZnlpbmcgdGhlIGN1cnJlbnQgYnJvd3NlciBhbmQgcGxhdGZvcm0uXG4gKiBAbW9kdWxlIHh0ZXJtL3V0aWxzL0Jyb3dzZXJcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cInVzZSBzdHJpY3RcIjtcbnZhciBHZW5lcmljX2pzXzEgPSByZXF1aXJlKFwiLi9HZW5lcmljLmpzXCIpO1xudmFyIGlzTm9kZSA9ICh0eXBlb2YgbmF2aWdhdG9yID09ICd1bmRlZmluZWQnKSA/IHRydWUgOiBmYWxzZTtcbnZhciB1c2VyQWdlbnQgPSAoaXNOb2RlKSA/ICdub2RlJyA6IG5hdmlnYXRvci51c2VyQWdlbnQ7XG52YXIgcGxhdGZvcm0gPSAoaXNOb2RlKSA/ICdub2RlJyA6IG5hdmlnYXRvci5wbGF0Zm9ybTtcbmV4cG9ydHMuaXNGaXJlZm94ID0gISF+dXNlckFnZW50LmluZGV4T2YoJ0ZpcmVmb3gnKTtcbmV4cG9ydHMuaXNNU0lFID0gISF+dXNlckFnZW50LmluZGV4T2YoJ01TSUUnKSB8fCAhIX51c2VyQWdlbnQuaW5kZXhPZignVHJpZGVudCcpO1xuLy8gRmluZCB0aGUgdXNlcnMgcGxhdGZvcm0uIFdlIHVzZSB0aGlzIHRvIGludGVycHJldCB0aGUgbWV0YSBrZXlcbi8vIGFuZCBJU08gdGhpcmQgbGV2ZWwgc2hpZnRzLlxuLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3EvMTk4Nzc5MjQvNTc3NTk4XG5leHBvcnRzLmlzTWFjID0gR2VuZXJpY19qc18xLmNvbnRhaW5zKFsnTWFjaW50b3NoJywgJ01hY0ludGVsJywgJ01hY1BQQycsICdNYWM2OEsnXSwgcGxhdGZvcm0pO1xuZXhwb3J0cy5pc0lwYWQgPSBwbGF0Zm9ybSA9PT0gJ2lQYWQnO1xuZXhwb3J0cy5pc0lwaG9uZSA9IHBsYXRmb3JtID09PSAnaVBob25lJztcbmV4cG9ydHMuaXNNU1dpbmRvd3MgPSBHZW5lcmljX2pzXzEuY29udGFpbnMoWydXaW5kb3dzJywgJ1dpbjE2JywgJ1dpbjMyJywgJ1dpbkNFJ10sIHBsYXRmb3JtKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJyb3dzZXIuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34veHRlcm0vbGliL3V0aWxzL0Jyb3dzZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIEdlbmVyaWMgdXRpbGl0aWVzIG1vZHVsZSB3aXRoIG1ldGhvZHMgdGhhdCBjYW4gYmUgaGVscGZ1bCBhdCBkaWZmZXJlbnQgcGFydHMgb2YgdGhlIGNvZGUgYmFzZS5cbiAqIEBtb2R1bGUgeHRlcm0vdXRpbHMvR2VuZXJpY1xuICogQGxpY2Vuc2UgTUlUXG4gKi9cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBSZXR1cm4gaWYgdGhlIGdpdmVuIGFycmF5IGNvbnRhaW5zIHRoZSBnaXZlbiBlbGVtZW50XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2VhcmNoIGZvciB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBlbCBUaGUgZWxlbWVudCB0byBsb29rIGZvciBpbnRvIHRoZSBhcnJheVxuICovXG5leHBvcnRzLmNvbnRhaW5zID0gZnVuY3Rpb24gKGFyciwgZWwpIHtcbiAgICByZXR1cm4gYXJyLmluZGV4T2YoZWwpID49IDA7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R2VuZXJpYy5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi94dGVybS9saWIvdXRpbHMvR2VuZXJpYy5qc1xuICoqIG1vZHVsZSBpZCA9IDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBtYXAgPSB7XG5cdFwiLi9hdHRhY2gvYXR0YWNoXCI6IDksXG5cdFwiLi9hdHRhY2gvYXR0YWNoLmpzXCI6IDksXG5cdFwiLi9maXQvZml0XCI6IDEwLFxuXHRcIi4vZml0L2ZpdC5qc1wiOiAxMCxcblx0XCIuL2Z1bGxzY3JlZW4vZnVsbHNjcmVlblwiOiAxMSxcblx0XCIuL2Z1bGxzY3JlZW4vZnVsbHNjcmVlbi5qc1wiOiAxMSxcblx0XCIuL2xpbmtpZnkvbGlua2lmeVwiOiAxMixcblx0XCIuL2xpbmtpZnkvbGlua2lmeS5qc1wiOiAxMixcblx0XCIuL3Rlcm1pbmFkby90ZXJtaW5hZG9cIjogMTMsXG5cdFwiLi90ZXJtaW5hZG8vdGVybWluYWRvLmpzXCI6IDEzXG59O1xuZnVuY3Rpb24gd2VicGFja0NvbnRleHQocmVxKSB7XG5cdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKHdlYnBhY2tDb250ZXh0UmVzb2x2ZShyZXEpKTtcbn07XG5mdW5jdGlvbiB3ZWJwYWNrQ29udGV4dFJlc29sdmUocmVxKSB7XG5cdHJldHVybiBtYXBbcmVxXSB8fCAoZnVuY3Rpb24oKSB7IHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIgKyByZXEgKyBcIicuXCIpIH0oKSk7XG59O1xud2VicGFja0NvbnRleHQua2V5cyA9IGZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0S2V5cygpIHtcblx0cmV0dXJuIE9iamVjdC5rZXlzKG1hcCk7XG59O1xud2VicGFja0NvbnRleHQucmVzb2x2ZSA9IHdlYnBhY2tDb250ZXh0UmVzb2x2ZTtcbm1vZHVsZS5leHBvcnRzID0gd2VicGFja0NvbnRleHQ7XG53ZWJwYWNrQ29udGV4dC5pZCA9IDg7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi94dGVybS9saWIvYWRkb25zIF5cXC5cXC8uKiRcbiAqKiBtb2R1bGUgaWQgPSA4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIEltcGxlbWVudHMgdGhlIGF0dGFjaCBtZXRob2QsIHRoYXQgYXR0YWNoZXMgdGhlIHRlcm1pbmFsIHRvIGEgV2ViU29ja2V0IHN0cmVhbS5cbiAqIEBtb2R1bGUgeHRlcm0vYWRkb25zL2F0dGFjaC9hdHRhY2hcbiAqIEBsaWNlbnNlIE1JVFxuICovXG4oZnVuY3Rpb24gKGF0dGFjaCkge1xuICAgIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgLypcbiAgICAgICAgICogQ29tbW9uSlMgZW52aXJvbm1lbnRcbiAgICAgICAgICovXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gYXR0YWNoKHJlcXVpcmUoJy4uLy4uL3h0ZXJtJykpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLypcbiAgICAgICAgICogUmVxdWlyZS5qcyBpcyBhdmFpbGFibGVcbiAgICAgICAgICovXG4gICAgICAgIGRlZmluZShbJy4uLy4uL3h0ZXJtJ10sIGF0dGFjaCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvKlxuICAgICAgICAgKiBQbGFpbiBicm93c2VyIGVudmlyb25tZW50XG4gICAgICAgICAqL1xuICAgICAgICBhdHRhY2god2luZG93LlRlcm1pbmFsKTtcbiAgICB9XG59KShmdW5jdGlvbiAoWHRlcm0pIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIGV4cG9ydHMgPSB7fTtcbiAgICAvKipcbiAgICAgKiBBdHRhY2hlcyB0aGUgZ2l2ZW4gdGVybWluYWwgdG8gdGhlIGdpdmVuIHNvY2tldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7WHRlcm19IHRlcm0gLSBUaGUgdGVybWluYWwgdG8gYmUgYXR0YWNoZWQgdG8gdGhlIGdpdmVuIHNvY2tldC5cbiAgICAgKiBAcGFyYW0ge1dlYlNvY2tldH0gc29ja2V0IC0gVGhlIHNvY2tldCB0byBhdHRhY2ggdGhlIGN1cnJlbnQgdGVybWluYWwuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBiaWRpcmVjdGlvbmFsIC0gV2hldGhlciB0aGUgdGVybWluYWwgc2hvdWxkIHNlbmQgZGF0YVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIHRoZSBzb2NrZXQgYXMgd2VsbC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGJ1ZmZlcmVkIC0gV2hldGhlciB0aGUgcmVuZGVyaW5nIG9mIGluY29taW5nIGRhdGFcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkIGhhcHBlbiBpbnN0YW50bHkgb3IgYXQgYSBtYXhpbXVtXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyZXF1ZW5jeSBvZiAxIHJlbmRlcmluZyBwZXIgMTBtcy5cbiAgICAgKi9cbiAgICBleHBvcnRzLmF0dGFjaCA9IGZ1bmN0aW9uICh0ZXJtLCBzb2NrZXQsIGJpZGlyZWN0aW9uYWwsIGJ1ZmZlcmVkKSB7XG4gICAgICAgIGJpZGlyZWN0aW9uYWwgPSAodHlwZW9mIGJpZGlyZWN0aW9uYWwgPT0gJ3VuZGVmaW5lZCcpID8gdHJ1ZSA6IGJpZGlyZWN0aW9uYWw7XG4gICAgICAgIHRlcm0uc29ja2V0ID0gc29ja2V0O1xuICAgICAgICB0ZXJtLl9mbHVzaEJ1ZmZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRlcm0ud3JpdGUodGVybS5fYXR0YWNoU29ja2V0QnVmZmVyKTtcbiAgICAgICAgICAgIHRlcm0uX2F0dGFjaFNvY2tldEJ1ZmZlciA9IG51bGw7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGVybS5fYXR0YWNoU29ja2V0QnVmZmVyVGltZXIpO1xuICAgICAgICAgICAgdGVybS5fYXR0YWNoU29ja2V0QnVmZmVyVGltZXIgPSBudWxsO1xuICAgICAgICB9O1xuICAgICAgICB0ZXJtLl9wdXNoVG9CdWZmZXIgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgaWYgKHRlcm0uX2F0dGFjaFNvY2tldEJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIHRlcm0uX2F0dGFjaFNvY2tldEJ1ZmZlciArPSBkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGVybS5fYXR0YWNoU29ja2V0QnVmZmVyID0gZGF0YTtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KHRlcm0uX2ZsdXNoQnVmZmVyLCAxMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRlcm0uX2dldE1lc3NhZ2UgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIGlmIChidWZmZXJlZCkge1xuICAgICAgICAgICAgICAgIHRlcm0uX3B1c2hUb0J1ZmZlcihldi5kYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRlcm0ud3JpdGUoZXYuZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRlcm0uX3NlbmREYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHNvY2tldC5zZW5kKGRhdGEpO1xuICAgICAgICB9O1xuICAgICAgICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHRlcm0uX2dldE1lc3NhZ2UpO1xuICAgICAgICBpZiAoYmlkaXJlY3Rpb25hbCkge1xuICAgICAgICAgICAgdGVybS5vbignZGF0YScsIHRlcm0uX3NlbmREYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignY2xvc2UnLCB0ZXJtLmRldGFjaC5iaW5kKHRlcm0sIHNvY2tldCkpO1xuICAgICAgICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCB0ZXJtLmRldGFjaC5iaW5kKHRlcm0sIHNvY2tldCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGV0YWNoZXMgdGhlIGdpdmVuIHRlcm1pbmFsIGZyb20gdGhlIGdpdmVuIHNvY2tldFxuICAgICAqXG4gICAgICogQHBhcmFtIHtYdGVybX0gdGVybSAtIFRoZSB0ZXJtaW5hbCB0byBiZSBkZXRhY2hlZCBmcm9tIHRoZSBnaXZlbiBzb2NrZXQuXG4gICAgICogQHBhcmFtIHtXZWJTb2NrZXR9IHNvY2tldCAtIFRoZSBzb2NrZXQgZnJvbSB3aGljaCB0byBkZXRhY2ggdGhlIGN1cnJlbnRcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVybWluYWwuXG4gICAgICovXG4gICAgZXhwb3J0cy5kZXRhY2ggPSBmdW5jdGlvbiAodGVybSwgc29ja2V0KSB7XG4gICAgICAgIHRlcm0ub2ZmKCdkYXRhJywgdGVybS5fc2VuZERhdGEpO1xuICAgICAgICBzb2NrZXQgPSAodHlwZW9mIHNvY2tldCA9PSAndW5kZWZpbmVkJykgPyB0ZXJtLnNvY2tldCA6IHNvY2tldDtcbiAgICAgICAgaWYgKHNvY2tldCkge1xuICAgICAgICAgICAgc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0ZXJtLl9nZXRNZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgdGVybS5zb2NrZXQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBdHRhY2hlcyB0aGUgY3VycmVudCB0ZXJtaW5hbCB0byB0aGUgZ2l2ZW4gc29ja2V0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYlNvY2tldH0gc29ja2V0IC0gVGhlIHNvY2tldCB0byBhdHRhY2ggdGhlIGN1cnJlbnQgdGVybWluYWwuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBiaWRpcmVjdGlvbmFsIC0gV2hldGhlciB0aGUgdGVybWluYWwgc2hvdWxkIHNlbmQgZGF0YVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIHRoZSBzb2NrZXQgYXMgd2VsbC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGJ1ZmZlcmVkIC0gV2hldGhlciB0aGUgcmVuZGVyaW5nIG9mIGluY29taW5nIGRhdGFcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkIGhhcHBlbiBpbnN0YW50bHkgb3IgYXQgYSBtYXhpbXVtXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyZXF1ZW5jeSBvZiAxIHJlbmRlcmluZyBwZXIgMTBtcy5cbiAgICAgKi9cbiAgICBYdGVybS5wcm90b3R5cGUuYXR0YWNoID0gZnVuY3Rpb24gKHNvY2tldCwgYmlkaXJlY3Rpb25hbCwgYnVmZmVyZWQpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuYXR0YWNoKHRoaXMsIHNvY2tldCwgYmlkaXJlY3Rpb25hbCwgYnVmZmVyZWQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGV0YWNoZXMgdGhlIGN1cnJlbnQgdGVybWluYWwgZnJvbSB0aGUgZ2l2ZW4gc29ja2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJTb2NrZXR9IHNvY2tldCAtIFRoZSBzb2NrZXQgZnJvbSB3aGljaCB0byBkZXRhY2ggdGhlIGN1cnJlbnRcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVybWluYWwuXG4gICAgICovXG4gICAgWHRlcm0ucHJvdG90eXBlLmRldGFjaCA9IGZ1bmN0aW9uIChzb2NrZXQpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuZGV0YWNoKHRoaXMsIHNvY2tldCk7XG4gICAgfTtcbiAgICByZXR1cm4gZXhwb3J0cztcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXR0YWNoLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3h0ZXJtL2xpYi9hZGRvbnMvYXR0YWNoL2F0dGFjaC5qc1xuICoqIG1vZHVsZSBpZCA9IDlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogRml0IHRlcm1pbmFsIGNvbHVtbnMgYW5kIHJvd3MgdG8gdGhlIGRpbWVuc2lvbnMgb2YgaXRzIERPTSBlbGVtZW50LlxuICpcbiAqICMjIEFwcHJvYWNoXG4gKiAtIFJvd3M6IFRydW5jYXRlIHRoZSBkaXZpc2lvbiBvZiB0aGUgdGVybWluYWwgcGFyZW50IGVsZW1lbnQgaGVpZ2h0IGJ5IHRoZSB0ZXJtaW5hbCByb3cgaGVpZ2h0LlxuICpcbiAqIC0gQ29sdW1uczogVHJ1bmNhdGUgdGhlIGRpdmlzaW9uIG9mIHRoZSB0ZXJtaW5hbCBwYXJlbnQgZWxlbWVudCB3aWR0aCBieSB0aGUgdGVybWluYWwgY2hhcmFjdGVyXG4gKiB3aWR0aCAoYXBwbHkgZGlzcGxheTogaW5saW5lIGF0IHRoZSB0ZXJtaW5hbCByb3cgYW5kIHRydW5jYXRlIGl0cyB3aWR0aCB3aXRoIHRoZSBjdXJyZW50XG4gKiBudW1iZXIgb2YgY29sdW1ucykuXG4gKiBAbW9kdWxlIHh0ZXJtL2FkZG9ucy9maXQvZml0XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuKGZ1bmN0aW9uIChmaXQpIHtcbiAgICBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8qXG4gICAgICAgICAqIENvbW1vbkpTIGVudmlyb25tZW50XG4gICAgICAgICAqL1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZpdChyZXF1aXJlKCcuLi8uLi94dGVybScpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8qXG4gICAgICAgICAqIFJlcXVpcmUuanMgaXMgYXZhaWxhYmxlXG4gICAgICAgICAqL1xuICAgICAgICBkZWZpbmUoWycuLi8uLi94dGVybSddLCBmaXQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLypcbiAgICAgICAgICogUGxhaW4gYnJvd3NlciBlbnZpcm9ubWVudFxuICAgICAgICAgKi9cbiAgICAgICAgZml0KHdpbmRvdy5UZXJtaW5hbCk7XG4gICAgfVxufSkoZnVuY3Rpb24gKFh0ZXJtKSB7XG4gICAgdmFyIGV4cG9ydHMgPSB7fTtcbiAgICBleHBvcnRzLnByb3Bvc2VHZW9tZXRyeSA9IGZ1bmN0aW9uICh0ZXJtKSB7XG4gICAgICAgIHZhciBwYXJlbnRFbGVtZW50U3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0ZXJtLmVsZW1lbnQucGFyZW50RWxlbWVudCksIHBhcmVudEVsZW1lbnRIZWlnaHQgPSBwYXJzZUludChwYXJlbnRFbGVtZW50U3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnaGVpZ2h0JykpLCBwYXJlbnRFbGVtZW50V2lkdGggPSBNYXRoLm1heCgwLCBwYXJzZUludChwYXJlbnRFbGVtZW50U3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnd2lkdGgnKSkgLSAxNyksIGVsZW1lbnRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRlcm0uZWxlbWVudCksIGVsZW1lbnRQYWRkaW5nVmVyID0gcGFyc2VJbnQoZWxlbWVudFN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ3BhZGRpbmctdG9wJykpICsgcGFyc2VJbnQoZWxlbWVudFN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ3BhZGRpbmctYm90dG9tJykpLCBlbGVtZW50UGFkZGluZ0hvciA9IHBhcnNlSW50KGVsZW1lbnRTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdwYWRkaW5nLXJpZ2h0JykpICsgcGFyc2VJbnQoZWxlbWVudFN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ3BhZGRpbmctbGVmdCcpKSwgYXZhaWxhYmxlSGVpZ2h0ID0gcGFyZW50RWxlbWVudEhlaWdodCAtIGVsZW1lbnRQYWRkaW5nVmVyLCBhdmFpbGFibGVXaWR0aCA9IHBhcmVudEVsZW1lbnRXaWR0aCAtIGVsZW1lbnRQYWRkaW5nSG9yLCBjb250YWluZXIgPSB0ZXJtLnJvd0NvbnRhaW5lciwgc3ViamVjdFJvdyA9IHRlcm0ucm93Q29udGFpbmVyLmZpcnN0RWxlbWVudENoaWxkLCBjb250ZW50QnVmZmVyID0gc3ViamVjdFJvdy5pbm5lckhUTUwsIGNoYXJhY3RlckhlaWdodCwgcm93cywgY2hhcmFjdGVyV2lkdGgsIGNvbHMsIGdlb21ldHJ5O1xuICAgICAgICBzdWJqZWN0Um93LnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lJztcbiAgICAgICAgc3ViamVjdFJvdy5pbm5lckhUTUwgPSAnVyc7IC8vIENvbW1vbiBjaGFyYWN0ZXIgZm9yIG1lYXN1cmluZyB3aWR0aCwgYWx0aG91Z2ggb24gbW9ub3NwYWNlXG4gICAgICAgIGNoYXJhY3RlcldpZHRoID0gc3ViamVjdFJvdy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcbiAgICAgICAgc3ViamVjdFJvdy5zdHlsZS5kaXNwbGF5ID0gJyc7IC8vIFJldmVydCBzdHlsZSBiZWZvcmUgY2FsY3VsYXRpbmcgaGVpZ2h0LCBzaW5jZSB0aGV5IGRpZmZlci5cbiAgICAgICAgY2hhcmFjdGVySGVpZ2h0ID0gcGFyc2VJbnQoc3ViamVjdFJvdy5vZmZzZXRIZWlnaHQpO1xuICAgICAgICBzdWJqZWN0Um93LmlubmVySFRNTCA9IGNvbnRlbnRCdWZmZXI7XG4gICAgICAgIHJvd3MgPSBwYXJzZUludChhdmFpbGFibGVIZWlnaHQgLyBjaGFyYWN0ZXJIZWlnaHQpO1xuICAgICAgICBjb2xzID0gcGFyc2VJbnQoYXZhaWxhYmxlV2lkdGggLyBjaGFyYWN0ZXJXaWR0aCk7XG4gICAgICAgIGdlb21ldHJ5ID0geyBjb2xzOiBjb2xzLCByb3dzOiByb3dzIH07XG4gICAgICAgIHJldHVybiBnZW9tZXRyeTtcbiAgICB9O1xuICAgIGV4cG9ydHMuZml0ID0gZnVuY3Rpb24gKHRlcm0pIHtcbiAgICAgICAgdmFyIGdlb21ldHJ5ID0gZXhwb3J0cy5wcm9wb3NlR2VvbWV0cnkodGVybSk7XG4gICAgICAgIHRlcm0ucmVzaXplKGdlb21ldHJ5LmNvbHMsIGdlb21ldHJ5LnJvd3MpO1xuICAgIH07XG4gICAgWHRlcm0ucHJvdG90eXBlLnByb3Bvc2VHZW9tZXRyeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMucHJvcG9zZUdlb21ldHJ5KHRoaXMpO1xuICAgIH07XG4gICAgWHRlcm0ucHJvdG90eXBlLmZpdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuZml0KHRoaXMpO1xuICAgIH07XG4gICAgcmV0dXJuIGV4cG9ydHM7XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpdC5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi94dGVybS9saWIvYWRkb25zL2ZpdC9maXQuanNcbiAqKiBtb2R1bGUgaWQgPSAxMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBGdWxsc2NyZWVuIGFkZG9uIGZvciB4dGVybS5qc1xuICogQG1vZHVsZSB4dGVybS9hZGRvbnMvZnVsbHNjcmVlbi9mdWxsc2NyZWVuXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuKGZ1bmN0aW9uIChmdWxsc2NyZWVuKSB7XG4gICAgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAvKlxuICAgICAgICAgKiBDb21tb25KUyBlbnZpcm9ubWVudFxuICAgICAgICAgKi9cbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdWxsc2NyZWVuKHJlcXVpcmUoJy4uLy4uL3h0ZXJtJykpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLypcbiAgICAgICAgICogUmVxdWlyZS5qcyBpcyBhdmFpbGFibGVcbiAgICAgICAgICovXG4gICAgICAgIGRlZmluZShbJy4uLy4uL3h0ZXJtJ10sIGZ1bGxzY3JlZW4pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLypcbiAgICAgICAgICogUGxhaW4gYnJvd3NlciBlbnZpcm9ubWVudFxuICAgICAgICAgKi9cbiAgICAgICAgZnVsbHNjcmVlbih3aW5kb3cuVGVybWluYWwpO1xuICAgIH1cbn0pKGZ1bmN0aW9uIChYdGVybSkge1xuICAgIHZhciBleHBvcnRzID0ge307XG4gICAgLyoqXG4gICAgICogVG9nZ2xlIHRoZSBnaXZlbiB0ZXJtaW5hbCdzIGZ1bGxzY3JlZW4gbW9kZS5cbiAgICAgKiBAcGFyYW0ge1h0ZXJtfSB0ZXJtIC0gVGhlIHRlcm1pbmFsIHRvIHRvZ2dsZSBmdWxsIHNjcmVlbiBtb2RlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBmdWxsc2NyZWVuIC0gVG9nZ2xlIGZ1bGxzY3JlZW4gb24gKHRydWUpIG9yIG9mZiAoZmFsc2UpXG4gICAgICovXG4gICAgZXhwb3J0cy50b2dnbGVGdWxsU2NyZWVuID0gZnVuY3Rpb24gKHRlcm0sIGZ1bGxzY3JlZW4pIHtcbiAgICAgICAgdmFyIGZuO1xuICAgICAgICBpZiAodHlwZW9mIGZ1bGxzY3JlZW4gPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGZuID0gKHRlcm0uZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ2Z1bGxzY3JlZW4nKSkgPyAncmVtb3ZlJyA6ICdhZGQnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFmdWxsc2NyZWVuKSB7XG4gICAgICAgICAgICBmbiA9ICdyZW1vdmUnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm4gPSAnYWRkJztcbiAgICAgICAgfVxuICAgICAgICB0ZXJtLmVsZW1lbnQuY2xhc3NMaXN0W2ZuXSgnZnVsbHNjcmVlbicpO1xuICAgIH07XG4gICAgWHRlcm0ucHJvdG90eXBlLnRvZ2dsZUZ1bGxzY3JlZW4gPSBmdW5jdGlvbiAoZnVsbHNjcmVlbikge1xuICAgICAgICBleHBvcnRzLnRvZ2dsZUZ1bGxTY3JlZW4odGhpcywgZnVsbHNjcmVlbik7XG4gICAgfTtcbiAgICByZXR1cm4gZXhwb3J0cztcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZnVsbHNjcmVlbi5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi94dGVybS9saWIvYWRkb25zL2Z1bGxzY3JlZW4vZnVsbHNjcmVlbi5qc1xuICoqIG1vZHVsZSBpZCA9IDExXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIE1ldGhvZHMgZm9yIHR1cm5pbmcgVVJMIHN1YnNjcmluZ3MgaW4gdGhlIHRlcm1pbmFsJ3MgY29udGVudCBpbnRvIGxpbmtzIChgYWAgRE9NIGVsZW1lbnRzKS5cbiAqIEBtb2R1bGUgeHRlcm0vYWRkb25zL2xpbmtpZnkvbGlua2lmeVxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbihmdW5jdGlvbiAobGlua2lmeSkge1xuICAgIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgLypcbiAgICAgICAgICogQ29tbW9uSlMgZW52aXJvbm1lbnRcbiAgICAgICAgICovXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gbGlua2lmeShyZXF1aXJlKCcuLi8uLi94dGVybScpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8qXG4gICAgICAgICAqIFJlcXVpcmUuanMgaXMgYXZhaWxhYmxlXG4gICAgICAgICAqL1xuICAgICAgICBkZWZpbmUoWycuLi8uLi94dGVybSddLCBsaW5raWZ5KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8qXG4gICAgICAgICAqIFBsYWluIGJyb3dzZXIgZW52aXJvbm1lbnRcbiAgICAgICAgICovXG4gICAgICAgIGxpbmtpZnkod2luZG93LlRlcm1pbmFsKTtcbiAgICB9XG59KShmdW5jdGlvbiAoWHRlcm0pIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIGV4cG9ydHMgPSB7fSwgcHJvdG9jb2xDbGF1c2UgPSAnKGh0dHBzPzpcXFxcL1xcXFwvKScsIGRvbWFpbkNoYXJhY3RlclNldCA9ICdbXFxcXGRhLXpcXFxcLi1dKycsIG5lZ2F0ZWREb21haW5DaGFyYWN0ZXJTZXQgPSAnW15cXFxcZGEtelxcXFwuLV0rJywgZG9tYWluQm9keUNsYXVzZSA9ICcoJyArIGRvbWFpbkNoYXJhY3RlclNldCArICcpJywgdGxkQ2xhdXNlID0gJyhbYS16XFxcXC5dezIsNn0pJywgaXBDbGF1c2UgPSAnKChcXFxcZHsxLDN9XFxcXC4pezN9XFxcXGR7MSwzfSknLCBwb3J0Q2xhdXNlID0gJyg6XFxcXGR7MSw1fSknLCBob3N0Q2xhdXNlID0gJygoJyArIGRvbWFpbkJvZHlDbGF1c2UgKyAnXFxcXC4nICsgdGxkQ2xhdXNlICsgJyl8JyArIGlwQ2xhdXNlICsgJyknICsgcG9ydENsYXVzZSArICc/JywgcGF0aENsYXVzZSA9ICcoXFxcXC9bXFxcXC9cXFxcd1xcXFwuLV0qKSonLCBuZWdhdGVkUGF0aENoYXJhY3RlclNldCA9ICdbXlxcXFwvXFxcXHdcXFxcLi1dKycsIGJvZHlDbGF1c2UgPSBob3N0Q2xhdXNlICsgcGF0aENsYXVzZSwgc3RhcnQgPSAnKD86XnwnICsgbmVnYXRlZERvbWFpbkNoYXJhY3RlclNldCArICcpKCcsIGVuZCA9ICcpKCR8JyArIG5lZ2F0ZWRQYXRoQ2hhcmFjdGVyU2V0ICsgJyknLCBsZW5pZW50VXJsQ2xhdXNlID0gc3RhcnQgKyBwcm90b2NvbENsYXVzZSArICc/JyArIGJvZHlDbGF1c2UgKyBlbmQsIHN0cmljdFVybENsYXVzZSA9IHN0YXJ0ICsgcHJvdG9jb2xDbGF1c2UgKyBib2R5Q2xhdXNlICsgZW5kLCBsZW5pZW50VXJsUmVnZXggPSBuZXcgUmVnRXhwKGxlbmllbnRVcmxDbGF1c2UpLCBzdHJpY3RVcmxSZWdleCA9IG5ldyBSZWdFeHAoc3RyaWN0VXJsQ2xhdXNlKTtcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhbGwgdmFsaWQgVVJMcyBmb3VuZCBpbiB0aGUgZ2l2ZW4gdGVybWluYWwgbGluZSBpbnRvXG4gICAgICogaHlwZXJsaW5rcy4gVGhlIHRlcm1pbmFsIGxpbmUgY2FuIGJlIGVpdGhlciB0aGUgSFRNTCBlbGVtZW50IGl0c2VsZlxuICAgICAqIG9yIHRoZSBpbmRleCBvZiB0aGUgdGVybWluYSBsaW5lIGluIHRoZSBjaGlsZHJlbiBvZiB0aGUgdGVybWluYWxcbiAgICAgKiByb3dzIGNvbnRhaW5lci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7WHRlcm19IHRlcm1pbmFsIC0gVGhlIHRlcm1pbmFsIHRoYXQgb3ducyB0aGUgZ2l2ZW4gbGluZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcnxIVE1MRGl2RWxlbWVudH0gbGluZSAtIFRoZSB0ZXJtaW5hbCBsaW5lIHRoYXQgc2hvdWxkIGdldFxuICAgICAqXHRcdFx0XHRcdFx0XHRcdCAgXHRcdCBcImxpbmtpZmllZFwiLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbGVuaWVudCAtIFRoZSByZWdleCB0eXBlIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGlkZW50aWZ5IGxpbmtzLiBJZiBsZW5pZW50IGlzXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UsIHRoZSByZWdleCByZXF1aXJlcyBhIHByb3RvY29sIGNsYXVzZS4gRGVmYXVsdHMgdG8gdHJ1ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFyZ2V0IC0gIFNldHMgdGFyZ2V0PVwiXCIgYXR0cmlidXRlIHdpdGggdmFsdWUgcHJvdmlkZWQgdG8gbGlua3MuXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0IGRvZXNuJ3Qgc2V0IHRhcmdldCBhdHRyaWJ1dGVcbiAgICAgKiBAZW1pdHMgbGlua2lmeVxuICAgICAqIEBlbWl0cyBsaW5raWZ5OmxpbmVcbiAgICAgKi9cbiAgICBleHBvcnRzLmxpbmtpZnlUZXJtaW5hbExpbmUgPSBmdW5jdGlvbiAodGVybWluYWwsIGxpbmUsIGxlbmllbnQsIHRhcmdldCkge1xuICAgICAgICBpZiAodHlwZW9mIGxpbmUgPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGxpbmUgPSB0ZXJtaW5hbC5yb3dDb250YWluZXIuY2hpbGRyZW5bbGluZV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIShsaW5lIGluc3RhbmNlb2YgSFRNTERpdkVsZW1lbnQpKSB7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9ICdUaGUgXCJsaW5lXCIgYXJndW1lbnQgc2hvdWxkIGJlIGVpdGhlciBhIG51bWJlcic7XG4gICAgICAgICAgICBtZXNzYWdlICs9ICcgb3IgYW4gSFRNTERpdkVsZW1lbnQnO1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRhcmdldCA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0ID0gJ3RhcmdldD1cIicgKyB0YXJnZXQgKyAnXCInO1xuICAgICAgICB9XG4gICAgICAgIHZhciBidWZmZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyksIG5vZGVzID0gbGluZS5jaGlsZE5vZGVzO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5vZGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2pdLCBtYXRjaDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2luY2Ugd2UgY2Fubm90IGFjY2VzcyB0aGUgVGV4dE5vZGUncyBIVE1MIHJlcHJlc2VudGF0aW9uXG4gICAgICAgICAgICAgKiBmcm9tIHRoZSBpbnN0YW5jZSBpdHNlbGYsIHdlIGFzc2lnbiBpdHMgZGF0YSBhcyB0ZXh0Q29udGVudFxuICAgICAgICAgICAgICogdG8gYSBkdW1teSBidWZmZXIgc3BhbiwgaW4gb3JkZXIgdG8gcmV0cmlldmUgdGhlIFRleHROb2RlJ3NcbiAgICAgICAgICAgICAqIEhUTUwgcmVwcmVzZW50YXRpb24gZnJvbSB0aGUgYnVmZmVyJ3MgaW5uZXJIVE1MLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBidWZmZXIudGV4dENvbnRlbnQgPSBub2RlLmRhdGE7XG4gICAgICAgICAgICB2YXIgbm9kZUhUTUwgPSBidWZmZXIuaW5uZXJIVE1MO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBcHBseSBmdW5jdGlvbiBvbmx5IG9uIFRleHROb2Rlc1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSAhPSBub2RlLlRFWFRfTk9ERSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHVybCA9IGV4cG9ydHMuZmluZExpbmtNYXRjaChub2RlLmRhdGEsIGxlbmllbnQpO1xuICAgICAgICAgICAgaWYgKCF1cmwpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzdGFydHNXaXRoUHJvdG9jb2wgPSBuZXcgUmVnRXhwKCdeJyArIHByb3RvY29sQ2xhdXNlKSwgdXJsSGFzUHJvdG9jb2wgPSB1cmwubWF0Y2goc3RhcnRzV2l0aFByb3RvY29sKSwgaHJlZiA9ICh1cmxIYXNQcm90b2NvbCkgPyB1cmwgOiAnaHR0cDovLycgKyB1cmwsIGxpbmsgPSAnPGEgaHJlZj1cIicgKyBocmVmICsgJ1wiICcgKyB0YXJnZXQgKyAnPicgKyB1cmwgKyAnPC9hPicsIG5ld0hUTUwgPSBub2RlSFRNTC5yZXBsYWNlKHVybCwgbGluayk7XG4gICAgICAgICAgICBsaW5lLmlubmVySFRNTCA9IGxpbmUuaW5uZXJIVE1MLnJlcGxhY2Uobm9kZUhUTUwsIG5ld0hUTUwpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGdldHMgZW1pdHRlZCB3aGVuIGNvbnZlcnNpb24gb2YgYWxsIFVSTCBzdXNidHJpbmdzXG4gICAgICAgICAqIHRvIEhUTUwgYW5jaG9yIGVsZW1lbnRzIChsaW5rcykgaGFzIGZpbmlzaGVkLCBmb3IgYSBzcGVjaWZpY1xuICAgICAgICAgKiBsaW5lIG9mIHRoZSBjdXJyZW50IFh0ZXJtIGluc3RhbmNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXZlbnQgbGlua2lmeTpsaW5lXG4gICAgICAgICAqL1xuICAgICAgICB0ZXJtaW5hbC5lbWl0KCdsaW5raWZ5OmxpbmUnLCBsaW5lKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEZpbmRzIGEgbGluayB3aXRoaW4gYSBibG9jayBvZiB0ZXh0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSBUaGUgdGV4dCB0byBzZWFyY2ggLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbGVuaWVudCAtIFdoZXRoZXIgdG8gdXNlIHRoZSBsZW5pZW50IHNlYXJjaC5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IEEgVVJMLlxuICAgICAqL1xuICAgIGV4cG9ydHMuZmluZExpbmtNYXRjaCA9IGZ1bmN0aW9uICh0ZXh0LCBsZW5pZW50KSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHRleHQubWF0Y2gobGVuaWVudCA/IGxlbmllbnRVcmxSZWdleCA6IHN0cmljdFVybFJlZ2V4KTtcbiAgICAgICAgaWYgKCFtYXRjaCB8fCBtYXRjaC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXRjaFsxXTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGFsbCB2YWxpZCBVUkxzIGZvdW5kIGluIHRoZSB0ZXJtaW5hbCB2aWV3IGludG8gaHlwZXJsaW5rcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7WHRlcm19IHRlcm1pbmFsIC0gVGhlIHRlcm1pbmFsIHRoYXQgc2hvdWxkIGdldCBcImxpbmtpZmllZFwiLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbGVuaWVudCAtIFRoZSByZWdleCB0eXBlIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGlkZW50aWZ5IGxpbmtzLiBJZiBsZW5pZW50IGlzXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UsIHRoZSByZWdleCByZXF1aXJlcyBhIHByb3RvY29sIGNsYXVzZS4gRGVmYXVsdHMgdG8gdHJ1ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFyZ2V0IC0gIFNldHMgdGFyZ2V0PVwiXCIgYXR0cmlidXRlIHdpdGggdmFsdWUgcHJvdmlkZWQgdG8gbGlua3MuXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0IGRvZXNuJ3Qgc2V0IHRhcmdldCBhdHRyaWJ1dGVcbiAgICAgKiBAZW1pdHMgbGlua2lmeVxuICAgICAqIEBlbWl0cyBsaW5raWZ5OmxpbmVcbiAgICAgKi9cbiAgICBleHBvcnRzLmxpbmtpZnkgPSBmdW5jdGlvbiAodGVybWluYWwsIGxlbmllbnQsIHRhcmdldCkge1xuICAgICAgICB2YXIgcm93cyA9IHRlcm1pbmFsLnJvd0NvbnRhaW5lci5jaGlsZHJlbjtcbiAgICAgICAgbGVuaWVudCA9ICh0eXBlb2YgbGVuaWVudCA9PSBcImJvb2xlYW5cIikgPyBsZW5pZW50IDogdHJ1ZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbGluZSA9IHJvd3NbaV07XG4gICAgICAgICAgICBleHBvcnRzLmxpbmtpZnlUZXJtaW5hbExpbmUodGVybWluYWwsIGxpbmUsIGxlbmllbnQsIHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZXZlbnQgZ2V0cyBlbWl0dGVkIHdoZW4gY29udmVyc2lvbiBvZiAgYWxsIFVSTCBzdWJzdHJpbmdzIHRvXG4gICAgICAgICAqIEhUTUwgYW5jaG9yIGVsZW1lbnRzIChsaW5rcykgaGFzIGZpbmlzaGVkIGZvciB0aGUgY3VycmVudCBYdGVybVxuICAgICAgICAgKiBpbnN0YW5jZSdzIHZpZXcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBldmVudCBsaW5raWZ5XG4gICAgICAgICAqL1xuICAgICAgICB0ZXJtaW5hbC5lbWl0KCdsaW5raWZ5Jyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFeHRlbmQgWHRlcm0gcHJvdG90eXBlLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGFsbCB2YWxpZCBVUkxzIGZvdW5kIGluIHRoZSBjdXJyZW50IHRlcm1pbmFsIGxpbnRlIGludG9cbiAgICAgKiBoeXBlcmxpbmtzLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFh0ZXJtXG4gICAgICogQHBhcmFtIHtudW1iZXJ8SFRNTERpdkVsZW1lbnR9IGxpbmUgLSBUaGUgdGVybWluYWwgbGluZSB0aGF0IHNob3VsZCBnZXRcbiAgICAgKlx0XHRcdFx0XHRcdFx0XHQgIFx0XHQgXCJsaW5raWZpZWRcIi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGxlbmllbnQgLSBUaGUgcmVnZXggdHlwZSB0aGF0IHdpbGwgYmUgdXNlZCB0byBpZGVudGlmeSBsaW5rcy4gSWYgbGVuaWVudCBpc1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlLCB0aGUgcmVnZXggcmVxdWlyZXMgYSBwcm90b2NvbCBjbGF1c2UuIERlZmF1bHRzIHRvIHRydWUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldCAtICBTZXRzIHRhcmdldD1cIlwiIGF0dHJpYnV0ZSB3aXRoIHZhbHVlIHByb3ZpZGVkIHRvIGxpbmtzLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVmYXVsdCBkb2Vzbid0IHNldCB0YXJnZXQgYXR0cmlidXRlXG4gICAgICovXG4gICAgWHRlcm0ucHJvdG90eXBlLmxpbmtpZnlUZXJtaW5hbExpbmUgPSBmdW5jdGlvbiAobGluZSwgbGVuaWVudCwgdGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLmxpbmtpZnlUZXJtaW5hbExpbmUodGhpcywgbGluZSwgbGVuaWVudCwgdGFyZ2V0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGFsbCB2YWxpZCBVUkxzIGZvdW5kIGluIHRoZSBjdXJyZW50IHRlcm1pbmFsIGludG8gaHlwZXJsaW5rcy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBYdGVybVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbGVuaWVudCAtIFRoZSByZWdleCB0eXBlIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGlkZW50aWZ5IGxpbmtzLiBJZiBsZW5pZW50IGlzXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UsIHRoZSByZWdleCByZXF1aXJlcyBhIHByb3RvY29sIGNsYXVzZS4gRGVmYXVsdHMgdG8gdHJ1ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFyZ2V0IC0gIFNldHMgdGFyZ2V0PVwiXCIgYXR0cmlidXRlIHdpdGggdmFsdWUgcHJvdmlkZWQgdG8gbGlua3MuXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0IGRvZXNuJ3Qgc2V0IHRhcmdldCBhdHRyaWJ1dGVcbiAgICAgKi9cbiAgICBYdGVybS5wcm90b3R5cGUubGlua2lmeSA9IGZ1bmN0aW9uIChsZW5pZW50LCB0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMubGlua2lmeSh0aGlzLCBsZW5pZW50LCB0YXJnZXQpO1xuICAgIH07XG4gICAgcmV0dXJuIGV4cG9ydHM7XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpbmtpZnkuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34veHRlcm0vbGliL2FkZG9ucy9saW5raWZ5L2xpbmtpZnkuanNcbiAqKiBtb2R1bGUgaWQgPSAxMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBUaGlzIG1vZHVsZSBwcm92aWRlcyBtZXRob2RzIGZvciBhdHRhY2hpbmcgYSB0ZXJtaW5hbCB0byBhIHRlcm1pbmFkbyBXZWJTb2NrZXQgc3RyZWFtLlxuICpcbiAqIEBtb2R1bGUgeHRlcm0vYWRkb25zL3Rlcm1pbmFkby90ZXJtaW5hZG9cbiAqIEBsaWNlbnNlIE1JVFxuICovXG4oZnVuY3Rpb24gKGF0dGFjaCkge1xuICAgIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgLypcbiAgICAgICAgICogQ29tbW9uSlMgZW52aXJvbm1lbnRcbiAgICAgICAgICovXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gYXR0YWNoKHJlcXVpcmUoJy4uLy4uL3h0ZXJtJykpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLypcbiAgICAgICAgICogUmVxdWlyZS5qcyBpcyBhdmFpbGFibGVcbiAgICAgICAgICovXG4gICAgICAgIGRlZmluZShbJy4uLy4uL3h0ZXJtJ10sIGF0dGFjaCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvKlxuICAgICAgICAgKiBQbGFpbiBicm93c2VyIGVudmlyb25tZW50XG4gICAgICAgICAqL1xuICAgICAgICBhdHRhY2god2luZG93LlRlcm1pbmFsKTtcbiAgICB9XG59KShmdW5jdGlvbiAoWHRlcm0pIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIGV4cG9ydHMgPSB7fTtcbiAgICAvKipcbiAgICAgKiBBdHRhY2hlcyB0aGUgZ2l2ZW4gdGVybWluYWwgdG8gdGhlIGdpdmVuIHNvY2tldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7WHRlcm19IHRlcm0gLSBUaGUgdGVybWluYWwgdG8gYmUgYXR0YWNoZWQgdG8gdGhlIGdpdmVuIHNvY2tldC5cbiAgICAgKiBAcGFyYW0ge1dlYlNvY2tldH0gc29ja2V0IC0gVGhlIHNvY2tldCB0byBhdHRhY2ggdGhlIGN1cnJlbnQgdGVybWluYWwuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBiaWRpcmVjdGlvbmFsIC0gV2hldGhlciB0aGUgdGVybWluYWwgc2hvdWxkIHNlbmQgZGF0YVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIHRoZSBzb2NrZXQgYXMgd2VsbC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGJ1ZmZlcmVkIC0gV2hldGhlciB0aGUgcmVuZGVyaW5nIG9mIGluY29taW5nIGRhdGFcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkIGhhcHBlbiBpbnN0YW50bHkgb3IgYXQgYSBtYXhpbXVtXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyZXF1ZW5jeSBvZiAxIHJlbmRlcmluZyBwZXIgMTBtcy5cbiAgICAgKi9cbiAgICBleHBvcnRzLnRlcm1pbmFkb0F0dGFjaCA9IGZ1bmN0aW9uICh0ZXJtLCBzb2NrZXQsIGJpZGlyZWN0aW9uYWwsIGJ1ZmZlcmVkKSB7XG4gICAgICAgIGJpZGlyZWN0aW9uYWwgPSAodHlwZW9mIGJpZGlyZWN0aW9uYWwgPT0gJ3VuZGVmaW5lZCcpID8gdHJ1ZSA6IGJpZGlyZWN0aW9uYWw7XG4gICAgICAgIHRlcm0uc29ja2V0ID0gc29ja2V0O1xuICAgICAgICB0ZXJtLl9mbHVzaEJ1ZmZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRlcm0ud3JpdGUodGVybS5fYXR0YWNoU29ja2V0QnVmZmVyKTtcbiAgICAgICAgICAgIHRlcm0uX2F0dGFjaFNvY2tldEJ1ZmZlciA9IG51bGw7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGVybS5fYXR0YWNoU29ja2V0QnVmZmVyVGltZXIpO1xuICAgICAgICAgICAgdGVybS5fYXR0YWNoU29ja2V0QnVmZmVyVGltZXIgPSBudWxsO1xuICAgICAgICB9O1xuICAgICAgICB0ZXJtLl9wdXNoVG9CdWZmZXIgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgaWYgKHRlcm0uX2F0dGFjaFNvY2tldEJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIHRlcm0uX2F0dGFjaFNvY2tldEJ1ZmZlciArPSBkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGVybS5fYXR0YWNoU29ja2V0QnVmZmVyID0gZGF0YTtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KHRlcm0uX2ZsdXNoQnVmZmVyLCAxMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRlcm0uX2dldE1lc3NhZ2UgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gSlNPTi5wYXJzZShldi5kYXRhKTtcbiAgICAgICAgICAgIGlmIChkYXRhWzBdID09IFwic3Rkb3V0XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoYnVmZmVyZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGVybS5fcHVzaFRvQnVmZmVyKGRhdGFbMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGVybS53cml0ZShkYXRhWzFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRlcm0uX3NlbmREYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHNvY2tldC5zZW5kKEpTT04uc3RyaW5naWZ5KFsnc3RkaW4nLCBkYXRhXSkpO1xuICAgICAgICB9O1xuICAgICAgICB0ZXJtLl9zZXRTaXplID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgICAgICAgICAgIHNvY2tldC5zZW5kKEpTT04uc3RyaW5naWZ5KFsnc2V0X3NpemUnLCBzaXplLnJvd3MsIHNpemUuY29sc10pKTtcbiAgICAgICAgfTtcbiAgICAgICAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0ZXJtLl9nZXRNZXNzYWdlKTtcbiAgICAgICAgaWYgKGJpZGlyZWN0aW9uYWwpIHtcbiAgICAgICAgICAgIHRlcm0ub24oJ2RhdGEnLCB0ZXJtLl9zZW5kRGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgdGVybS5vbigncmVzaXplJywgdGVybS5fc2V0U2l6ZSk7XG4gICAgICAgIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdjbG9zZScsIHRlcm0udGVybWluYWRvRGV0YWNoLmJpbmQodGVybSwgc29ja2V0KSk7XG4gICAgICAgIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIHRlcm0udGVybWluYWRvRGV0YWNoLmJpbmQodGVybSwgc29ja2V0KSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZXRhY2hlcyB0aGUgZ2l2ZW4gdGVybWluYWwgZnJvbSB0aGUgZ2l2ZW4gc29ja2V0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1h0ZXJtfSB0ZXJtIC0gVGhlIHRlcm1pbmFsIHRvIGJlIGRldGFjaGVkIGZyb20gdGhlIGdpdmVuIHNvY2tldC5cbiAgICAgKiBAcGFyYW0ge1dlYlNvY2tldH0gc29ja2V0IC0gVGhlIHNvY2tldCBmcm9tIHdoaWNoIHRvIGRldGFjaCB0aGUgY3VycmVudFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXJtaW5hbC5cbiAgICAgKi9cbiAgICBleHBvcnRzLnRlcm1pbmFkb0RldGFjaCA9IGZ1bmN0aW9uICh0ZXJtLCBzb2NrZXQpIHtcbiAgICAgICAgdGVybS5vZmYoJ2RhdGEnLCB0ZXJtLl9zZW5kRGF0YSk7XG4gICAgICAgIHNvY2tldCA9ICh0eXBlb2Ygc29ja2V0ID09ICd1bmRlZmluZWQnKSA/IHRlcm0uc29ja2V0IDogc29ja2V0O1xuICAgICAgICBpZiAoc29ja2V0KSB7XG4gICAgICAgICAgICBzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHRlcm0uX2dldE1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSB0ZXJtLnNvY2tldDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEF0dGFjaGVzIHRoZSBjdXJyZW50IHRlcm1pbmFsIHRvIHRoZSBnaXZlbiBzb2NrZXRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViU29ja2V0fSBzb2NrZXQgLSBUaGUgc29ja2V0IHRvIGF0dGFjaCB0aGUgY3VycmVudCB0ZXJtaW5hbC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGJpZGlyZWN0aW9uYWwgLSBXaGV0aGVyIHRoZSB0ZXJtaW5hbCBzaG91bGQgc2VuZCBkYXRhXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gdGhlIHNvY2tldCBhcyB3ZWxsLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYnVmZmVyZWQgLSBXaGV0aGVyIHRoZSByZW5kZXJpbmcgb2YgaW5jb21pbmcgZGF0YVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG91bGQgaGFwcGVuIGluc3RhbnRseSBvciBhdCBhIG1heGltdW1cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJlcXVlbmN5IG9mIDEgcmVuZGVyaW5nIHBlciAxMG1zLlxuICAgICAqL1xuICAgIFh0ZXJtLnByb3RvdHlwZS50ZXJtaW5hZG9BdHRhY2ggPSBmdW5jdGlvbiAoc29ja2V0LCBiaWRpcmVjdGlvbmFsLCBidWZmZXJlZCkge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy50ZXJtaW5hZG9BdHRhY2godGhpcywgc29ja2V0LCBiaWRpcmVjdGlvbmFsLCBidWZmZXJlZCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZXRhY2hlcyB0aGUgY3VycmVudCB0ZXJtaW5hbCBmcm9tIHRoZSBnaXZlbiBzb2NrZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYlNvY2tldH0gc29ja2V0IC0gVGhlIHNvY2tldCBmcm9tIHdoaWNoIHRvIGRldGFjaCB0aGUgY3VycmVudFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXJtaW5hbC5cbiAgICAgKi9cbiAgICBYdGVybS5wcm90b3R5cGUudGVybWluYWRvRGV0YWNoID0gZnVuY3Rpb24gKHNvY2tldCkge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy50ZXJtaW5hZG9EZXRhY2godGhpcywgc29ja2V0KTtcbiAgICB9O1xuICAgIHJldHVybiBleHBvcnRzO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZXJtaW5hZG8uanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34veHRlcm0vbGliL2FkZG9ucy90ZXJtaW5hZG8vdGVybWluYWRvLmpzXG4gKiogbW9kdWxlIGlkID0gMTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=