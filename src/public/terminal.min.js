/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	window.Terminal = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	var require;var require;(function(f){if(true){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.Terminal = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return require(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	/**
	 * xterm.js: xterm, in the browser
	 * Copyright (c) 2014-2016, SourceLair Private Company (www.sourcelair.com (MIT License)
	 */
	
	/**
	 * Encapsulates the logic for handling compositionstart, compositionupdate and compositionend
	 * events, displaying the in-progress composition to the UI and forwarding the final composition
	 * to the handler.
	 * @param {HTMLTextAreaElement} textarea The textarea that xterm uses for input.
	 * @param {HTMLElement} compositionView The element to display the in-progress composition in.
	 * @param {Terminal} terminal The Terminal to forward the finished composition to.
	 */
	function CompositionHelper(textarea, compositionView, terminal) {
	  this.textarea = textarea;
	  this.compositionView = compositionView;
	  this.terminal = terminal;
	
	  // Whether input composition is currently happening, eg. via a mobile keyboard, speech input
	  // or IME. This variable determines whether the compositionText should be displayed on the UI.
	  this.isComposing = false;
	
	  // The input currently being composed, eg. via a mobile keyboard, speech input or IME.
	  this.compositionText = null;
	
	  // The position within the input textarea's value of the current composition.
	  this.compositionPosition = { start: null, end: null };
	
	  // Whether a composition is in the process of being sent, setting this to false will cancel
	  // any in-progress composition.
	  this.isSendingComposition = false;
	}
	
	/**
	 * Handles the compositionstart event, activating the composition view.
	 */
	CompositionHelper.prototype.compositionstart = function () {
	  this.isComposing = true;
	  this.compositionPosition.start = this.textarea.value.length;
	  this.compositionView.textContent = '';
	  this.compositionView.classList.add('active');
	};
	
	/**
	 * Handles the compositionupdate event, updating the composition view.
	 * @param {CompositionEvent} ev The event.
	 */
	CompositionHelper.prototype.compositionupdate = function (ev) {
	  this.compositionView.textContent = ev.data;
	  this.updateCompositionElements();
	  var self = this;
	  setTimeout(function () {
	    self.compositionPosition.end = self.textarea.value.length;
	  }, 0);
	};
	
	/**
	 * Handles the compositionend event, hiding the composition view and sending the composition to
	 * the handler.
	 */
	CompositionHelper.prototype.compositionend = function () {
	  this.finalizeComposition(true);
	};
	
	/**
	 * Handles the keydown event, routing any necessary events to the CompositionHelper functions.
	 * @return Whether the Terminal should continue processing the keydown event.
	 */
	CompositionHelper.prototype.keydown = function (ev) {
	  if (this.isComposing || this.isSendingComposition) {
	    if (ev.keyCode === 229) {
	      // Continue composing if the keyCode is the "composition character"
	      return false;
	    } else if (ev.keyCode === 16 || ev.keyCode === 17 || ev.keyCode === 18) {
	      // Continue composing if the keyCode is a modifier key
	      return false;
	    } else {
	      // Finish composition immediately. This is mainly here for the case where enter is
	      // pressed and the handler needs to be triggered before the command is executed.
	      this.finalizeComposition(false);
	    }
	  }
	
	  if (ev.keyCode === 229) {
	    // If the "composition character" is used but gets to this point it means a non-composition
	    // character (eg. numbers and punctuation) was pressed when the IME was active.
	    this.handleAnyTextareaChanges();
	    return false;
	  }
	
	  return true;
	};
	
	/**
	 * Finalizes the composition, resuming regular input actions. This is called when a composition
	 * is ending.
	 * @param {boolean} waitForPropogation Whether to wait for events to propogate before sending
	 *   the input. This should be false if a non-composition keystroke is entered before the
	 *   compositionend event is triggered, such as enter, so that the composition is send before
	 *   the command is executed.
	 */
	CompositionHelper.prototype.finalizeComposition = function (waitForPropogation) {
	  this.compositionView.classList.remove('active');
	  this.isComposing = false;
	  this.clearTextareaPosition();
	
	  if (!waitForPropogation) {
	    // Cancel any delayed composition send requests and send the input immediately.
	    this.isSendingComposition = false;
	    var input = this.textarea.value.substring(this.compositionPosition.start, this.compositionPosition.end);
	    this.terminal.handler(input);
	  } else {
	    // Make a deep copy of the composition position here as a new compositionstart event may
	    // fire before the setTimeout executes.
	    var currentCompositionPosition = {
	      start: this.compositionPosition.start,
	      end: this.compositionPosition.end
	    };
	
	    // Since composition* events happen before the changes take place in the textarea on most
	    // browsers, use a setTimeout with 0ms time to allow the native compositionend event to
	    // complete. This ensures the correct character is retrieved, this solution was used
	    // because:
	    // - The compositionend event's data property is unreliable, at least on Chromium
	    // - The last compositionupdate event's data property does not always accurately describe
	    //   the character, a counter example being Korean where an ending consonsant can move to
	    //   the following character if the following input is a vowel.
	    var self = this;
	    this.isSendingComposition = true;
	    setTimeout(function () {
	      // Ensure that the input has not already been sent
	      if (self.isSendingComposition) {
	        self.isSendingComposition = false;
	        var input;
	        if (self.isComposing) {
	          // Use the end position to get the string if a new composition has started.
	          input = self.textarea.value.substring(currentCompositionPosition.start, currentCompositionPosition.end);
	        } else {
	          // Don't use the end position here in order to pick up any characters after the
	          // composition has finished, for example when typing a non-composition character
	          // (eg. 2) after a composition character.
	          input = self.textarea.value.substring(currentCompositionPosition.start);
	        }
	        self.terminal.handler(input);
	      }
	    }, 0);
	  }
	};
	
	/**
	 * Apply any changes made to the textarea after the current event chain is allowed to complete.
	 * This should be called when not currently composing but a keydown event with the "composition
	 * character" (229) is triggered, in order to allow non-composition text to be entered when an
	 * IME is active.
	 */
	CompositionHelper.prototype.handleAnyTextareaChanges = function () {
	  var oldValue = this.textarea.value;
	  var self = this;
	  setTimeout(function () {
	    // Ignore if a composition has started since the timeout
	    if (!self.isComposing) {
	      var newValue = self.textarea.value;
	      var diff = newValue.replace(oldValue, '');
	      if (diff.length > 0) {
	        self.terminal.handler(diff);
	      }
	    }
	  }, 0);
	};
	
	/**
	 * Positions the composition view on top of the cursor and the textarea just below it (so the
	 * IME helper dialog is positioned correctly).
	 */
	CompositionHelper.prototype.updateCompositionElements = function (dontRecurse) {
	  if (!this.isComposing) {
	    return;
	  }
	  var cursor = this.terminal.element.querySelector('.terminal-cursor');
	  if (cursor) {
	    this.compositionView.style.left = cursor.offsetLeft + 'px';
	    this.compositionView.style.top = cursor.offsetTop + 'px';
	    var compositionViewBounds = this.compositionView.getBoundingClientRect();
	    this.textarea.style.left = cursor.offsetLeft + compositionViewBounds.width + 'px';
	    this.textarea.style.top = cursor.offsetTop + cursor.offsetHeight + 'px';
	  }
	  if (!dontRecurse) {
	    setTimeout(this.updateCompositionElements.bind(this, true), 0);
	  }
	};
	
	/**
	 * Clears the textarea's position so that the cursor does not blink on IE.
	 * @private
	 */
	CompositionHelper.prototype.clearTextareaPosition = function () {
	  this.textarea.style.left = '';
	  this.textarea.style.top = '';
	};
	
	exports.CompositionHelper = CompositionHelper;
	
	},{}],2:[function(_dereq_,module,exports){
	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	/**
	 * xterm.js: xterm, in the browser
	 * Copyright (c) 2014-2016, SourceLair Private Company (www.sourcelair.com (MIT License)
	 */
	
	function EventEmitter() {
	  this._events = this._events || {};
	}
	
	EventEmitter.prototype.addListener = function (type, listener) {
	  this._events[type] = this._events[type] || [];
	  this._events[type].push(listener);
	};
	
	EventEmitter.prototype.on = EventEmitter.prototype.addListener;
	
	EventEmitter.prototype.removeListener = function (type, listener) {
	  if (!this._events[type]) return;
	
	  var obj = this._events[type],
	      i = obj.length;
	
	  while (i--) {
	    if (obj[i] === listener || obj[i].listener === listener) {
	      obj.splice(i, 1);
	      return;
	    }
	  }
	};
	
	EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
	
	EventEmitter.prototype.removeAllListeners = function (type) {
	  if (this._events[type]) delete this._events[type];
	};
	
	EventEmitter.prototype.once = function (type, listener) {
	  var self = this;
	  function on() {
	    var args = Array.prototype.slice.call(arguments);
	    this.removeListener(type, on);
	    return listener.apply(this, args);
	  }
	  on.listener = listener;
	  return this.on(type, on);
	};
	
	EventEmitter.prototype.emit = function (type) {
	  if (!this._events[type]) return;
	
	  var args = Array.prototype.slice.call(arguments, 1),
	      obj = this._events[type],
	      l = obj.length,
	      i = 0;
	
	  for (; i < l; i++) {
	    obj[i].apply(this, args);
	  }
	};
	
	EventEmitter.prototype.listeners = function (type) {
	  return this._events[type] = this._events[type] || [];
	};
	
	exports.EventEmitter = EventEmitter;
	
	},{}],3:[function(_dereq_,module,exports){
	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	/**
	 * xterm.js: xterm, in the browser
	 * Copyright (c) 2014-2016, SourceLair Private Company (www.sourcelair.com (MIT License)
	 */
	
	/**
	 * Represents the viewport of a terminal, the visible area within the larger buffer of output.
	 * Logic for the virtual scroll bar is included in this object.
	 * @param {Terminal} terminal The Terminal object.
	 * @param {HTMLElement} viewportElement The DOM element acting as the viewport
	 * @param {HTMLElement} charMeasureElement A DOM element used to measure the character size of
	 *   the terminal.
	 */
	function Viewport(terminal, viewportElement, scrollArea, charMeasureElement) {
	  this.terminal = terminal;
	  this.viewportElement = viewportElement;
	  this.scrollArea = scrollArea;
	  this.charMeasureElement = charMeasureElement;
	  this.currentRowHeight = 0;
	  this.lastRecordedBufferLength = 0;
	  this.lastRecordedViewportHeight = 0;
	
	  this.terminal.on('scroll', this.syncScrollArea.bind(this));
	  this.terminal.on('resize', this.syncScrollArea.bind(this));
	  this.viewportElement.addEventListener('scroll', this.onScroll.bind(this));
	
	  this.syncScrollArea();
	}
	
	/**
	 * Refreshes row height, setting line-height, viewport height and scroll area height if
	 * necessary.
	 * @param {number|undefined} charSize A character size measurement bounding rect object, if it
	 *   doesn't exist it will be created.
	 */
	Viewport.prototype.refresh = function (charSize) {
	  var size = charSize || this.charMeasureElement.getBoundingClientRect();
	  if (size.height > 0) {
	    var rowHeightChanged = size.height !== this.currentRowHeight;
	    if (rowHeightChanged) {
	      this.currentRowHeight = size.height;
	      this.viewportElement.style.lineHeight = size.height + 'px';
	      this.terminal.rowContainer.style.lineHeight = size.height + 'px';
	    }
	    var viewportHeightChanged = this.lastRecordedViewportHeight !== this.terminal.rows;
	    if (rowHeightChanged || viewportHeightChanged) {
	      this.lastRecordedViewportHeight = this.terminal.rows;
	      this.viewportElement.style.height = size.height * this.terminal.rows + 'px';
	    }
	    this.scrollArea.style.height = size.height * this.lastRecordedBufferLength + 'px';
	  }
	};
	
	/**
	 * Updates dimensions and synchronizes the scroll area if necessary.
	 */
	Viewport.prototype.syncScrollArea = function () {
	  if (this.lastRecordedBufferLength !== this.terminal.lines.length) {
	    // If buffer height changed
	    this.lastRecordedBufferLength = this.terminal.lines.length;
	    this.refresh();
	  } else if (this.lastRecordedViewportHeight !== this.terminal.rows) {
	    // If viewport height changed
	    this.refresh();
	  } else {
	    // If size has changed, refresh viewport
	    var size = this.charMeasureElement.getBoundingClientRect();
	    if (size.height !== this.currentRowHeight) {
	      this.refresh(size);
	    }
	  }
	
	  // Sync scrollTop
	  var scrollTop = this.terminal.ydisp * this.currentRowHeight;
	  if (this.viewportElement.scrollTop !== scrollTop) {
	    this.viewportElement.scrollTop = scrollTop;
	  }
	};
	
	/**
	 * Handles scroll events on the viewport, calculating the new viewport and requesting the
	 * terminal to scroll to it.
	 * @param {Event} ev The scroll event.
	 */
	Viewport.prototype.onScroll = function (ev) {
	  var newRow = Math.round(this.viewportElement.scrollTop / this.currentRowHeight);
	  var diff = newRow - this.terminal.ydisp;
	  this.terminal.scrollDisp(diff, true);
	};
	
	/**
	 * Handles mouse wheel events by adjusting the viewport's scrollTop and delegating the actual
	 * scrolling to `onScroll`, this event needs to be attached manually by the consumer of
	 * `Viewport`.
	 * @param {WheelEvent} ev The mouse wheel event.
	 */
	Viewport.prototype.onWheel = function (ev) {
	  if (ev.deltaY === 0) {
	    // Do nothing if it's not a vertical scroll event
	    return;
	  }
	  // Fallback to WheelEvent.DOM_DELTA_PIXEL
	  var multiplier = 1;
	  if (ev.deltaMode === WheelEvent.DOM_DELTA_LINE) {
	    multiplier = this.currentRowHeight;
	  } else if (ev.deltaMode === WheelEvent.DOM_DELTA_PAGE) {
	    multiplier = this.currentRowHeight * this.terminal.rows;
	  }
	  this.viewportElement.scrollTop += ev.deltaY * multiplier;
	  // Prevent the page from scrolling when the terminal scrolls
	  ev.preventDefault();
	};
	
	exports.Viewport = Viewport;
	
	},{}],4:[function(_dereq_,module,exports){
	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	/**
	 * xterm.js: xterm, in the browser
	 * Copyright (c) 2016, SourceLair Private Company <www.sourcelair.com> (MIT License)
	 */
	
	/**
	 * Clipboard handler module. This module contains methods for handling all
	 * clipboard-related events appropriately in the terminal.
	 * @module xterm/handlers/Clipboard
	 */
	
	/**
	 * Prepares text copied from terminal selection, to be saved in the clipboard by:
	 *   1. stripping all trailing white spaces
	 *   2. converting all non-breaking spaces to regular spaces
	 * @param {string} text The copied text that needs processing for storing in clipboard
	 * @returns {string}
	 */
	function prepareTextForClipboard(text) {
	  var space = String.fromCharCode(32),
	      nonBreakingSpace = String.fromCharCode(160),
	      allNonBreakingSpaces = new RegExp(nonBreakingSpace, 'g'),
	      processedText = text.split('\n').map(function (line) {
	    // Strip all trailing white spaces and convert all non-breaking spaces
	    // to regular spaces.
	    var processedLine = line.replace(/\s+$/g, '').replace(allNonBreakingSpaces, space);
	
	    return processedLine;
	  }).join('\n');
	
	  return processedText;
	}
	
	/**
	 * Binds copy functionality to the given terminal.
	 * @param {ClipboardEvent} ev The original copy event to be handled
	 */
	function copyHandler(ev) {
	  var copiedText = window.getSelection().toString(),
	      text = prepareTextForClipboard(copiedText);
	
	  ev.clipboardData.setData('text/plain', text);
	  ev.preventDefault(); // Prevent or the original text will be copied.
	}
	
	/**
	 * Redirect the clipboard's data to the terminal's input handler.
	 * @param {ClipboardEvent} ev The original paste event to be handled
	 * @param {Terminal} term The terminal on which to apply the handled paste event
	 */
	function pasteHandler(ev, term) {
	  ev.stopPropagation();
	  if (ev.clipboardData) {
	    var text = ev.clipboardData.getData('text/plain');
	    term.handler(text);
	    term.textarea.value = '';
	    return term.cancel(ev);
	  }
	}
	
	/**
	 * Bind to right-click event and allow right-click copy and paste.
	 *
	 * **Logic**
	 * If text is selected and right-click happens on selected text, then
	 * do nothing to allow seamless copying.
	 * If no text is selected or right-click is outside of the selection
	 * area, then bring the terminal's input below the cursor, in order to
	 * trigger the event on the textarea and allow-right click paste, without
	 * caring about disappearing selection.
	 * @param {ClipboardEvent} ev The original paste event to be handled
	 * @param {Terminal} term The terminal on which to apply the handled paste event
	 */
	function rightClickHandler(ev, term) {
	  var s = document.getSelection(),
	      sText = prepareTextForClipboard(s.toString()),
	      r = s.getRangeAt(0);
	
	  var x = ev.clientX,
	      y = ev.clientY;
	
	  var cr = r.getClientRects(),
	      clickIsOnSelection = false,
	      i,
	      rect;
	
	  for (i = 0; i < cr.length; i++) {
	    rect = cr[i];
	    clickIsOnSelection = x > rect.left && x < rect.right && y > rect.top && y < rect.bottom;
	    // If we clicked on selection and selection is not a single space,
	    // then mark the right click as copy-only. We check for the single
	    // space selection, as this can happen when clicking on an &nbsp;
	    // and there is not much pointing in copying a single space.
	    // Single space is char
	    if (clickIsOnSelection && sText !== ' ') {
	      break;
	    }
	  }
	
	  // Bring textarea at the cursor position
	  if (!clickIsOnSelection) {
	    term.textarea.style.position = 'fixed';
	    term.textarea.style.width = '10px';
	    term.textarea.style.height = '10px';
	    term.textarea.style.left = x + 'px';
	    term.textarea.style.top = y + 'px';
	    term.textarea.style.zIndex = 1000;
	    term.textarea.focus();
	
	    // Reset the terminal textarea's styling
	    setTimeout(function () {
	      term.textarea.style.position = null;
	      term.textarea.style.width = null;
	      term.textarea.style.height = null;
	      term.textarea.style.left = null;
	      term.textarea.style.top = null;
	      term.textarea.style.zIndex = null;
	    }, 1);
	  }
	}
	
	exports.prepareTextForClipboard = prepareTextForClipboard;
	exports.copyHandler = copyHandler;
	exports.pasteHandler = pasteHandler;
	exports.rightClickHandler = rightClickHandler;
	
	},{}],5:[function(_dereq_,module,exports){
	(function (__dirname){
	'use strict';var _typeof=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};/**
	 * xterm.js: xterm, in the browser
	 * Copyright (c) 2014-2014, SourceLair Private Company <www.sourcelair.com> (MIT License)
	 * Copyright (c) 2012-2013, Christopher Jeffrey (MIT License)
	 * https://github.com/chjj/term.js
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 *
	 * Originally forked from (with the author's permission):
	 *   Fabrice Bellard's javascript vt100 for jslinux:
	 *   http://bellard.org/jslinux/
	 *   Copyright (c) 2011 Fabrice Bellard
	 *   The original design remains. The terminal itself
	 *   has been extended to include xterm CSI codes, among
	 *   other features.
	 */var _CompositionHelper=_dereq_('./CompositionHelper.js');var _EventEmitter=_dereq_('./EventEmitter.js');var _Viewport=_dereq_('./Viewport.js');var _Clipboard=_dereq_('./handlers/Clipboard.js');/**
	 * Terminal Emulation References:
	 *   http://vt100.net/
	 *   http://invisible-island.net/xterm/ctlseqs/ctlseqs.txt
	 *   http://invisible-island.net/xterm/ctlseqs/ctlseqs.html
	 *   http://invisible-island.net/vttest/
	 *   http://www.inwap.com/pdp10/ansicode.txt
	 *   http://linux.die.net/man/4/console_codes
	 *   http://linux.die.net/man/7/urxvt
	 */// Let it work inside Node.js for automated testing purposes.
	var document=typeof window!='undefined'?window.document:null;/**
	 * States
	 */var normal=0,escaped=1,csi=2,osc=3,charset=4,dcs=5,ignore=6;/**
	 * Terminal
	 *//**
	 * Creates a new `Terminal` object.
	 *
	 * @param {object} options An object containing a set of options, the available options are:
	 *   - cursorBlink (boolean): Whether the terminal cursor blinks
	 *
	 * @public
	 * @class Xterm Xterm
	 * @alias module:xterm/src/xterm
	 */function Terminal(options){var self=this;if(!(this instanceof Terminal)){return new Terminal(arguments[0],arguments[1],arguments[2]);}self.cancel=Terminal.cancel;_EventEmitter.EventEmitter.call(this);if(typeof options==='number'){options={cols:arguments[0],rows:arguments[1],handler:arguments[2]};}options=options||{};Object.keys(Terminal.defaults).forEach(function(key){if(options[key]==null){options[key]=Terminal.options[key];if(Terminal[key]!==Terminal.defaults[key]){options[key]=Terminal[key];}}self[key]=options[key];});if(options.colors.length===8){options.colors=options.colors.concat(Terminal._colors.slice(8));}else if(options.colors.length===16){options.colors=options.colors.concat(Terminal._colors.slice(16));}else if(options.colors.length===10){options.colors=options.colors.slice(0,-2).concat(Terminal._colors.slice(8,-2),options.colors.slice(-2));}else if(options.colors.length===18){options.colors=options.colors.concat(Terminal._colors.slice(16,-2),options.colors.slice(-2));}this.colors=options.colors;this.options=options;// this.context = options.context || window;
	// this.document = options.document || document;
	this.parent=options.body||options.parent||(document?document.getElementsByTagName('body')[0]:null);this.cols=options.cols||options.geometry[0];this.rows=options.rows||options.geometry[1];if(options.handler){this.on('data',options.handler);}/**
	   * The scroll position of the y cursor, ie. ybase + y = the y position within the entire
	   * buffer
	   */this.ybase=0;/**
	   * The scroll position of the viewport
	   */this.ydisp=0;/**
	   * The cursor's x position after ybase
	   */this.x=0;/**
	   * The cursor's y position after ybase
	   */this.y=0;/**
	   * Used to debounce the refresh function
	   */this.isRefreshing=false;/**
	   * Whether there is a full terminal refresh queued
	   */this.cursorState=0;this.cursorHidden=false;this.convertEol;this.state=0;this.queue='';this.scrollTop=0;this.scrollBottom=this.rows-1;this.customKeydownHandler=null;// modes
	this.applicationKeypad=false;this.applicationCursor=false;this.originMode=false;this.insertMode=false;this.wraparoundMode=true;// defaults: xterm - true, vt100 - false
	this.normal=null;// charset
	this.charset=null;this.gcharset=null;this.glevel=0;this.charsets=[null];// mouse properties
	this.decLocator;this.x10Mouse;this.vt200Mouse;this.vt300Mouse;this.normalMouse;this.mouseEvents;this.sendFocus;this.utfMouse;this.sgrMouse;this.urxvtMouse;// misc
	this.element;this.children;this.refreshStart;this.refreshEnd;this.savedX;this.savedY;this.savedCols;// stream
	this.readable=true;this.writable=true;this.defAttr=0<<18|257<<9|256<<0;this.curAttr=this.defAttr;this.params=[];this.currentParam=0;this.prefix='';this.postfix='';// leftover surrogate high from previous write invocation
	this.surrogate_high='';/**
	   * An array of all lines in the entire buffer, including the prompt. The lines are array of
	   * characters which are 2-length arrays where [0] is an attribute and [1] is the character.
	   */this.lines=[];var i=this.rows;while(i--){this.lines.push(this.blankLine());}this.tabs;this.setupStops();}inherits(Terminal,_EventEmitter.EventEmitter);/**
	 * back_color_erase feature for xterm.
	 */Terminal.prototype.eraseAttr=function(){// if (this.is('screen')) return this.defAttr;
	return this.defAttr&~0x1ff|this.curAttr&0x1ff;};/**
	 * Colors
	 */// Colors 0-15
	Terminal.tangoColors=[// dark:
	'#2e3436','#cc0000','#4e9a06','#c4a000','#3465a4','#75507b','#06989a','#d3d7cf',// bright:
	'#555753','#ef2929','#8ae234','#fce94f','#729fcf','#ad7fa8','#34e2e2','#eeeeec'];// Colors 0-15 + 16-255
	// Much thanks to TooTallNate for writing this.
	Terminal.colors=function(){var colors=Terminal.tangoColors.slice(),r=[0x00,0x5f,0x87,0xaf,0xd7,0xff],i;// 16-231
	i=0;for(;i<216;i++){out(r[i/36%6|0],r[i/6%6|0],r[i%6]);}// 232-255 (grey)
	i=0;for(;i<24;i++){r=8+i*10;out(r,r,r);}function out(r,g,b){colors.push('#'+hex(r)+hex(g)+hex(b));}function hex(c){c=c.toString(16);return c.length<2?'0'+c:c;}return colors;}();Terminal._colors=Terminal.colors.slice();Terminal.vcolors=function(){var out=[],colors=Terminal.colors,i=0,color;for(;i<256;i++){color=parseInt(colors[i].substring(1),16);out.push([color>>16&0xff,color>>8&0xff,color&0xff]);}return out;}();/**
	 * Options
	 */Terminal.defaults={colors:Terminal.colors,theme:'default',convertEol:false,termName:'xterm',geometry:[80,24],cursorBlink:false,visualBell:false,popOnBell:false,scrollback:1000,screenKeys:false,debug:false,cancelEvents:false// programFeatures: false,
	// focusKeys: false,
	};Terminal.options={};Terminal.focus=null;each(keys(Terminal.defaults),function(key){Terminal[key]=Terminal.defaults[key];Terminal.options[key]=Terminal.defaults[key];});/**
	 * Focus the terminal. Delegates focus handling to the terminal's DOM element.
	 */Terminal.prototype.focus=function(){return this.textarea.focus();};/**
	 * Retrieves an option's value from the terminal.
	 * @param {string} key The option key.
	 */Terminal.prototype.getOption=function(key,value){if(!(key in Terminal.defaults)){throw new Error('No option with key "'+key+'"');}if(typeof this.options[key]!=='undefined'){return this.options[key];}return this[key];};/**
	 * Sets an option on the terminal.
	 * @param {string} key The option key.
	 * @param {string} value The option value.
	 */Terminal.prototype.setOption=function(key,value){if(!(key in Terminal.defaults)){throw new Error('No option with key "'+key+'"');}this[key]=value;this.options[key]=value;};/**
	 * Binds the desired focus behavior on a given terminal object.
	 *
	 * @static
	 */Terminal.bindFocus=function(term){on(term.textarea,'focus',function(ev){if(term.sendFocus){term.send('\x1b[I');}term.element.classList.add('focus');term.showCursor();Terminal.focus=term;term.emit('focus',{terminal:term});});};/**
	 * Blur the terminal. Delegates blur handling to the terminal's DOM element.
	 */Terminal.prototype.blur=function(){return this.textarea.blur();};/**
	 * Binds the desired blur behavior on a given terminal object.
	 *
	 * @static
	 */Terminal.bindBlur=function(term){on(term.textarea,'blur',function(ev){term.refresh(term.y,term.y);if(term.sendFocus){term.send('\x1b[O');}term.element.classList.remove('focus');Terminal.focus=null;term.emit('blur',{terminal:term});});};/**
	 * Initialize default behavior
	 */Terminal.prototype.initGlobal=function(){var term=this;Terminal.bindKeys(this);Terminal.bindFocus(this);Terminal.bindBlur(this);// Bind clipboard functionality
	on(this.element,'copy',_Clipboard.copyHandler);on(this.textarea,'paste',function(ev){_Clipboard.pasteHandler.call(this,ev,term);});on(this.element,'contextmenu',function(ev){_Clipboard.rightClickHandler.call(this,ev,term);});};/**
	 * Apply key handling to the terminal
	 */Terminal.bindKeys=function(term){on(term.element,'keydown',function(ev){if(document.activeElement!=this){return;}term.keyDown(ev);},true);on(term.element,'keypress',function(ev){if(document.activeElement!=this){return;}term.keyPress(ev);},true);on(term.element,'keyup',term.focus.bind(term));on(term.textarea,'keydown',function(ev){term.keyDown(ev);},true);on(term.textarea,'keypress',function(ev){term.keyPress(ev);// Truncate the textarea's value, since it is not needed
	this.value='';},true);on(term.textarea,'compositionstart',term.compositionHelper.compositionstart.bind(term.compositionHelper));on(term.textarea,'compositionupdate',term.compositionHelper.compositionupdate.bind(term.compositionHelper));on(term.textarea,'compositionend',term.compositionHelper.compositionend.bind(term.compositionHelper));term.on('refresh',term.compositionHelper.updateCompositionElements.bind(term.compositionHelper));};/**
	 * Insert the given row to the terminal or produce a new one
	 * if no row argument is passed. Return the inserted row.
	 * @param {HTMLElement} row (optional) The row to append to the terminal.
	 */Terminal.prototype.insertRow=function(row){if((typeof row==='undefined'?'undefined':_typeof(row))!='object'){row=document.createElement('div');}this.rowContainer.appendChild(row);this.children.push(row);return row;};/**
	 * Opens the terminal within an element.
	 *
	 * @param {HTMLElement} parent The element to create the terminal within.
	 */Terminal.prototype.open=function(parent){var self=this,i=0,div;this.parent=parent||this.parent;if(!this.parent){throw new Error('Terminal requires a parent element.');}// Grab global elements
	this.context=this.parent.ownerDocument.defaultView;this.document=this.parent.ownerDocument;this.body=this.document.getElementsByTagName('body')[0];// Parse User-Agent
	if(this.context.navigator&&this.context.navigator.userAgent){this.isMSIE=!!~this.context.navigator.userAgent.indexOf('MSIE');}// Find the users platform. We use this to interpret the meta key
	// and ISO third level shifts.
	// http://stackoverflow.com/q/19877924/577598
	if(this.context.navigator&&this.context.navigator.platform){this.isMac=contains(this.context.navigator.platform,['Macintosh','MacIntel','MacPPC','Mac68K']);this.isIpad=this.context.navigator.platform==='iPad';this.isIphone=this.context.navigator.platform==='iPhone';this.isMSWindows=contains(this.context.navigator.platform,['Windows','Win16','Win32','WinCE']);}//Create main element container
	this.element=this.document.createElement('div');this.element.classList.add('terminal');this.element.classList.add('xterm');this.element.classList.add('xterm-theme-'+this.theme);this.element.style.height;this.element.setAttribute('tabindex',0);this.viewportElement=document.createElement('div');this.viewportElement.classList.add('xterm-viewport');this.element.appendChild(this.viewportElement);this.viewportScrollArea=document.createElement('div');this.viewportScrollArea.classList.add('xterm-scroll-area');this.viewportElement.appendChild(this.viewportScrollArea);// Create the container that will hold the lines of the terminal and then
	// produce the lines the lines.
	this.rowContainer=document.createElement('div');this.rowContainer.classList.add('xterm-rows');this.element.appendChild(this.rowContainer);this.children=[];// Create the container that will hold helpers like the textarea for
	// capturing DOM Events. Then produce the helpers.
	this.helperContainer=document.createElement('div');this.helperContainer.classList.add('xterm-helpers');// TODO: This should probably be inserted once it's filled to prevent an additional layout
	this.element.appendChild(this.helperContainer);this.textarea=document.createElement('textarea');this.textarea.classList.add('xterm-helper-textarea');this.textarea.setAttribute('autocorrect','off');this.textarea.setAttribute('autocapitalize','off');this.textarea.setAttribute('spellcheck','false');this.textarea.tabIndex=0;this.textarea.addEventListener('focus',function(){self.emit('focus',{terminal:self});});this.textarea.addEventListener('blur',function(){self.emit('blur',{terminal:self});});this.helperContainer.appendChild(this.textarea);this.compositionView=document.createElement('div');this.compositionView.classList.add('composition-view');this.compositionHelper=new _CompositionHelper.CompositionHelper(this.textarea,this.compositionView,this);this.helperContainer.appendChild(this.compositionView);this.charMeasureElement=document.createElement('div');this.charMeasureElement.classList.add('xterm-char-measure-element');this.charMeasureElement.innerHTML='W';this.helperContainer.appendChild(this.charMeasureElement);for(;i<this.rows;i++){this.insertRow();}this.parent.appendChild(this.element);this.viewport=new _Viewport.Viewport(this,this.viewportElement,this.viewportScrollArea,this.charMeasureElement);// Draw the screen.
	this.refresh(0,this.rows-1);// Initialize global actions that
	// need to be taken on the document.
	this.initGlobal();// Ensure there is a Terminal.focus.
	this.focus();on(this.element,'click',function(){var selection=document.getSelection(),collapsed=selection.isCollapsed,isRange=typeof collapsed=='boolean'?!collapsed:selection.type=='Range';if(!isRange){self.focus();}});// Listen for mouse events and translate
	// them into terminal mouse protocols.
	this.bindMouse();// Figure out whether boldness affects
	// the character width of monospace fonts.
	if(Terminal.brokenBold==null){Terminal.brokenBold=isBoldBroken(this.document);}this.emit('open');};/**
	 * Attempts to load an add-on using CommonJS or RequireJS (whichever is available).
	 * @param {string} addon The name of the addon to load
	 * @static
	 */Terminal.loadAddon=function(addon,callback){if((typeof exports==='undefined'?'undefined':_typeof(exports))==='object'&&(typeof module==='undefined'?'undefined':_typeof(module))==='object'){// CommonJS
	return _dereq_(__dirname+'/../addons/'+addon);}else if(typeof define=='function'){// RequireJS
	return _dereq_(['../addons/'+addon+'/'+addon],callback);}else{console.error('Cannot load a module without a CommonJS or RequireJS environment.');return false;}};/**
	 * XTerm mouse events
	 * http://invisible-island.net/xterm/ctlseqs/ctlseqs.html#Mouse%20Tracking
	 * To better understand these
	 * the xterm code is very helpful:
	 * Relevant files:
	 *   button.c, charproc.c, misc.c
	 * Relevant functions in xterm/button.c:
	 *   BtnCode, EmitButtonCode, EditorButton, SendMousePosition
	 */Terminal.prototype.bindMouse=function(){var el=this.element,self=this,pressed=32;// mouseup, mousedown, wheel
	// left click: ^[[M 3<^[[M#3<
	// wheel up: ^[[M`3>
	function sendButton(ev){var button,pos;// get the xterm-style button
	button=getButton(ev);// get mouse coordinates
	pos=getCoords(ev);if(!pos)return;sendEvent(button,pos);switch(ev.overrideType||ev.type){case'mousedown':pressed=button;break;case'mouseup':// keep it at the left
	// button, just in case.
	pressed=32;break;case'wheel':// nothing. don't
	// interfere with
	// `pressed`.
	break;}}// motion example of a left click:
	// ^[[M 3<^[[M@4<^[[M@5<^[[M@6<^[[M@7<^[[M#7<
	function sendMove(ev){var button=pressed,pos;pos=getCoords(ev);if(!pos)return;// buttons marked as motions
	// are incremented by 32
	button+=32;sendEvent(button,pos);}// encode button and
	// position to characters
	function encode(data,ch){if(!self.utfMouse){if(ch===255)return data.push(0);if(ch>127)ch=127;data.push(ch);}else{if(ch===2047)return data.push(0);if(ch<127){data.push(ch);}else{if(ch>2047)ch=2047;data.push(0xC0|ch>>6);data.push(0x80|ch&0x3F);}}}// send a mouse event:
	// regular/utf8: ^[[M Cb Cx Cy
	// urxvt: ^[[ Cb ; Cx ; Cy M
	// sgr: ^[[ Cb ; Cx ; Cy M/m
	// vt300: ^[[ 24(1/3/5)~ [ Cx , Cy ] \r
	// locator: CSI P e ; P b ; P r ; P c ; P p & w
	function sendEvent(button,pos){// self.emit('mouse', {
	//   x: pos.x - 32,
	//   y: pos.x - 32,
	//   button: button
	// });
	if(self.vt300Mouse){// NOTE: Unstable.
	// http://www.vt100.net/docs/vt3xx-gp/chapter15.html
	button&=3;pos.x-=32;pos.y-=32;var data='\x1b[24';if(button===0)data+='1';else if(button===1)data+='3';else if(button===2)data+='5';else if(button===3)return;else data+='0';data+='~['+pos.x+','+pos.y+']\r';self.send(data);return;}if(self.decLocator){// NOTE: Unstable.
	button&=3;pos.x-=32;pos.y-=32;if(button===0)button=2;else if(button===1)button=4;else if(button===2)button=6;else if(button===3)button=3;self.send('\x1b['+button+';'+(button===3?4:0)+';'+pos.y+';'+pos.x+';'+(pos.page||0)+'&w');return;}if(self.urxvtMouse){pos.x-=32;pos.y-=32;pos.x++;pos.y++;self.send('\x1b['+button+';'+pos.x+';'+pos.y+'M');return;}if(self.sgrMouse){pos.x-=32;pos.y-=32;self.send('\x1b[<'+((button&3)===3?button&~3:button)+';'+pos.x+';'+pos.y+((button&3)===3?'m':'M'));return;}var data=[];encode(data,button);encode(data,pos.x);encode(data,pos.y);self.send('\x1b[M'+String.fromCharCode.apply(String,data));}function getButton(ev){var button,shift,meta,ctrl,mod;// two low bits:
	// 0 = left
	// 1 = middle
	// 2 = right
	// 3 = release
	// wheel up/down:
	// 1, and 2 - with 64 added
	switch(ev.overrideType||ev.type){case'mousedown':button=ev.button!=null?+ev.button:ev.which!=null?ev.which-1:null;if(self.isMSIE){button=button===1?0:button===4?1:button;}break;case'mouseup':button=3;break;case'DOMMouseScroll':button=ev.detail<0?64:65;break;case'wheel':button=ev.wheelDeltaY>0?64:65;break;}// next three bits are the modifiers:
	// 4 = shift, 8 = meta, 16 = control
	shift=ev.shiftKey?4:0;meta=ev.metaKey?8:0;ctrl=ev.ctrlKey?16:0;mod=shift|meta|ctrl;// no mods
	if(self.vt200Mouse){// ctrl only
	mod&=ctrl;}else if(!self.normalMouse){mod=0;}// increment to SP
	button=32+(mod<<2)+button;return button;}// mouse coordinates measured in cols/rows
	function getCoords(ev){var x,y,w,h,el;// ignore browsers without pageX for now
	if(ev.pageX==null)return;x=ev.pageX;y=ev.pageY;el=self.element;// should probably check offsetParent
	// but this is more portable
	while(el&&el!==self.document.documentElement){x-=el.offsetLeft;y-=el.offsetTop;el='offsetParent'in el?el.offsetParent:el.parentNode;}// convert to cols/rows
	w=self.element.clientWidth;h=self.element.clientHeight;x=Math.ceil(x/w*self.cols);y=Math.ceil(y/h*self.rows);// be sure to avoid sending
	// bad positions to the program
	if(x<0)x=0;if(x>self.cols)x=self.cols;if(y<0)y=0;if(y>self.rows)y=self.rows;// xterm sends raw bytes and
	// starts at 32 (SP) for each.
	x+=32;y+=32;return{x:x,y:y,type:'wheel'};}on(el,'mousedown',function(ev){if(!self.mouseEvents)return;// send the button
	sendButton(ev);// ensure focus
	self.focus();// fix for odd bug
	//if (self.vt200Mouse && !self.normalMouse) {
	if(self.vt200Mouse){ev.overrideType='mouseup';sendButton(ev);return self.cancel(ev);}// bind events
	if(self.normalMouse)on(self.document,'mousemove',sendMove);// x10 compatibility mode can't send button releases
	if(!self.x10Mouse){on(self.document,'mouseup',function up(ev){sendButton(ev);if(self.normalMouse)off(self.document,'mousemove',sendMove);off(self.document,'mouseup',up);return self.cancel(ev);});}return self.cancel(ev);});//if (self.normalMouse) {
	//  on(self.document, 'mousemove', sendMove);
	//}
	on(el,'wheel',function(ev){if(!self.mouseEvents)return;if(self.x10Mouse||self.vt300Mouse||self.decLocator)return;sendButton(ev);return self.cancel(ev);});// allow wheel scrolling in
	// the shell for example
	on(el,'wheel',function(ev){if(self.mouseEvents)return;self.viewport.onWheel(ev);return self.cancel(ev);});};/**
	 * Destroys the terminal.
	 */Terminal.prototype.destroy=function(){this.readable=false;this.writable=false;this._events={};this.handler=function(){};this.write=function(){};if(this.element.parentNode){this.element.parentNode.removeChild(this.element);}//this.emit('close');
	};/**
	 * Flags used to render terminal text properly
	 */Terminal.flags={BOLD:1,UNDERLINE:2,BLINK:4,INVERSE:8,INVISIBLE:16};/**
	 * Refreshes (re-renders) terminal content within two rows (inclusive)
	 *
	 * Rendering Engine:
	 *
	 * In the screen buffer, each character is stored as a an array with a character
	 * and a 32-bit integer:
	 *   - First value: a utf-16 character.
	 *   - Second value:
	 *   - Next 9 bits: background color (0-511).
	 *   - Next 9 bits: foreground color (0-511).
	 *   - Next 14 bits: a mask for misc. flags:
	 *     - 1=bold
	 *     - 2=underline
	 *     - 4=blink
	 *     - 8=inverse
	 *     - 16=invisible
	 *
	 * @param {number} start The row to start from (between 0 and terminal's height terminal - 1)
	 * @param {number} end The row to end at (between fromRow and terminal's height terminal - 1)
	 * @param {boolean} queue Whether the refresh should ran right now or be queued
	 */Terminal.prototype.refresh=function(start,end,queue){var self=this;// queue defaults to true
	queue=typeof queue=='undefined'?true:queue;/**
	   * The refresh queue allows refresh to execute only approximately 30 times a second. For
	   * commands that pass a significant amount of output to the write function, this prevents the
	   * terminal from maxing out the CPU and making the UI unresponsive. While commands can still
	   * run beyond what they do on the terminal, it is far better with a debounce in place as
	   * every single terminal manipulation does not need to be constructed in the DOM.
	   *
	   * A side-effect of this is that it makes ^C to interrupt a process seem more responsive.
	   */if(queue){// If refresh should be queued, order the refresh and return.
	if(this._refreshIsQueued){// If a refresh has already been queued, just order a full refresh next
	this._fullRefreshNext=true;}else{setTimeout(function(){self.refresh(start,end,false);},34);this._refreshIsQueued=true;}return;}// If refresh should be run right now (not be queued), release the lock
	this._refreshIsQueued=false;// If multiple refreshes were requested, make a full refresh.
	if(this._fullRefreshNext){start=0;end=this.rows-1;this._fullRefreshNext=false;// reset lock
	}var x,y,i,line,out,ch,ch_width,width,data,attr,bg,fg,flags,row,parent,focused=document.activeElement;// If this is a big refresh, remove the terminal rows from the DOM for faster calculations
	if(end-start>=this.rows/2){parent=this.element.parentNode;if(parent){this.element.removeChild(this.rowContainer);}}width=this.cols;y=start;if(end>=this.rows.length){this.log('`end` is too large. Most likely a bad CSR.');end=this.rows.length-1;}for(;y<=end;y++){row=y+this.ydisp;line=this.lines[row];out='';if(this.y===y-(this.ybase-this.ydisp)&&this.cursorState&&!this.cursorHidden){x=this.x;}else{x=-1;}attr=this.defAttr;i=0;for(;i<width;i++){data=line[i][0];ch=line[i][1];ch_width=line[i][2];if(!ch_width)continue;if(i===x)data=-1;if(data!==attr){if(attr!==this.defAttr){out+='</span>';}if(data!==this.defAttr){if(data===-1){out+='<span class="reverse-video terminal-cursor';if(this.cursorBlink){out+=' blinking';}out+='">';}else{var classNames=[];bg=data&0x1ff;fg=data>>9&0x1ff;flags=data>>18;if(flags&Terminal.flags.BOLD){if(!Terminal.brokenBold){classNames.push('xterm-bold');}// See: XTerm*boldColors
	if(fg<8)fg+=8;}if(flags&Terminal.flags.UNDERLINE){classNames.push('xterm-underline');}if(flags&Terminal.flags.BLINK){classNames.push('xterm-blink');}// If inverse flag is on, then swap the foreground and background variables.
	if(flags&Terminal.flags.INVERSE){/* One-line variable swap in JavaScript: http://stackoverflow.com/a/16201730 */bg=[fg,fg=bg][0];// Should inverse just be before the
	// above boldColors effect instead?
	if(flags&1&&fg<8)fg+=8;}if(flags&Terminal.flags.INVISIBLE){classNames.push('xterm-hidden');}/**
	             * Weird situation: Invert flag used black foreground and white background results
	             * in invalid background color, positioned at the 256 index of the 256 terminal
	             * color map. Pin the colors manually in such a case.
	             *
	             * Source: https://github.com/sourcelair/xterm.js/issues/57
	             */if(flags&Terminal.flags.INVERSE){if(bg==257){bg=15;}if(fg==256){fg=0;}}if(bg<256){classNames.push('xterm-bg-color-'+bg);}if(fg<256){classNames.push('xterm-color-'+fg);}out+='<span';if(classNames.length){out+=' class="'+classNames.join(' ')+'"';}out+='>';}}}switch(ch){case'&':out+='&amp;';break;case'<':out+='&lt;';break;case'>':out+='&gt;';break;default:if(ch<=' '){out+='&nbsp;';}else{out+=ch;}break;}attr=data;}if(attr!==this.defAttr){out+='</span>';}this.children[y].innerHTML=out;}if(parent){this.element.appendChild(this.rowContainer);}this.emit('refresh',{element:this.element,start:start,end:end});};/**
	 * Display the cursor element
	 */Terminal.prototype.showCursor=function(){if(!this.cursorState){this.cursorState=1;this.refresh(this.y,this.y);}};/**
	 * Scroll the terminal
	 */Terminal.prototype.scroll=function(){var row;if(++this.ybase===this.scrollback){this.ybase=this.ybase/2|0;this.lines=this.lines.slice(-(this.ybase+this.rows)+1);}this.ydisp=this.ybase;// last line
	row=this.ybase+this.rows-1;// subtract the bottom scroll region
	row-=this.rows-1-this.scrollBottom;if(row===this.lines.length){// potential optimization:
	// pushing is faster than splicing
	// when they amount to the same
	// behavior.
	this.lines.push(this.blankLine());}else{// add our new line
	this.lines.splice(row,0,this.blankLine());}if(this.scrollTop!==0){if(this.ybase!==0){this.ybase--;this.ydisp=this.ybase;}this.lines.splice(this.ybase+this.scrollTop,1);}// this.maxRange();
	this.updateRange(this.scrollTop);this.updateRange(this.scrollBottom);this.emit('scroll',this.ydisp);};/**
	 * Scroll the display of the terminal
	 * @param {number} disp The number of lines to scroll down (negatives scroll up).
	 * @param {boolean} suppressScrollEvent Don't emit the scroll event as scrollDisp. This is used
	 * to avoid unwanted events being handled by the veiwport when the event was triggered from the
	 * viewport originally.
	 */Terminal.prototype.scrollDisp=function(disp,suppressScrollEvent){this.ydisp+=disp;if(this.ydisp>this.ybase){this.ydisp=this.ybase;}else if(this.ydisp<0){this.ydisp=0;}if(!suppressScrollEvent){this.emit('scroll',this.ydisp);}this.refresh(0,this.rows-1);};/**
	 * Writes text to the terminal.
	 * @param {string} text The text to write to the terminal.
	 */Terminal.prototype.write=function(data){var l=data.length,i=0,j,cs,ch,code,low,ch_width,row;this.refreshStart=this.y;this.refreshEnd=this.y;if(this.ybase!==this.ydisp){this.ydisp=this.ybase;this.emit('scroll',this.ydisp);this.maxRange();}// apply leftover surrogate high from last write
	if(this.surrogate_high){data=this.surrogate_high+data;this.surrogate_high='';}for(;i<l;i++){ch=data[i];// FIXME: higher chars than 0xa0 are not allowed in escape sequences
	//        --> maybe move to default
	code=data.charCodeAt(i);if(0xD800<=code&&code<=0xDBFF){// we got a surrogate high
	// get surrogate low (next 2 bytes)
	low=data.charCodeAt(i+1);if(isNaN(low)){// end of data stream, save surrogate high
	this.surrogate_high=ch;continue;}code=(code-0xD800)*0x400+(low-0xDC00)+0x10000;ch+=data.charAt(i+1);}// surrogate low - already handled above
	if(0xDC00<=code&&code<=0xDFFF)continue;switch(this.state){case normal:switch(ch){case'\x07':this.bell();break;// '\n', '\v', '\f'
	case'\n':case'\x0b':case'\x0c':if(this.convertEol){this.x=0;}this.y++;if(this.y>this.scrollBottom){this.y--;this.scroll();}break;// '\r'
	case'\r':this.x=0;break;// '\b'
	case'\x08':if(this.x>0){this.x--;}break;// '\t'
	case'\t':this.x=this.nextStop();break;// shift out
	case'\x0e':this.setgLevel(1);break;// shift in
	case'\x0f':this.setgLevel(0);break;// '\e'
	case'\x1b':this.state=escaped;break;default:// ' '
	// calculate print space
	// expensive call, therefore we save width in line buffer
	ch_width=wcwidth(code);if(ch>=' '){if(this.charset&&this.charset[ch]){ch=this.charset[ch];}row=this.y+this.ybase;// insert combining char in last cell
	// FIXME: needs handling after cursor jumps
	if(!ch_width&&this.x){// dont overflow left
	if(this.lines[row][this.x-1]){if(!this.lines[row][this.x-1][2]){// found empty cell after fullwidth, need to go 2 cells back
	if(this.lines[row][this.x-2])this.lines[row][this.x-2][1]+=ch;}else{this.lines[row][this.x-1][1]+=ch;}this.updateRange(this.y);}break;}// goto next line if ch would overflow
	// TODO: needs a global min terminal width of 2
	if(this.x+ch_width-1>=this.cols){// autowrap - DECAWM
	if(this.wraparoundMode){this.x=0;this.y++;if(this.y>this.scrollBottom){this.y--;this.scroll();}}else{this.x=this.cols-1;if(ch_width===2)// FIXME: check for xterm behavior
	continue;}}row=this.y+this.ybase;// insert mode: move characters to right
	if(this.insertMode){// do this twice for a fullwidth char
	for(var moves=0;moves<ch_width;++moves){// remove last cell, if it's width is 0
	// we have to adjust the second last cell as well
	var removed=this.lines[this.y+this.ybase].pop();if(removed[2]===0&&this.lines[row][this.cols-2]&&this.lines[row][this.cols-2][2]===2)this.lines[row][this.cols-2]=[this.curAttr,' ',1];// insert empty cell at cursor
	this.lines[row].splice(this.x,0,[this.curAttr,' ',1]);}}this.lines[row][this.x]=[this.curAttr,ch,ch_width];this.x++;this.updateRange(this.y);// fullwidth char - set next cell width to zero and advance cursor
	if(ch_width===2){this.lines[row][this.x]=[this.curAttr,'',0];this.x++;}}break;}break;case escaped:switch(ch){// ESC [ Control Sequence Introducer ( CSI is 0x9b).
	case'[':this.params=[];this.currentParam=0;this.state=csi;break;// ESC ] Operating System Command ( OSC is 0x9d).
	case']':this.params=[];this.currentParam=0;this.state=osc;break;// ESC P Device Control String ( DCS is 0x90).
	case'P':this.params=[];this.currentParam=0;this.state=dcs;break;// ESC _ Application Program Command ( APC is 0x9f).
	case'_':this.state=ignore;break;// ESC ^ Privacy Message ( PM is 0x9e).
	case'^':this.state=ignore;break;// ESC c Full Reset (RIS).
	case'c':this.reset();break;// ESC E Next Line ( NEL is 0x85).
	// ESC D Index ( IND is 0x84).
	case'E':this.x=0;;case'D':this.index();break;// ESC M Reverse Index ( RI is 0x8d).
	case'M':this.reverseIndex();break;// ESC % Select default/utf-8 character set.
	// @ = default, G = utf-8
	case'%'://this.charset = null;
	this.setgLevel(0);this.setgCharset(0,Terminal.charsets.US);this.state=normal;i++;break;// ESC (,),*,+,-,. Designate G0-G2 Character Set.
	case'(':// <-- this seems to get all the attention
	case')':case'*':case'+':case'-':case'.':switch(ch){case'(':this.gcharset=0;break;case')':this.gcharset=1;break;case'*':this.gcharset=2;break;case'+':this.gcharset=3;break;case'-':this.gcharset=1;break;case'.':this.gcharset=2;break;}this.state=charset;break;// Designate G3 Character Set (VT300).
	// A = ISO Latin-1 Supplemental.
	// Not implemented.
	case'/':this.gcharset=3;this.state=charset;i--;break;// ESC N
	// Single Shift Select of G2 Character Set
	// ( SS2 is 0x8e). This affects next character only.
	case'N':break;// ESC O
	// Single Shift Select of G3 Character Set
	// ( SS3 is 0x8f). This affects next character only.
	case'O':break;// ESC n
	// Invoke the G2 Character Set as GL (LS2).
	case'n':this.setgLevel(2);break;// ESC o
	// Invoke the G3 Character Set as GL (LS3).
	case'o':this.setgLevel(3);break;// ESC |
	// Invoke the G3 Character Set as GR (LS3R).
	case'|':this.setgLevel(3);break;// ESC }
	// Invoke the G2 Character Set as GR (LS2R).
	case'}':this.setgLevel(2);break;// ESC ~
	// Invoke the G1 Character Set as GR (LS1R).
	case'~':this.setgLevel(1);break;// ESC 7 Save Cursor (DECSC).
	case'7':this.saveCursor();this.state=normal;break;// ESC 8 Restore Cursor (DECRC).
	case'8':this.restoreCursor();this.state=normal;break;// ESC # 3 DEC line height/width
	case'#':this.state=normal;i++;break;// ESC H Tab Set (HTS is 0x88).
	case'H':this.tabSet();break;// ESC = Application Keypad (DECKPAM).
	case'=':this.log('Serial port requested application keypad.');this.applicationKeypad=true;this.viewport.syncScrollArea();this.state=normal;break;// ESC > Normal Keypad (DECKPNM).
	case'>':this.log('Switching back to normal keypad.');this.applicationKeypad=false;this.viewport.syncScrollArea();this.state=normal;break;default:this.state=normal;this.error('Unknown ESC control: %s.',ch);break;}break;case charset:switch(ch){case'0':// DEC Special Character and Line Drawing Set.
	cs=Terminal.charsets.SCLD;break;case'A':// UK
	cs=Terminal.charsets.UK;break;case'B':// United States (USASCII).
	cs=Terminal.charsets.US;break;case'4':// Dutch
	cs=Terminal.charsets.Dutch;break;case'C':// Finnish
	case'5':cs=Terminal.charsets.Finnish;break;case'R':// French
	cs=Terminal.charsets.French;break;case'Q':// FrenchCanadian
	cs=Terminal.charsets.FrenchCanadian;break;case'K':// German
	cs=Terminal.charsets.German;break;case'Y':// Italian
	cs=Terminal.charsets.Italian;break;case'E':// NorwegianDanish
	case'6':cs=Terminal.charsets.NorwegianDanish;break;case'Z':// Spanish
	cs=Terminal.charsets.Spanish;break;case'H':// Swedish
	case'7':cs=Terminal.charsets.Swedish;break;case'=':// Swiss
	cs=Terminal.charsets.Swiss;break;case'/':// ISOLatin (actually /A)
	cs=Terminal.charsets.ISOLatin;i++;break;default:// Default
	cs=Terminal.charsets.US;break;}this.setgCharset(this.gcharset,cs);this.gcharset=null;this.state=normal;break;case osc:// OSC Ps ; Pt ST
	// OSC Ps ; Pt BEL
	//   Set Text Parameters.
	if(ch==='\x1b'||ch==='\x07'){if(ch==='\x1b')i++;this.params.push(this.currentParam);switch(this.params[0]){case 0:case 1:case 2:if(this.params[1]){this.title=this.params[1];this.handleTitle(this.title);}break;case 3:// set X property
	break;case 4:case 5:// change dynamic colors
	break;case 10:case 11:case 12:case 13:case 14:case 15:case 16:case 17:case 18:case 19:// change dynamic ui colors
	break;case 46:// change log file
	break;case 50:// dynamic font
	break;case 51:// emacs shell
	break;case 52:// manipulate selection data
	break;case 104:case 105:case 110:case 111:case 112:case 113:case 114:case 115:case 116:case 117:case 118:// reset colors
	break;}this.params=[];this.currentParam=0;this.state=normal;}else{if(!this.params.length){if(ch>='0'&&ch<='9'){this.currentParam=this.currentParam*10+ch.charCodeAt(0)-48;}else if(ch===';'){this.params.push(this.currentParam);this.currentParam='';}}else{this.currentParam+=ch;}}break;case csi:// '?', '>', '!'
	if(ch==='?'||ch==='>'||ch==='!'){this.prefix=ch;break;}// 0 - 9
	if(ch>='0'&&ch<='9'){this.currentParam=this.currentParam*10+ch.charCodeAt(0)-48;break;}// '$', '"', ' ', '\''
	if(ch==='$'||ch==='"'||ch===' '||ch==='\''){this.postfix=ch;break;}this.params.push(this.currentParam);this.currentParam=0;// ';'
	if(ch===';')break;this.state=normal;switch(ch){// CSI Ps A
	// Cursor Up Ps Times (default = 1) (CUU).
	case'A':this.cursorUp(this.params);break;// CSI Ps B
	// Cursor Down Ps Times (default = 1) (CUD).
	case'B':this.cursorDown(this.params);break;// CSI Ps C
	// Cursor Forward Ps Times (default = 1) (CUF).
	case'C':this.cursorForward(this.params);break;// CSI Ps D
	// Cursor Backward Ps Times (default = 1) (CUB).
	case'D':this.cursorBackward(this.params);break;// CSI Ps ; Ps H
	// Cursor Position [row;column] (default = [1,1]) (CUP).
	case'H':this.cursorPos(this.params);break;// CSI Ps J  Erase in Display (ED).
	case'J':this.eraseInDisplay(this.params);break;// CSI Ps K  Erase in Line (EL).
	case'K':this.eraseInLine(this.params);break;// CSI Pm m  Character Attributes (SGR).
	case'm':if(!this.prefix){this.charAttributes(this.params);}break;// CSI Ps n  Device Status Report (DSR).
	case'n':if(!this.prefix){this.deviceStatus(this.params);}break;/**
	             * Additions
	             */// CSI Ps @
	// Insert Ps (Blank) Character(s) (default = 1) (ICH).
	case'@':this.insertChars(this.params);break;// CSI Ps E
	// Cursor Next Line Ps Times (default = 1) (CNL).
	case'E':this.cursorNextLine(this.params);break;// CSI Ps F
	// Cursor Preceding Line Ps Times (default = 1) (CNL).
	case'F':this.cursorPrecedingLine(this.params);break;// CSI Ps G
	// Cursor Character Absolute  [column] (default = [row,1]) (CHA).
	case'G':this.cursorCharAbsolute(this.params);break;// CSI Ps L
	// Insert Ps Line(s) (default = 1) (IL).
	case'L':this.insertLines(this.params);break;// CSI Ps M
	// Delete Ps Line(s) (default = 1) (DL).
	case'M':this.deleteLines(this.params);break;// CSI Ps P
	// Delete Ps Character(s) (default = 1) (DCH).
	case'P':this.deleteChars(this.params);break;// CSI Ps X
	// Erase Ps Character(s) (default = 1) (ECH).
	case'X':this.eraseChars(this.params);break;// CSI Pm `  Character Position Absolute
	//   [column] (default = [row,1]) (HPA).
	case'`':this.charPosAbsolute(this.params);break;// 141 61 a * HPR -
	// Horizontal Position Relative
	case'a':this.HPositionRelative(this.params);break;// CSI P s c
	// Send Device Attributes (Primary DA).
	// CSI > P s c
	// Send Device Attributes (Secondary DA)
	case'c':this.sendDeviceAttributes(this.params);break;// CSI Pm d
	// Line Position Absolute  [row] (default = [1,column]) (VPA).
	case'd':this.linePosAbsolute(this.params);break;// 145 65 e * VPR - Vertical Position Relative
	case'e':this.VPositionRelative(this.params);break;// CSI Ps ; Ps f
	//   Horizontal and Vertical Position [row;column] (default =
	//   [1,1]) (HVP).
	case'f':this.HVPosition(this.params);break;// CSI Pm h  Set Mode (SM).
	// CSI ? Pm h - mouse escape codes, cursor escape codes
	case'h':this.setMode(this.params);break;// CSI Pm l  Reset Mode (RM).
	// CSI ? Pm l
	case'l':this.resetMode(this.params);break;// CSI Ps ; Ps r
	//   Set Scrolling Region [top;bottom] (default = full size of win-
	//   dow) (DECSTBM).
	// CSI ? Pm r
	case'r':this.setScrollRegion(this.params);break;// CSI s
	//   Save cursor (ANSI.SYS).
	case's':this.saveCursor(this.params);break;// CSI u
	//   Restore cursor (ANSI.SYS).
	case'u':this.restoreCursor(this.params);break;/**
	             * Lesser Used
	             */// CSI Ps I
	// Cursor Forward Tabulation Ps tab stops (default = 1) (CHT).
	case'I':this.cursorForwardTab(this.params);break;// CSI Ps S  Scroll up Ps lines (default = 1) (SU).
	case'S':this.scrollUp(this.params);break;// CSI Ps T  Scroll down Ps lines (default = 1) (SD).
	// CSI Ps ; Ps ; Ps ; Ps ; Ps T
	// CSI > Ps; Ps T
	case'T':// if (this.prefix === '>') {
	//   this.resetTitleModes(this.params);
	//   break;
	// }
	// if (this.params.length > 2) {
	//   this.initMouseTracking(this.params);
	//   break;
	// }
	if(this.params.length<2&&!this.prefix){this.scrollDown(this.params);}break;// CSI Ps Z
	// Cursor Backward Tabulation Ps tab stops (default = 1) (CBT).
	case'Z':this.cursorBackwardTab(this.params);break;// CSI Ps b  Repeat the preceding graphic character Ps times (REP).
	case'b':this.repeatPrecedingCharacter(this.params);break;// CSI Ps g  Tab Clear (TBC).
	case'g':this.tabClear(this.params);break;// CSI Pm i  Media Copy (MC).
	// CSI ? Pm i
	// case 'i':
	//   this.mediaCopy(this.params);
	//   break;
	// CSI Pm m  Character Attributes (SGR).
	// CSI > Ps; Ps m
	// case 'm': // duplicate
	//   if (this.prefix === '>') {
	//     this.setResources(this.params);
	//   } else {
	//     this.charAttributes(this.params);
	//   }
	//   break;
	// CSI Ps n  Device Status Report (DSR).
	// CSI > Ps n
	// case 'n': // duplicate
	//   if (this.prefix === '>') {
	//     this.disableModifiers(this.params);
	//   } else {
	//     this.deviceStatus(this.params);
	//   }
	//   break;
	// CSI > Ps p  Set pointer mode.
	// CSI ! p   Soft terminal reset (DECSTR).
	// CSI Ps$ p
	//   Request ANSI mode (DECRQM).
	// CSI ? Ps$ p
	//   Request DEC private mode (DECRQM).
	// CSI Ps ; Ps " p
	case'p':switch(this.prefix){// case '>':
	//   this.setPointerMode(this.params);
	//   break;
	case'!':this.softReset(this.params);break;// case '?':
	//   if (this.postfix === '$') {
	//     this.requestPrivateMode(this.params);
	//   }
	//   break;
	// default:
	//   if (this.postfix === '"') {
	//     this.setConformanceLevel(this.params);
	//   } else if (this.postfix === '$') {
	//     this.requestAnsiMode(this.params);
	//   }
	//   break;
	}break;// CSI Ps q  Load LEDs (DECLL).
	// CSI Ps SP q
	// CSI Ps " q
	// case 'q':
	//   if (this.postfix === ' ') {
	//     this.setCursorStyle(this.params);
	//     break;
	//   }
	//   if (this.postfix === '"') {
	//     this.setCharProtectionAttr(this.params);
	//     break;
	//   }
	//   this.loadLEDs(this.params);
	//   break;
	// CSI Ps ; Ps r
	//   Set Scrolling Region [top;bottom] (default = full size of win-
	//   dow) (DECSTBM).
	// CSI ? Pm r
	// CSI Pt; Pl; Pb; Pr; Ps$ r
	// case 'r': // duplicate
	//   if (this.prefix === '?') {
	//     this.restorePrivateValues(this.params);
	//   } else if (this.postfix === '$') {
	//     this.setAttrInRectangle(this.params);
	//   } else {
	//     this.setScrollRegion(this.params);
	//   }
	//   break;
	// CSI s     Save cursor (ANSI.SYS).
	// CSI ? Pm s
	// case 's': // duplicate
	//   if (this.prefix === '?') {
	//     this.savePrivateValues(this.params);
	//   } else {
	//     this.saveCursor(this.params);
	//   }
	//   break;
	// CSI Ps ; Ps ; Ps t
	// CSI Pt; Pl; Pb; Pr; Ps$ t
	// CSI > Ps; Ps t
	// CSI Ps SP t
	// case 't':
	//   if (this.postfix === '$') {
	//     this.reverseAttrInRectangle(this.params);
	//   } else if (this.postfix === ' ') {
	//     this.setWarningBellVolume(this.params);
	//   } else {
	//     if (this.prefix === '>') {
	//       this.setTitleModeFeature(this.params);
	//     } else {
	//       this.manipulateWindow(this.params);
	//     }
	//   }
	//   break;
	// CSI u     Restore cursor (ANSI.SYS).
	// CSI Ps SP u
	// case 'u': // duplicate
	//   if (this.postfix === ' ') {
	//     this.setMarginBellVolume(this.params);
	//   } else {
	//     this.restoreCursor(this.params);
	//   }
	//   break;
	// CSI Pt; Pl; Pb; Pr; Pp; Pt; Pl; Pp$ v
	// case 'v':
	//   if (this.postfix === '$') {
	//     this.copyRectagle(this.params);
	//   }
	//   break;
	// CSI Pt ; Pl ; Pb ; Pr ' w
	// case 'w':
	//   if (this.postfix === '\'') {
	//     this.enableFilterRectangle(this.params);
	//   }
	//   break;
	// CSI Ps x  Request Terminal Parameters (DECREQTPARM).
	// CSI Ps x  Select Attribute Change Extent (DECSACE).
	// CSI Pc; Pt; Pl; Pb; Pr$ x
	// case 'x':
	//   if (this.postfix === '$') {
	//     this.fillRectangle(this.params);
	//   } else {
	//     this.requestParameters(this.params);
	//     //this.__(this.params);
	//   }
	//   break;
	// CSI Ps ; Pu ' z
	// CSI Pt; Pl; Pb; Pr$ z
	// case 'z':
	//   if (this.postfix === '\'') {
	//     this.enableLocatorReporting(this.params);
	//   } else if (this.postfix === '$') {
	//     this.eraseRectangle(this.params);
	//   }
	//   break;
	// CSI Pm ' {
	// CSI Pt; Pl; Pb; Pr$ {
	// case '{':
	//   if (this.postfix === '\'') {
	//     this.setLocatorEvents(this.params);
	//   } else if (this.postfix === '$') {
	//     this.selectiveEraseRectangle(this.params);
	//   }
	//   break;
	// CSI Ps ' |
	// case '|':
	//   if (this.postfix === '\'') {
	//     this.requestLocatorPosition(this.params);
	//   }
	//   break;
	// CSI P m SP }
	// Insert P s Column(s) (default = 1) (DECIC), VT420 and up.
	// case '}':
	//   if (this.postfix === ' ') {
	//     this.insertColumns(this.params);
	//   }
	//   break;
	// CSI P m SP ~
	// Delete P s Column(s) (default = 1) (DECDC), VT420 and up
	// case '~':
	//   if (this.postfix === ' ') {
	//     this.deleteColumns(this.params);
	//   }
	//   break;
	default:this.error('Unknown CSI code: %s.',ch);break;}this.prefix='';this.postfix='';break;case dcs:if(ch==='\x1b'||ch==='\x07'){if(ch==='\x1b')i++;switch(this.prefix){// User-Defined Keys (DECUDK).
	case'':break;// Request Status String (DECRQSS).
	// test: echo -e '\eP$q"p\e\\'
	case'$q':var pt=this.currentParam,valid=false;switch(pt){// DECSCA
	case'"q':pt='0"q';break;// DECSCL
	case'"p':pt='61"p';break;// DECSTBM
	case'r':pt=''+(this.scrollTop+1)+';'+(this.scrollBottom+1)+'r';break;// SGR
	case'm':pt='0m';break;default:this.error('Unknown DCS Pt: %s.',pt);pt='';break;}this.send('\x1bP'+ +valid+'$r'+pt+'\x1b\\');break;// Set Termcap/Terminfo Data (xterm, experimental).
	case'+p':break;// Request Termcap/Terminfo String (xterm, experimental)
	// Regular xterm does not even respond to this sequence.
	// This can cause a small glitch in vim.
	// test: echo -ne '\eP+q6b64\e\\'
	case'+q':var pt=this.currentParam,valid=false;this.send('\x1bP'+ +valid+'+r'+pt+'\x1b\\');break;default:this.error('Unknown DCS prefix: %s.',this.prefix);break;}this.currentParam=0;this.prefix='';this.state=normal;}else if(!this.currentParam){if(!this.prefix&&ch!=='$'&&ch!=='+'){this.currentParam=ch;}else if(this.prefix.length===2){this.currentParam=ch;}else{this.prefix+=ch;}}else{this.currentParam+=ch;}break;case ignore:// For PM and APC.
	if(ch==='\x1b'||ch==='\x07'){if(ch==='\x1b')i++;this.state=normal;}break;}}this.updateRange(this.y);this.refresh(this.refreshStart,this.refreshEnd);};/**
	 * Writes text to the terminal, followed by a break line character (\n).
	 * @param {string} text The text to write to the terminal.
	 */Terminal.prototype.writeln=function(data){this.write(data+'\r\n');};/**
	 * Attaches a custom keydown handler which is run before keys are processed, giving consumers of
	 * xterm.js ultimate control as to what keys should be processed by the terminal and what keys
	 * should not.
	 * @param {function} customKeydownHandler The custom KeyboardEvent handler to attach. This is a
	 *   function that takes a KeyboardEvent, allowing consumers to stop propogation and/or prevent
	 *   the default action. The function returns whether the event should be processed by xterm.js.
	 */Terminal.prototype.attachCustomKeydownHandler=function(customKeydownHandler){this.customKeydownHandler=customKeydownHandler;};/**
	 * Handle a keydown event
	 * Key Resources:
	 *   - https://developer.mozilla.org/en-US/docs/DOM/KeyboardEvent
	 * @param {KeyboardEvent} ev The keydown event to be handled.
	 */Terminal.prototype.keyDown=function(ev){if(this.customKeydownHandler&&this.customKeydownHandler(ev)===false){return false;}if(!this.compositionHelper.keydown.bind(this.compositionHelper)(ev)){return false;}var self=this;var result=this.evaluateKeyEscapeSequence(ev);if(result.scrollDisp){this.scrollDisp(result.scrollDisp);return this.cancel(ev,true);}if(isThirdLevelShift(this,ev)){return true;}if(result.cancel){// The event is canceled at the end already, is this necessary?
	this.cancel(ev,true);}if(!result.key){return true;}this.emit('keydown',ev);this.emit('key',result.key,ev);this.showCursor();this.handler(result.key);return this.cancel(ev,true);};/**
	 * Returns an object that determines how a KeyboardEvent should be handled. The key of the
	 * returned value is the new key code to pass to the PTY.
	 *
	 * Reference: http://invisible-island.net/xterm/ctlseqs/ctlseqs.html
	 * @param {KeyboardEvent} ev The keyboard event to be translated to key escape sequence.
	 */Terminal.prototype.evaluateKeyEscapeSequence=function(ev){var result={// Whether to cancel event propogation (NOTE: this may not be needed since the event is
	// canceled at the end of keyDown
	cancel:false,// The new key even to emit
	key:undefined,// The number of characters to scroll, if this is defined it will cancel the event
	scrollDisp:undefined};var modifiers=ev.shiftKey<<0|ev.altKey<<1|ev.ctrlKey<<2|ev.metaKey<<3;switch(ev.keyCode){case 8:// backspace
	if(ev.shiftKey){result.key='\x08';// ^H
	break;}result.key='\x7f';// ^?
	break;case 9:// tab
	if(ev.shiftKey){result.key='\x1b[Z';break;}result.key='\t';result.cancel=true;break;case 13:// return/enter
	result.key='\r';result.cancel=true;break;case 27:// escape
	result.key='\x1b';result.cancel=true;break;case 37:// left-arrow
	if(modifiers){result.key='\x1b[1;'+(modifiers+1)+'D';// HACK: Make Alt + left-arrow behave like Ctrl + left-arrow: move one word backwards
	// http://unix.stackexchange.com/a/108106
	if(result.key=='\x1b[1;3D'){result.key='\x1b[1;5D';}}else if(this.applicationCursor){result.key='\x1bOD';}else{result.key='\x1b[D';}break;case 39:// right-arrow
	if(modifiers){result.key='\x1b[1;'+(modifiers+1)+'C';// HACK: Make Alt + right-arrow behave like Ctrl + right-arrow: move one word forward
	// http://unix.stackexchange.com/a/108106
	if(result.key=='\x1b[1;3C'){result.key='\x1b[1;5C';}}else if(this.applicationCursor){result.key='\x1bOC';}else{result.key='\x1b[C';}break;case 38:// up-arrow
	if(modifiers){result.key='\x1b[1;'+(modifiers+1)+'A';// HACK: Make Alt + up-arrow behave like Ctrl + up-arrow
	// http://unix.stackexchange.com/a/108106
	if(result.key=='\x1b[1;3A'){result.key='\x1b[1;5A';}}else if(this.applicationCursor){result.key='\x1bOA';}else{result.key='\x1b[A';}break;case 40:// down-arrow
	if(modifiers){result.key='\x1b[1;'+(modifiers+1)+'B';// HACK: Make Alt + down-arrow behave like Ctrl + down-arrow
	// http://unix.stackexchange.com/a/108106
	if(result.key=='\x1b[1;3B'){result.key='\x1b[1;5B';}}else if(this.applicationCursor){result.key='\x1bOB';}else{result.key='\x1b[B';}break;case 45:// insert
	if(!ev.shiftKey&&!ev.ctrlKey){// <Ctrl> or <Shift> + <Insert> are used to
	// copy-paste on some systems.
	result.key='\x1b[2~';}break;case 46:// delete
	if(modifiers){result.key='\x1b[3;'+(modifiers+1)+'~';}else{result.key='\x1b[3~';}break;case 36:// home
	if(modifiers)result.key='\x1b[1;'+(modifiers+1)+'H';else if(this.applicationCursor)result.key='\x1bOH';else result.key='\x1b[H';break;case 35:// end
	if(modifiers)result.key='\x1b[1;'+(modifiers+1)+'F';else if(this.applicationCursor)result.key='\x1bOF';else result.key='\x1b[F';break;case 33:// page up
	if(ev.shiftKey){result.scrollDisp=-(this.rows-1);}else{result.key='\x1b[5~';}break;case 34:// page down
	if(ev.shiftKey){result.scrollDisp=this.rows-1;}else{result.key='\x1b[6~';}break;case 112:// F1-F12
	if(modifiers){result.key='\x1b[1;'+(modifiers+1)+'P';}else{result.key='\x1bOP';}break;case 113:if(modifiers){result.key='\x1b[1;'+(modifiers+1)+'Q';}else{result.key='\x1bOQ';}break;case 114:if(modifiers){result.key='\x1b[1;'+(modifiers+1)+'R';}else{result.key='\x1bOR';}break;case 115:if(modifiers){result.key='\x1b[1;'+(modifiers+1)+'S';}else{result.key='\x1bOS';}break;case 116:if(modifiers){result.key='\x1b[15;'+(modifiers+1)+'~';}else{result.key='\x1b[15~';}break;case 117:if(modifiers){result.key='\x1b[17;'+(modifiers+1)+'~';}else{result.key='\x1b[17~';}break;case 118:if(modifiers){result.key='\x1b[18;'+(modifiers+1)+'~';}else{result.key='\x1b[18~';}break;case 119:if(modifiers){result.key='\x1b[19;'+(modifiers+1)+'~';}else{result.key='\x1b[19~';}break;case 120:if(modifiers){result.key='\x1b[20;'+(modifiers+1)+'~';}else{result.key='\x1b[20~';}break;case 121:if(modifiers){result.key='\x1b[21;'+(modifiers+1)+'~';}else{result.key='\x1b[21~';}break;case 122:if(modifiers){result.key='\x1b[23;'+(modifiers+1)+'~';}else{result.key='\x1b[23~';}break;case 123:if(modifiers){result.key='\x1b[24;'+(modifiers+1)+'~';}else{result.key='\x1b[24~';}break;default:// a-z and space
	if(ev.ctrlKey&&!ev.shiftKey&&!ev.altKey&&!ev.metaKey){if(ev.keyCode>=65&&ev.keyCode<=90){result.key=String.fromCharCode(ev.keyCode-64);}else if(ev.keyCode===32){// NUL
	result.key=String.fromCharCode(0);}else if(ev.keyCode>=51&&ev.keyCode<=55){// escape, file sep, group sep, record sep, unit sep
	result.key=String.fromCharCode(ev.keyCode-51+27);}else if(ev.keyCode===56){// delete
	result.key=String.fromCharCode(127);}else if(ev.keyCode===219){// ^[ - escape
	result.key=String.fromCharCode(27);}else if(ev.keyCode===221){// ^] - group sep
	result.key=String.fromCharCode(29);}}else if(!this.isMac&&ev.altKey&&!ev.ctrlKey&&!ev.metaKey){// On Mac this is a third level shift. Use <Esc> instead.
	if(ev.keyCode>=65&&ev.keyCode<=90){result.key='\x1b'+String.fromCharCode(ev.keyCode+32);}else if(ev.keyCode===192){result.key='\x1b`';}else if(ev.keyCode>=48&&ev.keyCode<=57){result.key='\x1b'+(ev.keyCode-48);}}break;}return result;};/**
	 * Set the G level of the terminal
	 * @param g
	 */Terminal.prototype.setgLevel=function(g){this.glevel=g;this.charset=this.charsets[g];};/**
	 * Set the charset for the given G level of the terminal
	 * @param g
	 * @param charset
	 */Terminal.prototype.setgCharset=function(g,charset){this.charsets[g]=charset;if(this.glevel===g){this.charset=charset;}};/**
	 * Handle a keypress event.
	 * Key Resources:
	 *   - https://developer.mozilla.org/en-US/docs/DOM/KeyboardEvent
	 * @param {KeyboardEvent} ev The keypress event to be handled.
	 */Terminal.prototype.keyPress=function(ev){var key;this.cancel(ev);if(ev.charCode){key=ev.charCode;}else if(ev.which==null){key=ev.keyCode;}else if(ev.which!==0&&ev.charCode!==0){key=ev.which;}else{return false;}if(!key||(ev.altKey||ev.ctrlKey||ev.metaKey)&&!isThirdLevelShift(this,ev)){return false;}key=String.fromCharCode(key);this.emit('keypress',key,ev);this.emit('key',key,ev);this.showCursor();this.handler(key);return false;};/**
	 * Send data for handling to the terminal
	 * @param {string} data
	 */Terminal.prototype.send=function(data){var self=this;if(!this.queue){setTimeout(function(){self.handler(self.queue);self.queue='';},1);}this.queue+=data;};/**
	 * Ring the bell.
	 * Note: We could do sweet things with webaudio here
	 */Terminal.prototype.bell=function(){if(!this.visualBell)return;var self=this;this.element.style.borderColor='white';setTimeout(function(){self.element.style.borderColor='';},10);if(this.popOnBell)this.focus();};/**
	 * Log the current state to the console.
	 */Terminal.prototype.log=function(){if(!this.debug)return;if(!this.context.console||!this.context.console.log)return;var args=Array.prototype.slice.call(arguments);this.context.console.log.apply(this.context.console,args);};/**
	 * Log the current state as error to the console.
	 */Terminal.prototype.error=function(){if(!this.debug)return;if(!this.context.console||!this.context.console.error)return;var args=Array.prototype.slice.call(arguments);this.context.console.error.apply(this.context.console,args);};/**
	 * Resizes the terminal.
	 *
	 * @param {number} x The number of columns to resize to.
	 * @param {number} y The number of rows to resize to.
	 */Terminal.prototype.resize=function(x,y){var line,el,i,j,ch,addToY;if(x===this.cols&&y===this.rows){return;}if(x<1)x=1;if(y<1)y=1;// resize cols
	j=this.cols;if(j<x){ch=[this.defAttr,' ',1];// does xterm use the default attr?
	i=this.lines.length;while(i--){while(this.lines[i].length<x){this.lines[i].push(ch);}}}else{// (j > x)
	i=this.lines.length;while(i--){while(this.lines[i].length>x){this.lines[i].pop();}}}this.setupStops(j);this.cols=x;// resize rows
	j=this.rows;addToY=0;if(j<y){el=this.element;while(j++<y){// y is rows, not this.y
	if(this.lines.length<y+this.ybase){if(this.ybase>0&&this.lines.length<=this.ybase+this.y+addToY+1){// There is room above the buffer and there are no empty elements below the line,
	// scroll up
	this.ybase--;addToY++;if(this.ydisp>0){// Viewport is at the top of the buffer, must increase downwards
	this.ydisp--;}}else{// Add a blank line if there is no buffer left at the top to scroll to, or if there
	// are blank lines after the cursor
	this.lines.push(this.blankLine());}}if(this.children.length<y){this.insertRow();}}}else{// (j > y)
	while(j-->y){if(this.lines.length>y+this.ybase){if(this.lines.length>this.ybase+this.y+1){// The line is a blank line below the cursor, remove it
	this.lines.pop();}else{// The line is the cursor, scroll down
	this.ybase++;this.ydisp++;}}if(this.children.length>y){el=this.children.shift();if(!el)continue;el.parentNode.removeChild(el);}}}this.rows=y;// Make sure that the cursor stays on screen
	if(this.y>=y){this.y=y-1;}if(addToY){this.y+=addToY;}if(this.x>=x){this.x=x-1;}this.scrollTop=0;this.scrollBottom=y-1;this.refresh(0,this.rows-1);this.normal=null;this.emit('resize',{terminal:this,cols:x,rows:y});};/**
	 * Updates the range of rows to refresh
	 * @param {number} y The number of rows to refresh next.
	 */Terminal.prototype.updateRange=function(y){if(y<this.refreshStart)this.refreshStart=y;if(y>this.refreshEnd)this.refreshEnd=y;// if (y > this.refreshEnd) {
	//   this.refreshEnd = y;
	//   if (y > this.rows - 1) {
	//     this.refreshEnd = this.rows - 1;
	//   }
	// }
	};/**
	 * Set the range of refreshing to the maximyum value
	 */Terminal.prototype.maxRange=function(){this.refreshStart=0;this.refreshEnd=this.rows-1;};/**
	 * Setup the tab stops.
	 * @param {number} i
	 */Terminal.prototype.setupStops=function(i){if(i!=null){if(!this.tabs[i]){i=this.prevStop(i);}}else{this.tabs={};i=0;}for(;i<this.cols;i+=8){this.tabs[i]=true;}};/**
	 * Move the cursor to the previous tab stop from the given position (default is current).
	 * @param {number} x The position to move the cursor to the previous tab stop.
	 */Terminal.prototype.prevStop=function(x){if(x==null)x=this.x;while(!this.tabs[--x]&&x>0){}return x>=this.cols?this.cols-1:x<0?0:x;};/**
	 * Move the cursor one tab stop forward from the given position (default is current).
	 * @param {number} x The position to move the cursor one tab stop forward.
	 */Terminal.prototype.nextStop=function(x){if(x==null)x=this.x;while(!this.tabs[++x]&&x<this.cols){}return x>=this.cols?this.cols-1:x<0?0:x;};/**
	 * Erase in the identified line everything from "x" to the end of the line (right).
	 * @param {number} x The column from which to start erasing to the end of the line.
	 * @param {number} y The line in which to operate.
	 */Terminal.prototype.eraseRight=function(x,y){var line=this.lines[this.ybase+y],ch=[this.eraseAttr(),' ',1];// xterm
	for(;x<this.cols;x++){line[x]=ch;}this.updateRange(y);};/**
	 * Erase in the identified line everything from "x" to the start of the line (left).
	 * @param {number} x The column from which to start erasing to the start of the line.
	 * @param {number} y The line in which to operate.
	 */Terminal.prototype.eraseLeft=function(x,y){var line=this.lines[this.ybase+y],ch=[this.eraseAttr(),' ',1];// xterm
	x++;while(x--){line[x]=ch;}this.updateRange(y);};/**
	 * Clears the entire buffer, making the prompt line the new first line.
	 */Terminal.prototype.clear=function(){if(this.ybase===0&&this.y===0){// Don't clear if it's already clear
	return;}this.lines=[this.lines[this.ybase+this.y]];this.ydisp=0;this.ybase=0;this.y=0;for(var i=1;i<this.rows;i++){this.lines.push(this.blankLine());}this.refresh(0,this.rows-1);this.emit('scroll',this.ydisp);};/**
	 * Erase all content in the given line
	 * @param {number} y The line to erase all of its contents.
	 */Terminal.prototype.eraseLine=function(y){this.eraseRight(0,y);};/**
	 * Return the data array of a blank line/
	 * @param {number} cur First bunch of data for each "blank" character.
	 */Terminal.prototype.blankLine=function(cur){var attr=cur?this.eraseAttr():this.defAttr;var ch=[attr,' ',1]// width defaults to 1 halfwidth character
	,line=[],i=0;for(;i<this.cols;i++){line[i]=ch;}return line;};/**
	 * If cur return the back color xterm feature attribute. Else return defAttr.
	 * @param {object} cur
	 */Terminal.prototype.ch=function(cur){return cur?[this.eraseAttr(),' ',1]:[this.defAttr,' ',1];};/**
	 * Evaluate if the current erminal is the given argument.
	 * @param {object} term The terminal to evaluate
	 */Terminal.prototype.is=function(term){var name=this.termName;return(name+'').indexOf(term)===0;};/**
	     * Emit the 'data' event and populate the given data.
	     * @param {string} data The data to populate in the event.
	     */Terminal.prototype.handler=function(data){this.emit('data',data);};/**
	 * Emit the 'title' event and populate the given title.
	 * @param {string} title The title to populate in the event.
	 */Terminal.prototype.handleTitle=function(title){this.emit('title',title);};/**
	 * ESC
	 *//**
	 * ESC D Index (IND is 0x84).
	 */Terminal.prototype.index=function(){this.y++;if(this.y>this.scrollBottom){this.y--;this.scroll();}this.state=normal;};/**
	 * ESC M Reverse Index (RI is 0x8d).
	 */Terminal.prototype.reverseIndex=function(){var j;this.y--;if(this.y<this.scrollTop){this.y++;// possibly move the code below to term.reverseScroll();
	// test: echo -ne '\e[1;1H\e[44m\eM\e[0m'
	// blankLine(true) is xterm/linux behavior
	this.lines.splice(this.y+this.ybase,0,this.blankLine(true));j=this.rows-1-this.scrollBottom;this.lines.splice(this.rows-1+this.ybase-j+1,1);// this.maxRange();
	this.updateRange(this.scrollTop);this.updateRange(this.scrollBottom);}this.state=normal;};/**
	 * ESC c Full Reset (RIS).
	 */Terminal.prototype.reset=function(){this.options.rows=this.rows;this.options.cols=this.cols;var customKeydownHandler=this.customKeydownHandler;Terminal.call(this,this.options);this.customKeydownHandler=customKeydownHandler;this.refresh(0,this.rows-1);this.viewport.syncScrollArea();};/**
	 * ESC H Tab Set (HTS is 0x88).
	 */Terminal.prototype.tabSet=function(){this.tabs[this.x]=true;this.state=normal;};/**
	 * CSI
	 *//**
	 * CSI Ps A
	 * Cursor Up Ps Times (default = 1) (CUU).
	 */Terminal.prototype.cursorUp=function(params){var param=params[0];if(param<1)param=1;this.y-=param;if(this.y<0)this.y=0;};/**
	 * CSI Ps B
	 * Cursor Down Ps Times (default = 1) (CUD).
	 */Terminal.prototype.cursorDown=function(params){var param=params[0];if(param<1)param=1;this.y+=param;if(this.y>=this.rows){this.y=this.rows-1;}};/**
	 * CSI Ps C
	 * Cursor Forward Ps Times (default = 1) (CUF).
	 */Terminal.prototype.cursorForward=function(params){var param=params[0];if(param<1)param=1;this.x+=param;if(this.x>=this.cols){this.x=this.cols-1;}};/**
	 * CSI Ps D
	 * Cursor Backward Ps Times (default = 1) (CUB).
	 */Terminal.prototype.cursorBackward=function(params){var param=params[0];if(param<1)param=1;this.x-=param;if(this.x<0)this.x=0;};/**
	 * CSI Ps ; Ps H
	 * Cursor Position [row;column] (default = [1,1]) (CUP).
	 */Terminal.prototype.cursorPos=function(params){var row,col;row=params[0]-1;if(params.length>=2){col=params[1]-1;}else{col=0;}if(row<0){row=0;}else if(row>=this.rows){row=this.rows-1;}if(col<0){col=0;}else if(col>=this.cols){col=this.cols-1;}this.x=col;this.y=row;};/**
	 * CSI Ps J  Erase in Display (ED).
	 *     Ps = 0  -> Erase Below (default).
	 *     Ps = 1  -> Erase Above.
	 *     Ps = 2  -> Erase All.
	 *     Ps = 3  -> Erase Saved Lines (xterm).
	 * CSI ? Ps J
	 *   Erase in Display (DECSED).
	 *     Ps = 0  -> Selective Erase Below (default).
	 *     Ps = 1  -> Selective Erase Above.
	 *     Ps = 2  -> Selective Erase All.
	 */Terminal.prototype.eraseInDisplay=function(params){var j;switch(params[0]){case 0:this.eraseRight(this.x,this.y);j=this.y+1;for(;j<this.rows;j++){this.eraseLine(j);}break;case 1:this.eraseLeft(this.x,this.y);j=this.y;while(j--){this.eraseLine(j);}break;case 2:j=this.rows;while(j--){this.eraseLine(j);}break;case 3:;// no saved lines
	break;}};/**
	 * CSI Ps K  Erase in Line (EL).
	 *     Ps = 0  -> Erase to Right (default).
	 *     Ps = 1  -> Erase to Left.
	 *     Ps = 2  -> Erase All.
	 * CSI ? Ps K
	 *   Erase in Line (DECSEL).
	 *     Ps = 0  -> Selective Erase to Right (default).
	 *     Ps = 1  -> Selective Erase to Left.
	 *     Ps = 2  -> Selective Erase All.
	 */Terminal.prototype.eraseInLine=function(params){switch(params[0]){case 0:this.eraseRight(this.x,this.y);break;case 1:this.eraseLeft(this.x,this.y);break;case 2:this.eraseLine(this.y);break;}};/**
	 * CSI Pm m  Character Attributes (SGR).
	 *     Ps = 0  -> Normal (default).
	 *     Ps = 1  -> Bold.
	 *     Ps = 4  -> Underlined.
	 *     Ps = 5  -> Blink (appears as Bold).
	 *     Ps = 7  -> Inverse.
	 *     Ps = 8  -> Invisible, i.e., hidden (VT300).
	 *     Ps = 2 2  -> Normal (neither bold nor faint).
	 *     Ps = 2 4  -> Not underlined.
	 *     Ps = 2 5  -> Steady (not blinking).
	 *     Ps = 2 7  -> Positive (not inverse).
	 *     Ps = 2 8  -> Visible, i.e., not hidden (VT300).
	 *     Ps = 3 0  -> Set foreground color to Black.
	 *     Ps = 3 1  -> Set foreground color to Red.
	 *     Ps = 3 2  -> Set foreground color to Green.
	 *     Ps = 3 3  -> Set foreground color to Yellow.
	 *     Ps = 3 4  -> Set foreground color to Blue.
	 *     Ps = 3 5  -> Set foreground color to Magenta.
	 *     Ps = 3 6  -> Set foreground color to Cyan.
	 *     Ps = 3 7  -> Set foreground color to White.
	 *     Ps = 3 9  -> Set foreground color to default (original).
	 *     Ps = 4 0  -> Set background color to Black.
	 *     Ps = 4 1  -> Set background color to Red.
	 *     Ps = 4 2  -> Set background color to Green.
	 *     Ps = 4 3  -> Set background color to Yellow.
	 *     Ps = 4 4  -> Set background color to Blue.
	 *     Ps = 4 5  -> Set background color to Magenta.
	 *     Ps = 4 6  -> Set background color to Cyan.
	 *     Ps = 4 7  -> Set background color to White.
	 *     Ps = 4 9  -> Set background color to default (original).
	 *
	 *   If 16-color support is compiled, the following apply.  Assume
	 *   that xterm's resources are set so that the ISO color codes are
	 *   the first 8 of a set of 16.  Then the aixterm colors are the
	 *   bright versions of the ISO colors:
	 *     Ps = 9 0  -> Set foreground color to Black.
	 *     Ps = 9 1  -> Set foreground color to Red.
	 *     Ps = 9 2  -> Set foreground color to Green.
	 *     Ps = 9 3  -> Set foreground color to Yellow.
	 *     Ps = 9 4  -> Set foreground color to Blue.
	 *     Ps = 9 5  -> Set foreground color to Magenta.
	 *     Ps = 9 6  -> Set foreground color to Cyan.
	 *     Ps = 9 7  -> Set foreground color to White.
	 *     Ps = 1 0 0  -> Set background color to Black.
	 *     Ps = 1 0 1  -> Set background color to Red.
	 *     Ps = 1 0 2  -> Set background color to Green.
	 *     Ps = 1 0 3  -> Set background color to Yellow.
	 *     Ps = 1 0 4  -> Set background color to Blue.
	 *     Ps = 1 0 5  -> Set background color to Magenta.
	 *     Ps = 1 0 6  -> Set background color to Cyan.
	 *     Ps = 1 0 7  -> Set background color to White.
	 *
	 *   If xterm is compiled with the 16-color support disabled, it
	 *   supports the following, from rxvt:
	 *     Ps = 1 0 0  -> Set foreground and background color to
	 *     default.
	 *
	 *   If 88- or 256-color support is compiled, the following apply.
	 *     Ps = 3 8  ; 5  ; Ps -> Set foreground color to the second
	 *     Ps.
	 *     Ps = 4 8  ; 5  ; Ps -> Set background color to the second
	 *     Ps.
	 */Terminal.prototype.charAttributes=function(params){// Optimize a single SGR0.
	if(params.length===1&&params[0]===0){this.curAttr=this.defAttr;return;}var l=params.length,i=0,flags=this.curAttr>>18,fg=this.curAttr>>9&0x1ff,bg=this.curAttr&0x1ff,p;for(;i<l;i++){p=params[i];if(p>=30&&p<=37){// fg color 8
	fg=p-30;}else if(p>=40&&p<=47){// bg color 8
	bg=p-40;}else if(p>=90&&p<=97){// fg color 16
	p+=8;fg=p-90;}else if(p>=100&&p<=107){// bg color 16
	p+=8;bg=p-100;}else if(p===0){// default
	flags=this.defAttr>>18;fg=this.defAttr>>9&0x1ff;bg=this.defAttr&0x1ff;// flags = 0;
	// fg = 0x1ff;
	// bg = 0x1ff;
	}else if(p===1){// bold text
	flags|=1;}else if(p===4){// underlined text
	flags|=2;}else if(p===5){// blink
	flags|=4;}else if(p===7){// inverse and positive
	// test with: echo -e '\e[31m\e[42mhello\e[7mworld\e[27mhi\e[m'
	flags|=8;}else if(p===8){// invisible
	flags|=16;}else if(p===22){// not bold
	flags&=~1;}else if(p===24){// not underlined
	flags&=~2;}else if(p===25){// not blink
	flags&=~4;}else if(p===27){// not inverse
	flags&=~8;}else if(p===28){// not invisible
	flags&=~16;}else if(p===39){// reset fg
	fg=this.defAttr>>9&0x1ff;}else if(p===49){// reset bg
	bg=this.defAttr&0x1ff;}else if(p===38){// fg color 256
	if(params[i+1]===2){i+=2;fg=matchColor(params[i]&0xff,params[i+1]&0xff,params[i+2]&0xff);if(fg===-1)fg=0x1ff;i+=2;}else if(params[i+1]===5){i+=2;p=params[i]&0xff;fg=p;}}else if(p===48){// bg color 256
	if(params[i+1]===2){i+=2;bg=matchColor(params[i]&0xff,params[i+1]&0xff,params[i+2]&0xff);if(bg===-1)bg=0x1ff;i+=2;}else if(params[i+1]===5){i+=2;p=params[i]&0xff;bg=p;}}else if(p===100){// reset fg/bg
	fg=this.defAttr>>9&0x1ff;bg=this.defAttr&0x1ff;}else{this.error('Unknown SGR attribute: %d.',p);}}this.curAttr=flags<<18|fg<<9|bg;};/**
	 * CSI Ps n  Device Status Report (DSR).
	 *     Ps = 5  -> Status Report.  Result (``OK'') is
	 *   CSI 0 n
	 *     Ps = 6  -> Report Cursor Position (CPR) [row;column].
	 *   Result is
	 *   CSI r ; c R
	 * CSI ? Ps n
	 *   Device Status Report (DSR, DEC-specific).
	 *     Ps = 6  -> Report Cursor Position (CPR) [row;column] as CSI
	 *     ? r ; c R (assumes page is zero).
	 *     Ps = 1 5  -> Report Printer status as CSI ? 1 0  n  (ready).
	 *     or CSI ? 1 1  n  (not ready).
	 *     Ps = 2 5  -> Report UDK status as CSI ? 2 0  n  (unlocked)
	 *     or CSI ? 2 1  n  (locked).
	 *     Ps = 2 6  -> Report Keyboard status as
	 *   CSI ? 2 7  ;  1  ;  0  ;  0  n  (North American).
	 *   The last two parameters apply to VT400 & up, and denote key-
	 *   board ready and LK01 respectively.
	 *     Ps = 5 3  -> Report Locator status as
	 *   CSI ? 5 3  n  Locator available, if compiled-in, or
	 *   CSI ? 5 0  n  No Locator, if not.
	 */Terminal.prototype.deviceStatus=function(params){if(!this.prefix){switch(params[0]){case 5:// status report
	this.send('\x1b[0n');break;case 6:// cursor position
	this.send('\x1b['+(this.y+1)+';'+(this.x+1)+'R');break;}}else if(this.prefix==='?'){// modern xterm doesnt seem to
	// respond to any of these except ?6, 6, and 5
	switch(params[0]){case 6:// cursor position
	this.send('\x1b[?'+(this.y+1)+';'+(this.x+1)+'R');break;case 15:// no printer
	// this.send('\x1b[?11n');
	break;case 25:// dont support user defined keys
	// this.send('\x1b[?21n');
	break;case 26:// north american keyboard
	// this.send('\x1b[?27;1;0;0n');
	break;case 53:// no dec locator/mouse
	// this.send('\x1b[?50n');
	break;}}};/**
	 * Additions
	 *//**
	 * CSI Ps @
	 * Insert Ps (Blank) Character(s) (default = 1) (ICH).
	 */Terminal.prototype.insertChars=function(params){var param,row,j,ch;param=params[0];if(param<1)param=1;row=this.y+this.ybase;j=this.x;ch=[this.eraseAttr(),' ',1];// xterm
	while(param--&&j<this.cols){this.lines[row].splice(j++,0,ch);this.lines[row].pop();}};/**
	 * CSI Ps E
	 * Cursor Next Line Ps Times (default = 1) (CNL).
	 * same as CSI Ps B ?
	 */Terminal.prototype.cursorNextLine=function(params){var param=params[0];if(param<1)param=1;this.y+=param;if(this.y>=this.rows){this.y=this.rows-1;}this.x=0;};/**
	 * CSI Ps F
	 * Cursor Preceding Line Ps Times (default = 1) (CNL).
	 * reuse CSI Ps A ?
	 */Terminal.prototype.cursorPrecedingLine=function(params){var param=params[0];if(param<1)param=1;this.y-=param;if(this.y<0)this.y=0;this.x=0;};/**
	 * CSI Ps G
	 * Cursor Character Absolute  [column] (default = [row,1]) (CHA).
	 */Terminal.prototype.cursorCharAbsolute=function(params){var param=params[0];if(param<1)param=1;this.x=param-1;};/**
	 * CSI Ps L
	 * Insert Ps Line(s) (default = 1) (IL).
	 */Terminal.prototype.insertLines=function(params){var param,row,j;param=params[0];if(param<1)param=1;row=this.y+this.ybase;j=this.rows-1-this.scrollBottom;j=this.rows-1+this.ybase-j+1;while(param--){// test: echo -e '\e[44m\e[1L\e[0m'
	// blankLine(true) - xterm/linux behavior
	this.lines.splice(row,0,this.blankLine(true));this.lines.splice(j,1);}// this.maxRange();
	this.updateRange(this.y);this.updateRange(this.scrollBottom);};/**
	 * CSI Ps M
	 * Delete Ps Line(s) (default = 1) (DL).
	 */Terminal.prototype.deleteLines=function(params){var param,row,j;param=params[0];if(param<1)param=1;row=this.y+this.ybase;j=this.rows-1-this.scrollBottom;j=this.rows-1+this.ybase-j;while(param--){// test: echo -e '\e[44m\e[1M\e[0m'
	// blankLine(true) - xterm/linux behavior
	this.lines.splice(j+1,0,this.blankLine(true));this.lines.splice(row,1);}// this.maxRange();
	this.updateRange(this.y);this.updateRange(this.scrollBottom);};/**
	 * CSI Ps P
	 * Delete Ps Character(s) (default = 1) (DCH).
	 */Terminal.prototype.deleteChars=function(params){var param,row,ch;param=params[0];if(param<1)param=1;row=this.y+this.ybase;ch=[this.eraseAttr(),' ',1];// xterm
	while(param--){this.lines[row].splice(this.x,1);this.lines[row].push(ch);}};/**
	 * CSI Ps X
	 * Erase Ps Character(s) (default = 1) (ECH).
	 */Terminal.prototype.eraseChars=function(params){var param,row,j,ch;param=params[0];if(param<1)param=1;row=this.y+this.ybase;j=this.x;ch=[this.eraseAttr(),' ',1];// xterm
	while(param--&&j<this.cols){this.lines[row][j++]=ch;}};/**
	 * CSI Pm `  Character Position Absolute
	 *   [column] (default = [row,1]) (HPA).
	 */Terminal.prototype.charPosAbsolute=function(params){var param=params[0];if(param<1)param=1;this.x=param-1;if(this.x>=this.cols){this.x=this.cols-1;}};/**
	 * 141 61 a * HPR -
	 * Horizontal Position Relative
	 * reuse CSI Ps C ?
	 */Terminal.prototype.HPositionRelative=function(params){var param=params[0];if(param<1)param=1;this.x+=param;if(this.x>=this.cols){this.x=this.cols-1;}};/**
	 * CSI Ps c  Send Device Attributes (Primary DA).
	 *     Ps = 0  or omitted -> request attributes from terminal.  The
	 *     response depends on the decTerminalID resource setting.
	 *     -> CSI ? 1 ; 2 c  (``VT100 with Advanced Video Option'')
	 *     -> CSI ? 1 ; 0 c  (``VT101 with No Options'')
	 *     -> CSI ? 6 c  (``VT102'')
	 *     -> CSI ? 6 0 ; 1 ; 2 ; 6 ; 8 ; 9 ; 1 5 ; c  (``VT220'')
	 *   The VT100-style response parameters do not mean anything by
	 *   themselves.  VT220 parameters do, telling the host what fea-
	 *   tures the terminal supports:
	 *     Ps = 1  -> 132-columns.
	 *     Ps = 2  -> Printer.
	 *     Ps = 6  -> Selective erase.
	 *     Ps = 8  -> User-defined keys.
	 *     Ps = 9  -> National replacement character sets.
	 *     Ps = 1 5  -> Technical characters.
	 *     Ps = 2 2  -> ANSI color, e.g., VT525.
	 *     Ps = 2 9  -> ANSI text locator (i.e., DEC Locator mode).
	 * CSI > Ps c
	 *   Send Device Attributes (Secondary DA).
	 *     Ps = 0  or omitted -> request the terminal's identification
	 *     code.  The response depends on the decTerminalID resource set-
	 *     ting.  It should apply only to VT220 and up, but xterm extends
	 *     this to VT100.
	 *     -> CSI  > Pp ; Pv ; Pc c
	 *   where Pp denotes the terminal type
	 *     Pp = 0  -> ``VT100''.
	 *     Pp = 1  -> ``VT220''.
	 *   and Pv is the firmware version (for xterm, this was originally
	 *   the XFree86 patch number, starting with 95).  In a DEC termi-
	 *   nal, Pc indicates the ROM cartridge registration number and is
	 *   always zero.
	 * More information:
	 *   xterm/charproc.c - line 2012, for more information.
	 *   vim responds with ^[[?0c or ^[[?1c after the terminal's response (?)
	 */Terminal.prototype.sendDeviceAttributes=function(params){if(params[0]>0)return;if(!this.prefix){if(this.is('xterm')||this.is('rxvt-unicode')||this.is('screen')){this.send('\x1b[?1;2c');}else if(this.is('linux')){this.send('\x1b[?6c');}}else if(this.prefix==='>'){// xterm and urxvt
	// seem to spit this
	// out around ~370 times (?).
	if(this.is('xterm')){this.send('\x1b[>0;276;0c');}else if(this.is('rxvt-unicode')){this.send('\x1b[>85;95;0c');}else if(this.is('linux')){// not supported by linux console.
	// linux console echoes parameters.
	this.send(params[0]+'c');}else if(this.is('screen')){this.send('\x1b[>83;40003;0c');}}};/**
	 * CSI Pm d
	 * Line Position Absolute  [row] (default = [1,column]) (VPA).
	 */Terminal.prototype.linePosAbsolute=function(params){var param=params[0];if(param<1)param=1;this.y=param-1;if(this.y>=this.rows){this.y=this.rows-1;}};/**
	 * 145 65 e * VPR - Vertical Position Relative
	 * reuse CSI Ps B ?
	 */Terminal.prototype.VPositionRelative=function(params){var param=params[0];if(param<1)param=1;this.y+=param;if(this.y>=this.rows){this.y=this.rows-1;}};/**
	 * CSI Ps ; Ps f
	 *   Horizontal and Vertical Position [row;column] (default =
	 *   [1,1]) (HVP).
	 */Terminal.prototype.HVPosition=function(params){if(params[0]<1)params[0]=1;if(params[1]<1)params[1]=1;this.y=params[0]-1;if(this.y>=this.rows){this.y=this.rows-1;}this.x=params[1]-1;if(this.x>=this.cols){this.x=this.cols-1;}};/**
	 * CSI Pm h  Set Mode (SM).
	 *     Ps = 2  -> Keyboard Action Mode (AM).
	 *     Ps = 4  -> Insert Mode (IRM).
	 *     Ps = 1 2  -> Send/receive (SRM).
	 *     Ps = 2 0  -> Automatic Newline (LNM).
	 * CSI ? Pm h
	 *   DEC Private Mode Set (DECSET).
	 *     Ps = 1  -> Application Cursor Keys (DECCKM).
	 *     Ps = 2  -> Designate USASCII for character sets G0-G3
	 *     (DECANM), and set VT100 mode.
	 *     Ps = 3  -> 132 Column Mode (DECCOLM).
	 *     Ps = 4  -> Smooth (Slow) Scroll (DECSCLM).
	 *     Ps = 5  -> Reverse Video (DECSCNM).
	 *     Ps = 6  -> Origin Mode (DECOM).
	 *     Ps = 7  -> Wraparound Mode (DECAWM).
	 *     Ps = 8  -> Auto-repeat Keys (DECARM).
	 *     Ps = 9  -> Send Mouse X & Y on button press.  See the sec-
	 *     tion Mouse Tracking.
	 *     Ps = 1 0  -> Show toolbar (rxvt).
	 *     Ps = 1 2  -> Start Blinking Cursor (att610).
	 *     Ps = 1 8  -> Print form feed (DECPFF).
	 *     Ps = 1 9  -> Set print extent to full screen (DECPEX).
	 *     Ps = 2 5  -> Show Cursor (DECTCEM).
	 *     Ps = 3 0  -> Show scrollbar (rxvt).
	 *     Ps = 3 5  -> Enable font-shifting functions (rxvt).
	 *     Ps = 3 8  -> Enter Tektronix Mode (DECTEK).
	 *     Ps = 4 0  -> Allow 80 -> 132 Mode.
	 *     Ps = 4 1  -> more(1) fix (see curses resource).
	 *     Ps = 4 2  -> Enable Nation Replacement Character sets (DECN-
	 *     RCM).
	 *     Ps = 4 4  -> Turn On Margin Bell.
	 *     Ps = 4 5  -> Reverse-wraparound Mode.
	 *     Ps = 4 6  -> Start Logging.  This is normally disabled by a
	 *     compile-time option.
	 *     Ps = 4 7  -> Use Alternate Screen Buffer.  (This may be dis-
	 *     abled by the titeInhibit resource).
	 *     Ps = 6 6  -> Application keypad (DECNKM).
	 *     Ps = 6 7  -> Backarrow key sends backspace (DECBKM).
	 *     Ps = 1 0 0 0  -> Send Mouse X & Y on button press and
	 *     release.  See the section Mouse Tracking.
	 *     Ps = 1 0 0 1  -> Use Hilite Mouse Tracking.
	 *     Ps = 1 0 0 2  -> Use Cell Motion Mouse Tracking.
	 *     Ps = 1 0 0 3  -> Use All Motion Mouse Tracking.
	 *     Ps = 1 0 0 4  -> Send FocusIn/FocusOut events.
	 *     Ps = 1 0 0 5  -> Enable Extended Mouse Mode.
	 *     Ps = 1 0 1 0  -> Scroll to bottom on tty output (rxvt).
	 *     Ps = 1 0 1 1  -> Scroll to bottom on key press (rxvt).
	 *     Ps = 1 0 3 4  -> Interpret "meta" key, sets eighth bit.
	 *     (enables the eightBitInput resource).
	 *     Ps = 1 0 3 5  -> Enable special modifiers for Alt and Num-
	 *     Lock keys.  (This enables the numLock resource).
	 *     Ps = 1 0 3 6  -> Send ESC   when Meta modifies a key.  (This
	 *     enables the metaSendsEscape resource).
	 *     Ps = 1 0 3 7  -> Send DEL from the editing-keypad Delete
	 *     key.
	 *     Ps = 1 0 3 9  -> Send ESC  when Alt modifies a key.  (This
	 *     enables the altSendsEscape resource).
	 *     Ps = 1 0 4 0  -> Keep selection even if not highlighted.
	 *     (This enables the keepSelection resource).
	 *     Ps = 1 0 4 1  -> Use the CLIPBOARD selection.  (This enables
	 *     the selectToClipboard resource).
	 *     Ps = 1 0 4 2  -> Enable Urgency window manager hint when
	 *     Control-G is received.  (This enables the bellIsUrgent
	 *     resource).
	 *     Ps = 1 0 4 3  -> Enable raising of the window when Control-G
	 *     is received.  (enables the popOnBell resource).
	 *     Ps = 1 0 4 7  -> Use Alternate Screen Buffer.  (This may be
	 *     disabled by the titeInhibit resource).
	 *     Ps = 1 0 4 8  -> Save cursor as in DECSC.  (This may be dis-
	 *     abled by the titeInhibit resource).
	 *     Ps = 1 0 4 9  -> Save cursor as in DECSC and use Alternate
	 *     Screen Buffer, clearing it first.  (This may be disabled by
	 *     the titeInhibit resource).  This combines the effects of the 1
	 *     0 4 7  and 1 0 4 8  modes.  Use this with terminfo-based
	 *     applications rather than the 4 7  mode.
	 *     Ps = 1 0 5 0  -> Set terminfo/termcap function-key mode.
	 *     Ps = 1 0 5 1  -> Set Sun function-key mode.
	 *     Ps = 1 0 5 2  -> Set HP function-key mode.
	 *     Ps = 1 0 5 3  -> Set SCO function-key mode.
	 *     Ps = 1 0 6 0  -> Set legacy keyboard emulation (X11R6).
	 *     Ps = 1 0 6 1  -> Set VT220 keyboard emulation.
	 *     Ps = 2 0 0 4  -> Set bracketed paste mode.
	 * Modes:
	 *   http: *vt100.net/docs/vt220-rm/chapter4.html
	 */Terminal.prototype.setMode=function(params){if((typeof params==='undefined'?'undefined':_typeof(params))==='object'){var l=params.length,i=0;for(;i<l;i++){this.setMode(params[i]);}return;}if(!this.prefix){switch(params){case 4:this.insertMode=true;break;case 20://this.convertEol = true;
	break;}}else if(this.prefix==='?'){switch(params){case 1:this.applicationCursor=true;break;case 2:this.setgCharset(0,Terminal.charsets.US);this.setgCharset(1,Terminal.charsets.US);this.setgCharset(2,Terminal.charsets.US);this.setgCharset(3,Terminal.charsets.US);// set VT100 mode here
	break;case 3:// 132 col mode
	this.savedCols=this.cols;this.resize(132,this.rows);break;case 6:this.originMode=true;break;case 7:this.wraparoundMode=true;break;case 12:// this.cursorBlink = true;
	break;case 66:this.log('Serial port requested application keypad.');this.applicationKeypad=true;this.viewport.syncScrollArea();break;case 9:// X10 Mouse
	// no release, no motion, no wheel, no modifiers.
	case 1000:// vt200 mouse
	// no motion.
	// no modifiers, except control on the wheel.
	case 1002:// button event mouse
	case 1003:// any event mouse
	// any event - sends motion events,
	// even if there is no button held down.
	this.x10Mouse=params===9;this.vt200Mouse=params===1000;this.normalMouse=params>1000;this.mouseEvents=true;this.element.style.cursor='default';this.log('Binding to mouse events.');break;case 1004:// send focusin/focusout events
	// focusin: ^[[I
	// focusout: ^[[O
	this.sendFocus=true;break;case 1005:// utf8 ext mode mouse
	this.utfMouse=true;// for wide terminals
	// simply encodes large values as utf8 characters
	break;case 1006:// sgr ext mode mouse
	this.sgrMouse=true;// for wide terminals
	// does not add 32 to fields
	// press: ^[[<b;x;yM
	// release: ^[[<b;x;ym
	break;case 1015:// urxvt ext mode mouse
	this.urxvtMouse=true;// for wide terminals
	// numbers for fields
	// press: ^[[b;x;yM
	// motion: ^[[b;x;yT
	break;case 25:// show cursor
	this.cursorHidden=false;break;case 1049:// alt screen buffer cursor
	//this.saveCursor();
	;// FALL-THROUGH
	case 47:// alt screen buffer
	case 1047:// alt screen buffer
	if(!this.normal){var normal={lines:this.lines,ybase:this.ybase,ydisp:this.ydisp,x:this.x,y:this.y,scrollTop:this.scrollTop,scrollBottom:this.scrollBottom,tabs:this.tabs// XXX save charset(s) here?
	// charset: this.charset,
	// glevel: this.glevel,
	// charsets: this.charsets
	};this.reset();this.normal=normal;this.showCursor();}break;}}};/**
	 * CSI Pm l  Reset Mode (RM).
	 *     Ps = 2  -> Keyboard Action Mode (AM).
	 *     Ps = 4  -> Replace Mode (IRM).
	 *     Ps = 1 2  -> Send/receive (SRM).
	 *     Ps = 2 0  -> Normal Linefeed (LNM).
	 * CSI ? Pm l
	 *   DEC Private Mode Reset (DECRST).
	 *     Ps = 1  -> Normal Cursor Keys (DECCKM).
	 *     Ps = 2  -> Designate VT52 mode (DECANM).
	 *     Ps = 3  -> 80 Column Mode (DECCOLM).
	 *     Ps = 4  -> Jump (Fast) Scroll (DECSCLM).
	 *     Ps = 5  -> Normal Video (DECSCNM).
	 *     Ps = 6  -> Normal Cursor Mode (DECOM).
	 *     Ps = 7  -> No Wraparound Mode (DECAWM).
	 *     Ps = 8  -> No Auto-repeat Keys (DECARM).
	 *     Ps = 9  -> Don't send Mouse X & Y on button press.
	 *     Ps = 1 0  -> Hide toolbar (rxvt).
	 *     Ps = 1 2  -> Stop Blinking Cursor (att610).
	 *     Ps = 1 8  -> Don't print form feed (DECPFF).
	 *     Ps = 1 9  -> Limit print to scrolling region (DECPEX).
	 *     Ps = 2 5  -> Hide Cursor (DECTCEM).
	 *     Ps = 3 0  -> Don't show scrollbar (rxvt).
	 *     Ps = 3 5  -> Disable font-shifting functions (rxvt).
	 *     Ps = 4 0  -> Disallow 80 -> 132 Mode.
	 *     Ps = 4 1  -> No more(1) fix (see curses resource).
	 *     Ps = 4 2  -> Disable Nation Replacement Character sets (DEC-
	 *     NRCM).
	 *     Ps = 4 4  -> Turn Off Margin Bell.
	 *     Ps = 4 5  -> No Reverse-wraparound Mode.
	 *     Ps = 4 6  -> Stop Logging.  (This is normally disabled by a
	 *     compile-time option).
	 *     Ps = 4 7  -> Use Normal Screen Buffer.
	 *     Ps = 6 6  -> Numeric keypad (DECNKM).
	 *     Ps = 6 7  -> Backarrow key sends delete (DECBKM).
	 *     Ps = 1 0 0 0  -> Don't send Mouse X & Y on button press and
	 *     release.  See the section Mouse Tracking.
	 *     Ps = 1 0 0 1  -> Don't use Hilite Mouse Tracking.
	 *     Ps = 1 0 0 2  -> Don't use Cell Motion Mouse Tracking.
	 *     Ps = 1 0 0 3  -> Don't use All Motion Mouse Tracking.
	 *     Ps = 1 0 0 4  -> Don't send FocusIn/FocusOut events.
	 *     Ps = 1 0 0 5  -> Disable Extended Mouse Mode.
	 *     Ps = 1 0 1 0  -> Don't scroll to bottom on tty output
	 *     (rxvt).
	 *     Ps = 1 0 1 1  -> Don't scroll to bottom on key press (rxvt).
	 *     Ps = 1 0 3 4  -> Don't interpret "meta" key.  (This disables
	 *     the eightBitInput resource).
	 *     Ps = 1 0 3 5  -> Disable special modifiers for Alt and Num-
	 *     Lock keys.  (This disables the numLock resource).
	 *     Ps = 1 0 3 6  -> Don't send ESC  when Meta modifies a key.
	 *     (This disables the metaSendsEscape resource).
	 *     Ps = 1 0 3 7  -> Send VT220 Remove from the editing-keypad
	 *     Delete key.
	 *     Ps = 1 0 3 9  -> Don't send ESC  when Alt modifies a key.
	 *     (This disables the altSendsEscape resource).
	 *     Ps = 1 0 4 0  -> Do not keep selection when not highlighted.
	 *     (This disables the keepSelection resource).
	 *     Ps = 1 0 4 1  -> Use the PRIMARY selection.  (This disables
	 *     the selectToClipboard resource).
	 *     Ps = 1 0 4 2  -> Disable Urgency window manager hint when
	 *     Control-G is received.  (This disables the bellIsUrgent
	 *     resource).
	 *     Ps = 1 0 4 3  -> Disable raising of the window when Control-
	 *     G is received.  (This disables the popOnBell resource).
	 *     Ps = 1 0 4 7  -> Use Normal Screen Buffer, clearing screen
	 *     first if in the Alternate Screen.  (This may be disabled by
	 *     the titeInhibit resource).
	 *     Ps = 1 0 4 8  -> Restore cursor as in DECRC.  (This may be
	 *     disabled by the titeInhibit resource).
	 *     Ps = 1 0 4 9  -> Use Normal Screen Buffer and restore cursor
	 *     as in DECRC.  (This may be disabled by the titeInhibit
	 *     resource).  This combines the effects of the 1 0 4 7  and 1 0
	 *     4 8  modes.  Use this with terminfo-based applications rather
	 *     than the 4 7  mode.
	 *     Ps = 1 0 5 0  -> Reset terminfo/termcap function-key mode.
	 *     Ps = 1 0 5 1  -> Reset Sun function-key mode.
	 *     Ps = 1 0 5 2  -> Reset HP function-key mode.
	 *     Ps = 1 0 5 3  -> Reset SCO function-key mode.
	 *     Ps = 1 0 6 0  -> Reset legacy keyboard emulation (X11R6).
	 *     Ps = 1 0 6 1  -> Reset keyboard emulation to Sun/PC style.
	 *     Ps = 2 0 0 4  -> Reset bracketed paste mode.
	 */Terminal.prototype.resetMode=function(params){if((typeof params==='undefined'?'undefined':_typeof(params))==='object'){var l=params.length,i=0;for(;i<l;i++){this.resetMode(params[i]);}return;}if(!this.prefix){switch(params){case 4:this.insertMode=false;break;case 20://this.convertEol = false;
	break;}}else if(this.prefix==='?'){switch(params){case 1:this.applicationCursor=false;break;case 3:if(this.cols===132&&this.savedCols){this.resize(this.savedCols,this.rows);}delete this.savedCols;break;case 6:this.originMode=false;break;case 7:this.wraparoundMode=false;break;case 12:// this.cursorBlink = false;
	break;case 66:this.log('Switching back to normal keypad.');this.applicationKeypad=false;this.viewport.syncScrollArea();break;case 9:// X10 Mouse
	case 1000:// vt200 mouse
	case 1002:// button event mouse
	case 1003:// any event mouse
	this.x10Mouse=false;this.vt200Mouse=false;this.normalMouse=false;this.mouseEvents=false;this.element.style.cursor='';break;case 1004:// send focusin/focusout events
	this.sendFocus=false;break;case 1005:// utf8 ext mode mouse
	this.utfMouse=false;break;case 1006:// sgr ext mode mouse
	this.sgrMouse=false;break;case 1015:// urxvt ext mode mouse
	this.urxvtMouse=false;break;case 25:// hide cursor
	this.cursorHidden=true;break;case 1049:// alt screen buffer cursor
	;// FALL-THROUGH
	case 47:// normal screen buffer
	case 1047:// normal screen buffer - clearing it first
	if(this.normal){this.lines=this.normal.lines;this.ybase=this.normal.ybase;this.ydisp=this.normal.ydisp;this.x=this.normal.x;this.y=this.normal.y;this.scrollTop=this.normal.scrollTop;this.scrollBottom=this.normal.scrollBottom;this.tabs=this.normal.tabs;this.normal=null;// if (params === 1049) {
	//   this.x = this.savedX;
	//   this.y = this.savedY;
	// }
	this.refresh(0,this.rows-1);this.showCursor();}break;}}};/**
	 * CSI Ps ; Ps r
	 *   Set Scrolling Region [top;bottom] (default = full size of win-
	 *   dow) (DECSTBM).
	 * CSI ? Pm r
	 */Terminal.prototype.setScrollRegion=function(params){if(this.prefix)return;this.scrollTop=(params[0]||1)-1;this.scrollBottom=(params[1]||this.rows)-1;this.x=0;this.y=0;};/**
	 * CSI s
	 *   Save cursor (ANSI.SYS).
	 */Terminal.prototype.saveCursor=function(params){this.savedX=this.x;this.savedY=this.y;};/**
	 * CSI u
	 *   Restore cursor (ANSI.SYS).
	 */Terminal.prototype.restoreCursor=function(params){this.x=this.savedX||0;this.y=this.savedY||0;};/**
	 * Lesser Used
	 *//**
	 * CSI Ps I
	 *   Cursor Forward Tabulation Ps tab stops (default = 1) (CHT).
	 */Terminal.prototype.cursorForwardTab=function(params){var param=params[0]||1;while(param--){this.x=this.nextStop();}};/**
	 * CSI Ps S  Scroll up Ps lines (default = 1) (SU).
	 */Terminal.prototype.scrollUp=function(params){var param=params[0]||1;while(param--){this.lines.splice(this.ybase+this.scrollTop,1);this.lines.splice(this.ybase+this.scrollBottom,0,this.blankLine());}// this.maxRange();
	this.updateRange(this.scrollTop);this.updateRange(this.scrollBottom);};/**
	     * CSI Ps T  Scroll down Ps lines (default = 1) (SD).
	     */Terminal.prototype.scrollDown=function(params){var param=params[0]||1;while(param--){this.lines.splice(this.ybase+this.scrollBottom,1);this.lines.splice(this.ybase+this.scrollTop,0,this.blankLine());}// this.maxRange();
	this.updateRange(this.scrollTop);this.updateRange(this.scrollBottom);};/**
	 * CSI Ps ; Ps ; Ps ; Ps ; Ps T
	 *   Initiate highlight mouse tracking.  Parameters are
	 *   [func;startx;starty;firstrow;lastrow].  See the section Mouse
	 *   Tracking.
	 */Terminal.prototype.initMouseTracking=function(params){// Relevant: DECSET 1001
	};/**
	 * CSI > Ps; Ps T
	 *   Reset one or more features of the title modes to the default
	 *   value.  Normally, "reset" disables the feature.  It is possi-
	 *   ble to disable the ability to reset features by compiling a
	 *   different default for the title modes into xterm.
	 *     Ps = 0  -> Do not set window/icon labels using hexadecimal.
	 *     Ps = 1  -> Do not query window/icon labels using hexadeci-
	 *     mal.
	 *     Ps = 2  -> Do not set window/icon labels using UTF-8.
	 *     Ps = 3  -> Do not query window/icon labels using UTF-8.
	 *   (See discussion of "Title Modes").
	 */Terminal.prototype.resetTitleModes=function(params){;};/**
	 * CSI Ps Z  Cursor Backward Tabulation Ps tab stops (default = 1) (CBT).
	 */Terminal.prototype.cursorBackwardTab=function(params){var param=params[0]||1;while(param--){this.x=this.prevStop();}};/**
	 * CSI Ps b  Repeat the preceding graphic character Ps times (REP).
	 */Terminal.prototype.repeatPrecedingCharacter=function(params){var param=params[0]||1,line=this.lines[this.ybase+this.y],ch=line[this.x-1]||[this.defAttr,' ',1];while(param--){line[this.x++]=ch;}};/**
	 * CSI Ps g  Tab Clear (TBC).
	 *     Ps = 0  -> Clear Current Column (default).
	 *     Ps = 3  -> Clear All.
	 * Potentially:
	 *   Ps = 2  -> Clear Stops on Line.
	 *   http://vt100.net/annarbor/aaa-ug/section6.html
	 */Terminal.prototype.tabClear=function(params){var param=params[0];if(param<=0){delete this.tabs[this.x];}else if(param===3){this.tabs={};}};/**
	 * CSI Pm i  Media Copy (MC).
	 *     Ps = 0  -> Print screen (default).
	 *     Ps = 4  -> Turn off printer controller mode.
	 *     Ps = 5  -> Turn on printer controller mode.
	 * CSI ? Pm i
	 *   Media Copy (MC, DEC-specific).
	 *     Ps = 1  -> Print line containing cursor.
	 *     Ps = 4  -> Turn off autoprint mode.
	 *     Ps = 5  -> Turn on autoprint mode.
	 *     Ps = 1  0  -> Print composed display, ignores DECPEX.
	 *     Ps = 1  1  -> Print all pages.
	 */Terminal.prototype.mediaCopy=function(params){;};/**
	 * CSI > Ps; Ps m
	 *   Set or reset resource-values used by xterm to decide whether
	 *   to construct escape sequences holding information about the
	 *   modifiers pressed with a given key.  The first parameter iden-
	 *   tifies the resource to set/reset.  The second parameter is the
	 *   value to assign to the resource.  If the second parameter is
	 *   omitted, the resource is reset to its initial value.
	 *     Ps = 1  -> modifyCursorKeys.
	 *     Ps = 2  -> modifyFunctionKeys.
	 *     Ps = 4  -> modifyOtherKeys.
	 *   If no parameters are given, all resources are reset to their
	 *   initial values.
	 */Terminal.prototype.setResources=function(params){;};/**
	 * CSI > Ps n
	 *   Disable modifiers which may be enabled via the CSI > Ps; Ps m
	 *   sequence.  This corresponds to a resource value of "-1", which
	 *   cannot be set with the other sequence.  The parameter identi-
	 *   fies the resource to be disabled:
	 *     Ps = 1  -> modifyCursorKeys.
	 *     Ps = 2  -> modifyFunctionKeys.
	 *     Ps = 4  -> modifyOtherKeys.
	 *   If the parameter is omitted, modifyFunctionKeys is disabled.
	 *   When modifyFunctionKeys is disabled, xterm uses the modifier
	 *   keys to make an extended sequence of functions rather than
	 *   adding a parameter to each function key to denote the modi-
	 *   fiers.
	 */Terminal.prototype.disableModifiers=function(params){;};/**
	 * CSI > Ps p
	 *   Set resource value pointerMode.  This is used by xterm to
	 *   decide whether to hide the pointer cursor as the user types.
	 *   Valid values for the parameter:
	 *     Ps = 0  -> never hide the pointer.
	 *     Ps = 1  -> hide if the mouse tracking mode is not enabled.
	 *     Ps = 2  -> always hide the pointer.  If no parameter is
	 *     given, xterm uses the default, which is 1 .
	 */Terminal.prototype.setPointerMode=function(params){;};/**
	 * CSI ! p   Soft terminal reset (DECSTR).
	 * http://vt100.net/docs/vt220-rm/table4-10.html
	 */Terminal.prototype.softReset=function(params){this.cursorHidden=false;this.insertMode=false;this.originMode=false;this.wraparoundMode=false;// autowrap
	this.applicationKeypad=false;// ?
	this.viewport.syncScrollArea();this.applicationCursor=false;this.scrollTop=0;this.scrollBottom=this.rows-1;this.curAttr=this.defAttr;this.x=this.y=0;// ?
	this.charset=null;this.glevel=0;// ??
	this.charsets=[null];// ??
	};/**
	 * CSI Ps$ p
	 *   Request ANSI mode (DECRQM).  For VT300 and up, reply is
	 *     CSI Ps; Pm$ y
	 *   where Ps is the mode number as in RM, and Pm is the mode
	 *   value:
	 *     0 - not recognized
	 *     1 - set
	 *     2 - reset
	 *     3 - permanently set
	 *     4 - permanently reset
	 */Terminal.prototype.requestAnsiMode=function(params){;};/**
	 * CSI ? Ps$ p
	 *   Request DEC private mode (DECRQM).  For VT300 and up, reply is
	 *     CSI ? Ps; Pm$ p
	 *   where Ps is the mode number as in DECSET, Pm is the mode value
	 *   as in the ANSI DECRQM.
	 */Terminal.prototype.requestPrivateMode=function(params){;};/**
	 * CSI Ps ; Ps " p
	 *   Set conformance level (DECSCL).  Valid values for the first
	 *   parameter:
	 *     Ps = 6 1  -> VT100.
	 *     Ps = 6 2  -> VT200.
	 *     Ps = 6 3  -> VT300.
	 *   Valid values for the second parameter:
	 *     Ps = 0  -> 8-bit controls.
	 *     Ps = 1  -> 7-bit controls (always set for VT100).
	 *     Ps = 2  -> 8-bit controls.
	 */Terminal.prototype.setConformanceLevel=function(params){;};/**
	 * CSI Ps q  Load LEDs (DECLL).
	 *     Ps = 0  -> Clear all LEDS (default).
	 *     Ps = 1  -> Light Num Lock.
	 *     Ps = 2  -> Light Caps Lock.
	 *     Ps = 3  -> Light Scroll Lock.
	 *     Ps = 2  1  -> Extinguish Num Lock.
	 *     Ps = 2  2  -> Extinguish Caps Lock.
	 *     Ps = 2  3  -> Extinguish Scroll Lock.
	 */Terminal.prototype.loadLEDs=function(params){;};/**
	 * CSI Ps SP q
	 *   Set cursor style (DECSCUSR, VT520).
	 *     Ps = 0  -> blinking block.
	 *     Ps = 1  -> blinking block (default).
	 *     Ps = 2  -> steady block.
	 *     Ps = 3  -> blinking underline.
	 *     Ps = 4  -> steady underline.
	 */Terminal.prototype.setCursorStyle=function(params){;};/**
	 * CSI Ps " q
	 *   Select character protection attribute (DECSCA).  Valid values
	 *   for the parameter:
	 *     Ps = 0  -> DECSED and DECSEL can erase (default).
	 *     Ps = 1  -> DECSED and DECSEL cannot erase.
	 *     Ps = 2  -> DECSED and DECSEL can erase.
	 */Terminal.prototype.setCharProtectionAttr=function(params){;};/**
	 * CSI ? Pm r
	 *   Restore DEC Private Mode Values.  The value of Ps previously
	 *   saved is restored.  Ps values are the same as for DECSET.
	 */Terminal.prototype.restorePrivateValues=function(params){;};/**
	 * CSI Pt; Pl; Pb; Pr; Ps$ r
	 *   Change Attributes in Rectangular Area (DECCARA), VT400 and up.
	 *     Pt; Pl; Pb; Pr denotes the rectangle.
	 *     Ps denotes the SGR attributes to change: 0, 1, 4, 5, 7.
	 * NOTE: xterm doesn't enable this code by default.
	 */Terminal.prototype.setAttrInRectangle=function(params){var t=params[0],l=params[1],b=params[2],r=params[3],attr=params[4];var line,i;for(;t<b+1;t++){line=this.lines[this.ybase+t];for(i=l;i<r;i++){line[i]=[attr,line[i][1]];}}// this.maxRange();
	this.updateRange(params[0]);this.updateRange(params[2]);};/**
	 * CSI Pc; Pt; Pl; Pb; Pr$ x
	 *   Fill Rectangular Area (DECFRA), VT420 and up.
	 *     Pc is the character to use.
	 *     Pt; Pl; Pb; Pr denotes the rectangle.
	 * NOTE: xterm doesn't enable this code by default.
	 */Terminal.prototype.fillRectangle=function(params){var ch=params[0],t=params[1],l=params[2],b=params[3],r=params[4];var line,i;for(;t<b+1;t++){line=this.lines[this.ybase+t];for(i=l;i<r;i++){line[i]=[line[i][0],String.fromCharCode(ch)];}}// this.maxRange();
	this.updateRange(params[1]);this.updateRange(params[3]);};/**
	 * CSI Ps ; Pu ' z
	 *   Enable Locator Reporting (DECELR).
	 *   Valid values for the first parameter:
	 *     Ps = 0  -> Locator disabled (default).
	 *     Ps = 1  -> Locator enabled.
	 *     Ps = 2  -> Locator enabled for one report, then disabled.
	 *   The second parameter specifies the coordinate unit for locator
	 *   reports.
	 *   Valid values for the second parameter:
	 *     Pu = 0  <- or omitted -> default to character cells.
	 *     Pu = 1  <- device physical pixels.
	 *     Pu = 2  <- character cells.
	 */Terminal.prototype.enableLocatorReporting=function(params){var val=params[0]>0;//this.mouseEvents = val;
	//this.decLocator = val;
	};/**
	 * CSI Pt; Pl; Pb; Pr$ z
	 *   Erase Rectangular Area (DECERA), VT400 and up.
	 *     Pt; Pl; Pb; Pr denotes the rectangle.
	 * NOTE: xterm doesn't enable this code by default.
	 */Terminal.prototype.eraseRectangle=function(params){var t=params[0],l=params[1],b=params[2],r=params[3];var line,i,ch;ch=[this.eraseAttr(),' ',1];// xterm?
	for(;t<b+1;t++){line=this.lines[this.ybase+t];for(i=l;i<r;i++){line[i]=ch;}}// this.maxRange();
	this.updateRange(params[0]);this.updateRange(params[2]);};/**
	 * CSI P m SP }
	 * Insert P s Column(s) (default = 1) (DECIC), VT420 and up.
	 * NOTE: xterm doesn't enable this code by default.
	 */Terminal.prototype.insertColumns=function(){var param=params[0],l=this.ybase+this.rows,ch=[this.eraseAttr(),' ',1]// xterm?
	,i;while(param--){for(i=this.ybase;i<l;i++){this.lines[i].splice(this.x+1,0,ch);this.lines[i].pop();}}this.maxRange();};/**
	 * CSI P m SP ~
	 * Delete P s Column(s) (default = 1) (DECDC), VT420 and up
	 * NOTE: xterm doesn't enable this code by default.
	 */Terminal.prototype.deleteColumns=function(){var param=params[0],l=this.ybase+this.rows,ch=[this.eraseAttr(),' ',1]// xterm?
	,i;while(param--){for(i=this.ybase;i<l;i++){this.lines[i].splice(this.x,1);this.lines[i].push(ch);}}this.maxRange();};/**
	 * Character Sets
	 */Terminal.charsets={};// DEC Special Character and Line Drawing Set.
	// http://vt100.net/docs/vt102-ug/table5-13.html
	// A lot of curses apps use this if they see TERM=xterm.
	// testing: echo -e '\e(0a\e(B'
	// The xterm output sometimes seems to conflict with the
	// reference above. xterm seems in line with the reference
	// when running vttest however.
	// The table below now uses xterm's output from vttest.
	Terminal.charsets.SCLD={// (0
	'`':'\u25C6',// ''
	'a':'\u2592',// ''
	'b':'\t',// '\t'
	'c':'\f',// '\f'
	'd':'\r',// '\r'
	'e':'\n',// '\n'
	'f':'\xB0',// ''
	'g':'\xB1',// ''
	'h':'\u2424',// '\u2424' (NL)
	'i':'\x0B',// '\v'
	'j':'\u2518',// ''
	'k':'\u2510',// ''
	'l':'\u250C',// ''
	'm':'\u2514',// ''
	'n':'\u253C',// ''
	'o':'\u23BA',// ''
	'p':'\u23BB',// ''
	'q':'\u2500',// ''
	'r':'\u23BC',// ''
	's':'\u23BD',// ''
	't':'\u251C',// ''
	'u':'\u2524',// ''
	'v':'\u2534',// ''
	'w':'\u252C',// ''
	'x':'\u2502',// ''
	'y':'\u2264',// ''
	'z':'\u2265',// ''
	'{':'\u03C0',// ''
	'|':'\u2260',// ''
	'}':'\xA3',// ''
	'~':'\xB7'// ''
	};Terminal.charsets.UK=null;// (A
	Terminal.charsets.US=null;// (B (USASCII)
	Terminal.charsets.Dutch=null;// (4
	Terminal.charsets.Finnish=null;// (C or (5
	Terminal.charsets.French=null;// (R
	Terminal.charsets.FrenchCanadian=null;// (Q
	Terminal.charsets.German=null;// (K
	Terminal.charsets.Italian=null;// (Y
	Terminal.charsets.NorwegianDanish=null;// (E or (6
	Terminal.charsets.Spanish=null;// (Z
	Terminal.charsets.Swedish=null;// (H or (7
	Terminal.charsets.Swiss=null;// (=
	Terminal.charsets.ISOLatin=null;// /A
	/**
	 * Helpers
	 */function contains(el,arr){for(var i=0;i<arr.length;i+=1){if(el===arr[i]){return true;}}return false;}function on(el,type,handler,capture){if(!Array.isArray(el)){el=[el];}el.forEach(function(element){element.addEventListener(type,handler,capture||false);});}function off(el,type,handler,capture){el.removeEventListener(type,handler,capture||false);}function cancel(ev,force){if(!this.cancelEvents&&!force){return;}ev.preventDefault();ev.stopPropagation();return false;}function inherits(child,parent){function f(){this.constructor=child;}f.prototype=parent.prototype;child.prototype=new f();}// if bold is broken, we can't
	// use it in the terminal.
	function isBoldBroken(document){var body=document.getElementsByTagName('body')[0];var el=document.createElement('span');el.innerHTML='hello world';body.appendChild(el);var w1=el.scrollWidth;el.style.fontWeight='bold';var w2=el.scrollWidth;body.removeChild(el);return w1!==w2;}function indexOf(obj,el){var i=obj.length;while(i--){if(obj[i]===el)return i;}return-1;}function isThirdLevelShift(term,ev){var thirdLevelKey=term.isMac&&ev.altKey&&!ev.ctrlKey&&!ev.metaKey||term.isMSWindows&&ev.altKey&&ev.ctrlKey&&!ev.metaKey;if(ev.type=='keypress'){return thirdLevelKey;}// Don't invoke for arrows, pageDown, home, backspace, etc. (on non-keypress events)
	return thirdLevelKey&&(!ev.keyCode||ev.keyCode>47);}function matchColor(r1,g1,b1){var hash=r1<<16|g1<<8|b1;if(matchColor._cache[hash]!=null){return matchColor._cache[hash];}var ldiff=Infinity,li=-1,i=0,c,r2,g2,b2,diff;for(;i<Terminal.vcolors.length;i++){c=Terminal.vcolors[i];r2=c[0];g2=c[1];b2=c[2];diff=matchColor.distance(r1,g1,b1,r2,g2,b2);if(diff===0){li=i;break;}if(diff<ldiff){ldiff=diff;li=i;}}return matchColor._cache[hash]=li;}matchColor._cache={};// http://stackoverflow.com/questions/1633828
	matchColor.distance=function(r1,g1,b1,r2,g2,b2){return Math.pow(30*(r1-r2),2)+Math.pow(59*(g1-g2),2)+Math.pow(11*(b1-b2),2);};function each(obj,iter,con){if(obj.forEach)return obj.forEach(iter,con);for(var i=0;i<obj.length;i++){iter.call(con,obj[i],i,obj);}}function keys(obj){if(Object.keys)return Object.keys(obj);var key,keys=[];for(key in obj){if(Object.prototype.hasOwnProperty.call(obj,key)){keys.push(key);}}return keys;}var wcwidth=function(opts){// extracted from https://www.cl.cam.ac.uk/%7Emgk25/ucs/wcwidth.c
	// combining characters
	var COMBINING=[[0x0300,0x036F],[0x0483,0x0486],[0x0488,0x0489],[0x0591,0x05BD],[0x05BF,0x05BF],[0x05C1,0x05C2],[0x05C4,0x05C5],[0x05C7,0x05C7],[0x0600,0x0603],[0x0610,0x0615],[0x064B,0x065E],[0x0670,0x0670],[0x06D6,0x06E4],[0x06E7,0x06E8],[0x06EA,0x06ED],[0x070F,0x070F],[0x0711,0x0711],[0x0730,0x074A],[0x07A6,0x07B0],[0x07EB,0x07F3],[0x0901,0x0902],[0x093C,0x093C],[0x0941,0x0948],[0x094D,0x094D],[0x0951,0x0954],[0x0962,0x0963],[0x0981,0x0981],[0x09BC,0x09BC],[0x09C1,0x09C4],[0x09CD,0x09CD],[0x09E2,0x09E3],[0x0A01,0x0A02],[0x0A3C,0x0A3C],[0x0A41,0x0A42],[0x0A47,0x0A48],[0x0A4B,0x0A4D],[0x0A70,0x0A71],[0x0A81,0x0A82],[0x0ABC,0x0ABC],[0x0AC1,0x0AC5],[0x0AC7,0x0AC8],[0x0ACD,0x0ACD],[0x0AE2,0x0AE3],[0x0B01,0x0B01],[0x0B3C,0x0B3C],[0x0B3F,0x0B3F],[0x0B41,0x0B43],[0x0B4D,0x0B4D],[0x0B56,0x0B56],[0x0B82,0x0B82],[0x0BC0,0x0BC0],[0x0BCD,0x0BCD],[0x0C3E,0x0C40],[0x0C46,0x0C48],[0x0C4A,0x0C4D],[0x0C55,0x0C56],[0x0CBC,0x0CBC],[0x0CBF,0x0CBF],[0x0CC6,0x0CC6],[0x0CCC,0x0CCD],[0x0CE2,0x0CE3],[0x0D41,0x0D43],[0x0D4D,0x0D4D],[0x0DCA,0x0DCA],[0x0DD2,0x0DD4],[0x0DD6,0x0DD6],[0x0E31,0x0E31],[0x0E34,0x0E3A],[0x0E47,0x0E4E],[0x0EB1,0x0EB1],[0x0EB4,0x0EB9],[0x0EBB,0x0EBC],[0x0EC8,0x0ECD],[0x0F18,0x0F19],[0x0F35,0x0F35],[0x0F37,0x0F37],[0x0F39,0x0F39],[0x0F71,0x0F7E],[0x0F80,0x0F84],[0x0F86,0x0F87],[0x0F90,0x0F97],[0x0F99,0x0FBC],[0x0FC6,0x0FC6],[0x102D,0x1030],[0x1032,0x1032],[0x1036,0x1037],[0x1039,0x1039],[0x1058,0x1059],[0x1160,0x11FF],[0x135F,0x135F],[0x1712,0x1714],[0x1732,0x1734],[0x1752,0x1753],[0x1772,0x1773],[0x17B4,0x17B5],[0x17B7,0x17BD],[0x17C6,0x17C6],[0x17C9,0x17D3],[0x17DD,0x17DD],[0x180B,0x180D],[0x18A9,0x18A9],[0x1920,0x1922],[0x1927,0x1928],[0x1932,0x1932],[0x1939,0x193B],[0x1A17,0x1A18],[0x1B00,0x1B03],[0x1B34,0x1B34],[0x1B36,0x1B3A],[0x1B3C,0x1B3C],[0x1B42,0x1B42],[0x1B6B,0x1B73],[0x1DC0,0x1DCA],[0x1DFE,0x1DFF],[0x200B,0x200F],[0x202A,0x202E],[0x2060,0x2063],[0x206A,0x206F],[0x20D0,0x20EF],[0x302A,0x302F],[0x3099,0x309A],[0xA806,0xA806],[0xA80B,0xA80B],[0xA825,0xA826],[0xFB1E,0xFB1E],[0xFE00,0xFE0F],[0xFE20,0xFE23],[0xFEFF,0xFEFF],[0xFFF9,0xFFFB],[0x10A01,0x10A03],[0x10A05,0x10A06],[0x10A0C,0x10A0F],[0x10A38,0x10A3A],[0x10A3F,0x10A3F],[0x1D167,0x1D169],[0x1D173,0x1D182],[0x1D185,0x1D18B],[0x1D1AA,0x1D1AD],[0x1D242,0x1D244],[0xE0001,0xE0001],[0xE0020,0xE007F],[0xE0100,0xE01EF]];// binary search
	function bisearch(ucs){var min=0;var max=COMBINING.length-1;var mid;if(ucs<COMBINING[0][0]||ucs>COMBINING[max][1])return false;while(max>=min){mid=Math.floor((min+max)/2);if(ucs>COMBINING[mid][1])min=mid+1;else if(ucs<COMBINING[mid][0])max=mid-1;else return true;}return false;}function wcwidth(ucs){// test for 8-bit control characters
	if(ucs===0)return opts.nul;if(ucs<32||ucs>=0x7f&&ucs<0xa0)return opts.control;// binary search in table of non-spacing characters
	if(bisearch(ucs))return 0;// if we arrive here, ucs is not a combining or C0/C1 control character
	return 1+(ucs>=0x1100&&(ucs<=0x115f||// Hangul Jamo init. consonants
	ucs==0x2329||ucs==0x232a||ucs>=0x2e80&&ucs<=0xa4cf&&ucs!=0x303f||// CJK..Yi
	ucs>=0xac00&&ucs<=0xd7a3||// Hangul Syllables
	ucs>=0xf900&&ucs<=0xfaff||// CJK Compat Ideographs
	ucs>=0xfe10&&ucs<=0xfe19||// Vertical forms
	ucs>=0xfe30&&ucs<=0xfe6f||// CJK Compat Forms
	ucs>=0xff00&&ucs<=0xff60||// Fullwidth Forms
	ucs>=0xffe0&&ucs<=0xffe6||ucs>=0x20000&&ucs<=0x2fffd||ucs>=0x30000&&ucs<=0x3fffd));}return wcwidth;}({nul:0,control:0});// configurable options
	/**
	 * Expose
	 */Terminal.EventEmitter=_EventEmitter.EventEmitter;Terminal.CompositionHelper=_CompositionHelper.CompositionHelper;Terminal.Viewport=_Viewport.Viewport;Terminal.inherits=inherits;/**
	 * Adds an event listener to the terminal.
	 *
	 * @param {string} event The name of the event. TODO: Document all event types
	 * @param {function} callback The function to call when the event is triggered.
	 */Terminal.on=on;Terminal.off=off;Terminal.cancel=cancel;module.exports=Terminal;
	
	}).call(this,"/src")
	
	},{"./CompositionHelper.js":1,"./EventEmitter.js":2,"./Viewport.js":3,"./handlers/Clipboard.js":4}]},{},[5])(5)
	});
	//# sourceMappingURL=xterm.js.map


/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgNTBiY2U5MWQxZTM3ZjViN2E3ZjUiLCJ3ZWJwYWNrOi8vLy4vc3JjL3B1YmxpYy90ZXJtaW5hbC5qcyIsIndlYnBhY2s6Ly8vLi9+L3h0ZXJtL2Rpc3QveHRlcm0uanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUN0Q0E7Ozs7Ozs7YUNBQSx5QkFBYSxTQUEyRCxtQkFBbUIsZ0RBQWdELGFBQWEsS0FBSyxNQUFNLGdDQUFnQyxTQUFTLHFDQUFxQyxTQUFTLG1DQUFtQyxPQUFPLEtBQUssT0FBTyxrQkFBa0IsYUFBYSwwQkFBMEIsMEJBQTBCLGdCQUFnQixVQUFVLFVBQVUsMENBQTBDLDhCQUF3QixvQkFBb0IsOENBQThDLGtDQUFrQyxZQUFZLFlBQVksbUNBQW1DLGlCQUFpQixnQkFBZ0Isc0JBQXNCLG9CQUFvQiwwQ0FBMEMsWUFBWSxXQUFXLFlBQVksU0FBUyxHQUFHO0FBQzV5Qjs7QUFFQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxvQkFBb0I7QUFDL0IsWUFBVyxZQUFZO0FBQ3ZCLFlBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsK0JBQThCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVcsaUJBQWlCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFDLEdBQUc7QUFDSjs7QUFFQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtB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QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFvRixnQkFBZ0IsRUFBRSxnQkFBZ0IsRUFBRTtBQUN4SDtBQUNBO0FBQ0EscURBQW9ELGdFQUFnRSxxQ0FBcUMsMkJBQTJCO0FBQ3BMO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxTQUFTO0FBQ3BCLG1CQUFrQixpQkFBaUIsdUJBQXVCOztBQUUxRCxFQUFDOztBQUVELEVBQUMsRUFBRSwrRkFBK0YsRUFBRSxHQUFHO0FBQ3ZHLEVBQUM7QUFDRCIsImZpbGUiOiJ0ZXJtaW5hbC5taW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0ZXhwb3J0czoge30sXG4gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuIFx0XHRcdGxvYWRlZDogZmFsc2VcbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIHdlYnBhY2svYm9vdHN0cmFwIDUwYmNlOTFkMWUzN2Y1YjdhN2Y1XG4gKiovIiwid2luZG93LlRlcm1pbmFsID0gcmVxdWlyZSgneHRlcm0nKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvcHVibGljL3Rlcm1pbmFsLmpzXG4gKiogbW9kdWxlIGlkID0gMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKGYpe2lmKHR5cGVvZiBleHBvcnRzPT09XCJvYmplY3RcIiYmdHlwZW9mIG1vZHVsZSE9PVwidW5kZWZpbmVkXCIpe21vZHVsZS5leHBvcnRzPWYoKX1lbHNlIGlmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpe2RlZmluZShbXSxmKX1lbHNle3ZhciBnO2lmKHR5cGVvZiB3aW5kb3chPT1cInVuZGVmaW5lZFwiKXtnPXdpbmRvd31lbHNlIGlmKHR5cGVvZiBnbG9iYWwhPT1cInVuZGVmaW5lZFwiKXtnPWdsb2JhbH1lbHNlIGlmKHR5cGVvZiBzZWxmIT09XCJ1bmRlZmluZWRcIil7Zz1zZWxmfWVsc2V7Zz10aGlzfWcuVGVybWluYWwgPSBmKCl9fSkoZnVuY3Rpb24oKXt2YXIgZGVmaW5lLG1vZHVsZSxleHBvcnRzO3JldHVybiAoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSh7MTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG4vKipcbiAqIHh0ZXJtLmpzOiB4dGVybSwgaW4gdGhlIGJyb3dzZXJcbiAqIENvcHlyaWdodCAoYykgMjAxNC0yMDE2LCBTb3VyY2VMYWlyIFByaXZhdGUgQ29tcGFueSAod3d3LnNvdXJjZWxhaXIuY29tIChNSVQgTGljZW5zZSlcbiAqL1xuXG4vKipcbiAqIEVuY2Fwc3VsYXRlcyB0aGUgbG9naWMgZm9yIGhhbmRsaW5nIGNvbXBvc2l0aW9uc3RhcnQsIGNvbXBvc2l0aW9udXBkYXRlIGFuZCBjb21wb3NpdGlvbmVuZFxuICogZXZlbnRzLCBkaXNwbGF5aW5nIHRoZSBpbi1wcm9ncmVzcyBjb21wb3NpdGlvbiB0byB0aGUgVUkgYW5kIGZvcndhcmRpbmcgdGhlIGZpbmFsIGNvbXBvc2l0aW9uXG4gKiB0byB0aGUgaGFuZGxlci5cbiAqIEBwYXJhbSB7SFRNTFRleHRBcmVhRWxlbWVudH0gdGV4dGFyZWEgVGhlIHRleHRhcmVhIHRoYXQgeHRlcm0gdXNlcyBmb3IgaW5wdXQuXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb21wb3NpdGlvblZpZXcgVGhlIGVsZW1lbnQgdG8gZGlzcGxheSB0aGUgaW4tcHJvZ3Jlc3MgY29tcG9zaXRpb24gaW4uXG4gKiBAcGFyYW0ge1Rlcm1pbmFsfSB0ZXJtaW5hbCBUaGUgVGVybWluYWwgdG8gZm9yd2FyZCB0aGUgZmluaXNoZWQgY29tcG9zaXRpb24gdG8uXG4gKi9cbmZ1bmN0aW9uIENvbXBvc2l0aW9uSGVscGVyKHRleHRhcmVhLCBjb21wb3NpdGlvblZpZXcsIHRlcm1pbmFsKSB7XG4gIHRoaXMudGV4dGFyZWEgPSB0ZXh0YXJlYTtcbiAgdGhpcy5jb21wb3NpdGlvblZpZXcgPSBjb21wb3NpdGlvblZpZXc7XG4gIHRoaXMudGVybWluYWwgPSB0ZXJtaW5hbDtcblxuICAvLyBXaGV0aGVyIGlucHV0IGNvbXBvc2l0aW9uIGlzIGN1cnJlbnRseSBoYXBwZW5pbmcsIGVnLiB2aWEgYSBtb2JpbGUga2V5Ym9hcmQsIHNwZWVjaCBpbnB1dFxuICAvLyBvciBJTUUuIFRoaXMgdmFyaWFibGUgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBjb21wb3NpdGlvblRleHQgc2hvdWxkIGJlIGRpc3BsYXllZCBvbiB0aGUgVUkuXG4gIHRoaXMuaXNDb21wb3NpbmcgPSBmYWxzZTtcblxuICAvLyBUaGUgaW5wdXQgY3VycmVudGx5IGJlaW5nIGNvbXBvc2VkLCBlZy4gdmlhIGEgbW9iaWxlIGtleWJvYXJkLCBzcGVlY2ggaW5wdXQgb3IgSU1FLlxuICB0aGlzLmNvbXBvc2l0aW9uVGV4dCA9IG51bGw7XG5cbiAgLy8gVGhlIHBvc2l0aW9uIHdpdGhpbiB0aGUgaW5wdXQgdGV4dGFyZWEncyB2YWx1ZSBvZiB0aGUgY3VycmVudCBjb21wb3NpdGlvbi5cbiAgdGhpcy5jb21wb3NpdGlvblBvc2l0aW9uID0geyBzdGFydDogbnVsbCwgZW5kOiBudWxsIH07XG5cbiAgLy8gV2hldGhlciBhIGNvbXBvc2l0aW9uIGlzIGluIHRoZSBwcm9jZXNzIG9mIGJlaW5nIHNlbnQsIHNldHRpbmcgdGhpcyB0byBmYWxzZSB3aWxsIGNhbmNlbFxuICAvLyBhbnkgaW4tcHJvZ3Jlc3MgY29tcG9zaXRpb24uXG4gIHRoaXMuaXNTZW5kaW5nQ29tcG9zaXRpb24gPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBIYW5kbGVzIHRoZSBjb21wb3NpdGlvbnN0YXJ0IGV2ZW50LCBhY3RpdmF0aW5nIHRoZSBjb21wb3NpdGlvbiB2aWV3LlxuICovXG5Db21wb3NpdGlvbkhlbHBlci5wcm90b3R5cGUuY29tcG9zaXRpb25zdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5pc0NvbXBvc2luZyA9IHRydWU7XG4gIHRoaXMuY29tcG9zaXRpb25Qb3NpdGlvbi5zdGFydCA9IHRoaXMudGV4dGFyZWEudmFsdWUubGVuZ3RoO1xuICB0aGlzLmNvbXBvc2l0aW9uVmlldy50ZXh0Q29udGVudCA9ICcnO1xuICB0aGlzLmNvbXBvc2l0aW9uVmlldy5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcbn07XG5cbi8qKlxuICogSGFuZGxlcyB0aGUgY29tcG9zaXRpb251cGRhdGUgZXZlbnQsIHVwZGF0aW5nIHRoZSBjb21wb3NpdGlvbiB2aWV3LlxuICogQHBhcmFtIHtDb21wb3NpdGlvbkV2ZW50fSBldiBUaGUgZXZlbnQuXG4gKi9cbkNvbXBvc2l0aW9uSGVscGVyLnByb3RvdHlwZS5jb21wb3NpdGlvbnVwZGF0ZSA9IGZ1bmN0aW9uIChldikge1xuICB0aGlzLmNvbXBvc2l0aW9uVmlldy50ZXh0Q29udGVudCA9IGV2LmRhdGE7XG4gIHRoaXMudXBkYXRlQ29tcG9zaXRpb25FbGVtZW50cygpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuY29tcG9zaXRpb25Qb3NpdGlvbi5lbmQgPSBzZWxmLnRleHRhcmVhLnZhbHVlLmxlbmd0aDtcbiAgfSwgMCk7XG59O1xuXG4vKipcbiAqIEhhbmRsZXMgdGhlIGNvbXBvc2l0aW9uZW5kIGV2ZW50LCBoaWRpbmcgdGhlIGNvbXBvc2l0aW9uIHZpZXcgYW5kIHNlbmRpbmcgdGhlIGNvbXBvc2l0aW9uIHRvXG4gKiB0aGUgaGFuZGxlci5cbiAqL1xuQ29tcG9zaXRpb25IZWxwZXIucHJvdG90eXBlLmNvbXBvc2l0aW9uZW5kID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmZpbmFsaXplQ29tcG9zaXRpb24odHJ1ZSk7XG59O1xuXG4vKipcbiAqIEhhbmRsZXMgdGhlIGtleWRvd24gZXZlbnQsIHJvdXRpbmcgYW55IG5lY2Vzc2FyeSBldmVudHMgdG8gdGhlIENvbXBvc2l0aW9uSGVscGVyIGZ1bmN0aW9ucy5cbiAqIEByZXR1cm4gV2hldGhlciB0aGUgVGVybWluYWwgc2hvdWxkIGNvbnRpbnVlIHByb2Nlc3NpbmcgdGhlIGtleWRvd24gZXZlbnQuXG4gKi9cbkNvbXBvc2l0aW9uSGVscGVyLnByb3RvdHlwZS5rZXlkb3duID0gZnVuY3Rpb24gKGV2KSB7XG4gIGlmICh0aGlzLmlzQ29tcG9zaW5nIHx8IHRoaXMuaXNTZW5kaW5nQ29tcG9zaXRpb24pIHtcbiAgICBpZiAoZXYua2V5Q29kZSA9PT0gMjI5KSB7XG4gICAgICAvLyBDb250aW51ZSBjb21wb3NpbmcgaWYgdGhlIGtleUNvZGUgaXMgdGhlIFwiY29tcG9zaXRpb24gY2hhcmFjdGVyXCJcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGV2LmtleUNvZGUgPT09IDE2IHx8IGV2LmtleUNvZGUgPT09IDE3IHx8IGV2LmtleUNvZGUgPT09IDE4KSB7XG4gICAgICAvLyBDb250aW51ZSBjb21wb3NpbmcgaWYgdGhlIGtleUNvZGUgaXMgYSBtb2RpZmllciBrZXlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRmluaXNoIGNvbXBvc2l0aW9uIGltbWVkaWF0ZWx5LiBUaGlzIGlzIG1haW5seSBoZXJlIGZvciB0aGUgY2FzZSB3aGVyZSBlbnRlciBpc1xuICAgICAgLy8gcHJlc3NlZCBhbmQgdGhlIGhhbmRsZXIgbmVlZHMgdG8gYmUgdHJpZ2dlcmVkIGJlZm9yZSB0aGUgY29tbWFuZCBpcyBleGVjdXRlZC5cbiAgICAgIHRoaXMuZmluYWxpemVDb21wb3NpdGlvbihmYWxzZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGV2LmtleUNvZGUgPT09IDIyOSkge1xuICAgIC8vIElmIHRoZSBcImNvbXBvc2l0aW9uIGNoYXJhY3RlclwiIGlzIHVzZWQgYnV0IGdldHMgdG8gdGhpcyBwb2ludCBpdCBtZWFucyBhIG5vbi1jb21wb3NpdGlvblxuICAgIC8vIGNoYXJhY3RlciAoZWcuIG51bWJlcnMgYW5kIHB1bmN0dWF0aW9uKSB3YXMgcHJlc3NlZCB3aGVuIHRoZSBJTUUgd2FzIGFjdGl2ZS5cbiAgICB0aGlzLmhhbmRsZUFueVRleHRhcmVhQ2hhbmdlcygpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBGaW5hbGl6ZXMgdGhlIGNvbXBvc2l0aW9uLCByZXN1bWluZyByZWd1bGFyIGlucHV0IGFjdGlvbnMuIFRoaXMgaXMgY2FsbGVkIHdoZW4gYSBjb21wb3NpdGlvblxuICogaXMgZW5kaW5nLlxuICogQHBhcmFtIHtib29sZWFufSB3YWl0Rm9yUHJvcG9nYXRpb24gV2hldGhlciB0byB3YWl0IGZvciBldmVudHMgdG8gcHJvcG9nYXRlIGJlZm9yZSBzZW5kaW5nXG4gKiAgIHRoZSBpbnB1dC4gVGhpcyBzaG91bGQgYmUgZmFsc2UgaWYgYSBub24tY29tcG9zaXRpb24ga2V5c3Ryb2tlIGlzIGVudGVyZWQgYmVmb3JlIHRoZVxuICogICBjb21wb3NpdGlvbmVuZCBldmVudCBpcyB0cmlnZ2VyZWQsIHN1Y2ggYXMgZW50ZXIsIHNvIHRoYXQgdGhlIGNvbXBvc2l0aW9uIGlzIHNlbmQgYmVmb3JlXG4gKiAgIHRoZSBjb21tYW5kIGlzIGV4ZWN1dGVkLlxuICovXG5Db21wb3NpdGlvbkhlbHBlci5wcm90b3R5cGUuZmluYWxpemVDb21wb3NpdGlvbiA9IGZ1bmN0aW9uICh3YWl0Rm9yUHJvcG9nYXRpb24pIHtcbiAgdGhpcy5jb21wb3NpdGlvblZpZXcuY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XG4gIHRoaXMuaXNDb21wb3NpbmcgPSBmYWxzZTtcbiAgdGhpcy5jbGVhclRleHRhcmVhUG9zaXRpb24oKTtcblxuICBpZiAoIXdhaXRGb3JQcm9wb2dhdGlvbikge1xuICAgIC8vIENhbmNlbCBhbnkgZGVsYXllZCBjb21wb3NpdGlvbiBzZW5kIHJlcXVlc3RzIGFuZCBzZW5kIHRoZSBpbnB1dCBpbW1lZGlhdGVseS5cbiAgICB0aGlzLmlzU2VuZGluZ0NvbXBvc2l0aW9uID0gZmFsc2U7XG4gICAgdmFyIGlucHV0ID0gdGhpcy50ZXh0YXJlYS52YWx1ZS5zdWJzdHJpbmcodGhpcy5jb21wb3NpdGlvblBvc2l0aW9uLnN0YXJ0LCB0aGlzLmNvbXBvc2l0aW9uUG9zaXRpb24uZW5kKTtcbiAgICB0aGlzLnRlcm1pbmFsLmhhbmRsZXIoaW5wdXQpO1xuICB9IGVsc2Uge1xuICAgIC8vIE1ha2UgYSBkZWVwIGNvcHkgb2YgdGhlIGNvbXBvc2l0aW9uIHBvc2l0aW9uIGhlcmUgYXMgYSBuZXcgY29tcG9zaXRpb25zdGFydCBldmVudCBtYXlcbiAgICAvLyBmaXJlIGJlZm9yZSB0aGUgc2V0VGltZW91dCBleGVjdXRlcy5cbiAgICB2YXIgY3VycmVudENvbXBvc2l0aW9uUG9zaXRpb24gPSB7XG4gICAgICBzdGFydDogdGhpcy5jb21wb3NpdGlvblBvc2l0aW9uLnN0YXJ0LFxuICAgICAgZW5kOiB0aGlzLmNvbXBvc2l0aW9uUG9zaXRpb24uZW5kXG4gICAgfTtcblxuICAgIC8vIFNpbmNlIGNvbXBvc2l0aW9uKiBldmVudHMgaGFwcGVuIGJlZm9yZSB0aGUgY2hhbmdlcyB0YWtlIHBsYWNlIGluIHRoZSB0ZXh0YXJlYSBvbiBtb3N0XG4gICAgLy8gYnJvd3NlcnMsIHVzZSBhIHNldFRpbWVvdXQgd2l0aCAwbXMgdGltZSB0byBhbGxvdyB0aGUgbmF0aXZlIGNvbXBvc2l0aW9uZW5kIGV2ZW50IHRvXG4gICAgLy8gY29tcGxldGUuIFRoaXMgZW5zdXJlcyB0aGUgY29ycmVjdCBjaGFyYWN0ZXIgaXMgcmV0cmlldmVkLCB0aGlzIHNvbHV0aW9uIHdhcyB1c2VkXG4gICAgLy8gYmVjYXVzZTpcbiAgICAvLyAtIFRoZSBjb21wb3NpdGlvbmVuZCBldmVudCdzIGRhdGEgcHJvcGVydHkgaXMgdW5yZWxpYWJsZSwgYXQgbGVhc3Qgb24gQ2hyb21pdW1cbiAgICAvLyAtIFRoZSBsYXN0IGNvbXBvc2l0aW9udXBkYXRlIGV2ZW50J3MgZGF0YSBwcm9wZXJ0eSBkb2VzIG5vdCBhbHdheXMgYWNjdXJhdGVseSBkZXNjcmliZVxuICAgIC8vICAgdGhlIGNoYXJhY3RlciwgYSBjb3VudGVyIGV4YW1wbGUgYmVpbmcgS29yZWFuIHdoZXJlIGFuIGVuZGluZyBjb25zb25zYW50IGNhbiBtb3ZlIHRvXG4gICAgLy8gICB0aGUgZm9sbG93aW5nIGNoYXJhY3RlciBpZiB0aGUgZm9sbG93aW5nIGlucHV0IGlzIGEgdm93ZWwuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuaXNTZW5kaW5nQ29tcG9zaXRpb24gPSB0cnVlO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgLy8gRW5zdXJlIHRoYXQgdGhlIGlucHV0IGhhcyBub3QgYWxyZWFkeSBiZWVuIHNlbnRcbiAgICAgIGlmIChzZWxmLmlzU2VuZGluZ0NvbXBvc2l0aW9uKSB7XG4gICAgICAgIHNlbGYuaXNTZW5kaW5nQ29tcG9zaXRpb24gPSBmYWxzZTtcbiAgICAgICAgdmFyIGlucHV0O1xuICAgICAgICBpZiAoc2VsZi5pc0NvbXBvc2luZykge1xuICAgICAgICAgIC8vIFVzZSB0aGUgZW5kIHBvc2l0aW9uIHRvIGdldCB0aGUgc3RyaW5nIGlmIGEgbmV3IGNvbXBvc2l0aW9uIGhhcyBzdGFydGVkLlxuICAgICAgICAgIGlucHV0ID0gc2VsZi50ZXh0YXJlYS52YWx1ZS5zdWJzdHJpbmcoY3VycmVudENvbXBvc2l0aW9uUG9zaXRpb24uc3RhcnQsIGN1cnJlbnRDb21wb3NpdGlvblBvc2l0aW9uLmVuZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gRG9uJ3QgdXNlIHRoZSBlbmQgcG9zaXRpb24gaGVyZSBpbiBvcmRlciB0byBwaWNrIHVwIGFueSBjaGFyYWN0ZXJzIGFmdGVyIHRoZVxuICAgICAgICAgIC8vIGNvbXBvc2l0aW9uIGhhcyBmaW5pc2hlZCwgZm9yIGV4YW1wbGUgd2hlbiB0eXBpbmcgYSBub24tY29tcG9zaXRpb24gY2hhcmFjdGVyXG4gICAgICAgICAgLy8gKGVnLiAyKSBhZnRlciBhIGNvbXBvc2l0aW9uIGNoYXJhY3Rlci5cbiAgICAgICAgICBpbnB1dCA9IHNlbGYudGV4dGFyZWEudmFsdWUuc3Vic3RyaW5nKGN1cnJlbnRDb21wb3NpdGlvblBvc2l0aW9uLnN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLnRlcm1pbmFsLmhhbmRsZXIoaW5wdXQpO1xuICAgICAgfVxuICAgIH0sIDApO1xuICB9XG59O1xuXG4vKipcbiAqIEFwcGx5IGFueSBjaGFuZ2VzIG1hZGUgdG8gdGhlIHRleHRhcmVhIGFmdGVyIHRoZSBjdXJyZW50IGV2ZW50IGNoYWluIGlzIGFsbG93ZWQgdG8gY29tcGxldGUuXG4gKiBUaGlzIHNob3VsZCBiZSBjYWxsZWQgd2hlbiBub3QgY3VycmVudGx5IGNvbXBvc2luZyBidXQgYSBrZXlkb3duIGV2ZW50IHdpdGggdGhlIFwiY29tcG9zaXRpb25cbiAqIGNoYXJhY3RlclwiICgyMjkpIGlzIHRyaWdnZXJlZCwgaW4gb3JkZXIgdG8gYWxsb3cgbm9uLWNvbXBvc2l0aW9uIHRleHQgdG8gYmUgZW50ZXJlZCB3aGVuIGFuXG4gKiBJTUUgaXMgYWN0aXZlLlxuICovXG5Db21wb3NpdGlvbkhlbHBlci5wcm90b3R5cGUuaGFuZGxlQW55VGV4dGFyZWFDaGFuZ2VzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgb2xkVmFsdWUgPSB0aGlzLnRleHRhcmVhLnZhbHVlO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIC8vIElnbm9yZSBpZiBhIGNvbXBvc2l0aW9uIGhhcyBzdGFydGVkIHNpbmNlIHRoZSB0aW1lb3V0XG4gICAgaWYgKCFzZWxmLmlzQ29tcG9zaW5nKSB7XG4gICAgICB2YXIgbmV3VmFsdWUgPSBzZWxmLnRleHRhcmVhLnZhbHVlO1xuICAgICAgdmFyIGRpZmYgPSBuZXdWYWx1ZS5yZXBsYWNlKG9sZFZhbHVlLCAnJyk7XG4gICAgICBpZiAoZGlmZi5sZW5ndGggPiAwKSB7XG4gICAgICAgIHNlbGYudGVybWluYWwuaGFuZGxlcihkaWZmKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIDApO1xufTtcblxuLyoqXG4gKiBQb3NpdGlvbnMgdGhlIGNvbXBvc2l0aW9uIHZpZXcgb24gdG9wIG9mIHRoZSBjdXJzb3IgYW5kIHRoZSB0ZXh0YXJlYSBqdXN0IGJlbG93IGl0IChzbyB0aGVcbiAqIElNRSBoZWxwZXIgZGlhbG9nIGlzIHBvc2l0aW9uZWQgY29ycmVjdGx5KS5cbiAqL1xuQ29tcG9zaXRpb25IZWxwZXIucHJvdG90eXBlLnVwZGF0ZUNvbXBvc2l0aW9uRWxlbWVudHMgPSBmdW5jdGlvbiAoZG9udFJlY3Vyc2UpIHtcbiAgaWYgKCF0aGlzLmlzQ29tcG9zaW5nKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBjdXJzb3IgPSB0aGlzLnRlcm1pbmFsLmVsZW1lbnQucXVlcnlTZWxlY3RvcignLnRlcm1pbmFsLWN1cnNvcicpO1xuICBpZiAoY3Vyc29yKSB7XG4gICAgdGhpcy5jb21wb3NpdGlvblZpZXcuc3R5bGUubGVmdCA9IGN1cnNvci5vZmZzZXRMZWZ0ICsgJ3B4JztcbiAgICB0aGlzLmNvbXBvc2l0aW9uVmlldy5zdHlsZS50b3AgPSBjdXJzb3Iub2Zmc2V0VG9wICsgJ3B4JztcbiAgICB2YXIgY29tcG9zaXRpb25WaWV3Qm91bmRzID0gdGhpcy5jb21wb3NpdGlvblZpZXcuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgdGhpcy50ZXh0YXJlYS5zdHlsZS5sZWZ0ID0gY3Vyc29yLm9mZnNldExlZnQgKyBjb21wb3NpdGlvblZpZXdCb3VuZHMud2lkdGggKyAncHgnO1xuICAgIHRoaXMudGV4dGFyZWEuc3R5bGUudG9wID0gY3Vyc29yLm9mZnNldFRvcCArIGN1cnNvci5vZmZzZXRIZWlnaHQgKyAncHgnO1xuICB9XG4gIGlmICghZG9udFJlY3Vyc2UpIHtcbiAgICBzZXRUaW1lb3V0KHRoaXMudXBkYXRlQ29tcG9zaXRpb25FbGVtZW50cy5iaW5kKHRoaXMsIHRydWUpLCAwKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDbGVhcnMgdGhlIHRleHRhcmVhJ3MgcG9zaXRpb24gc28gdGhhdCB0aGUgY3Vyc29yIGRvZXMgbm90IGJsaW5rIG9uIElFLlxuICogQHByaXZhdGVcbiAqL1xuQ29tcG9zaXRpb25IZWxwZXIucHJvdG90eXBlLmNsZWFyVGV4dGFyZWFQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy50ZXh0YXJlYS5zdHlsZS5sZWZ0ID0gJyc7XG4gIHRoaXMudGV4dGFyZWEuc3R5bGUudG9wID0gJyc7XG59O1xuXG5leHBvcnRzLkNvbXBvc2l0aW9uSGVscGVyID0gQ29tcG9zaXRpb25IZWxwZXI7XG5cbn0se31dLDI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG4vKipcbiAqIHh0ZXJtLmpzOiB4dGVybSwgaW4gdGhlIGJyb3dzZXJcbiAqIENvcHlyaWdodCAoYykgMjAxNC0yMDE2LCBTb3VyY2VMYWlyIFByaXZhdGUgQ29tcGFueSAod3d3LnNvdXJjZWxhaXIuY29tIChNSVQgTGljZW5zZSlcbiAqL1xuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uICh0eXBlLCBsaXN0ZW5lcikge1xuICB0aGlzLl9ldmVudHNbdHlwZV0gPSB0aGlzLl9ldmVudHNbdHlwZV0gfHwgW107XG4gIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKSByZXR1cm47XG5cbiAgdmFyIG9iaiA9IHRoaXMuX2V2ZW50c1t0eXBlXSxcbiAgICAgIGkgPSBvYmoubGVuZ3RoO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZiAob2JqW2ldID09PSBsaXN0ZW5lciB8fCBvYmpbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICBvYmouc3BsaWNlKGksIDEpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gIGlmICh0aGlzLl9ldmVudHNbdHlwZV0pIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiAodHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBmdW5jdGlvbiBvbigpIHtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBvbik7XG4gICAgcmV0dXJuIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG4gIG9uLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHJldHVybiB0aGlzLm9uKHR5cGUsIG9uKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKSByZXR1cm47XG5cbiAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLFxuICAgICAgb2JqID0gdGhpcy5fZXZlbnRzW3R5cGVdLFxuICAgICAgbCA9IG9iai5sZW5ndGgsXG4gICAgICBpID0gMDtcblxuICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgIG9ialtpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiAodHlwZSkge1xuICByZXR1cm4gdGhpcy5fZXZlbnRzW3R5cGVdID0gdGhpcy5fZXZlbnRzW3R5cGVdIHx8IFtdO1xufTtcblxuZXhwb3J0cy5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbn0se31dLDM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuLyoqXG4gKiB4dGVybS5qczogeHRlcm0sIGluIHRoZSBicm93c2VyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNiwgU291cmNlTGFpciBQcml2YXRlIENvbXBhbnkgKHd3dy5zb3VyY2VsYWlyLmNvbSAoTUlUIExpY2Vuc2UpXG4gKi9cblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSB2aWV3cG9ydCBvZiBhIHRlcm1pbmFsLCB0aGUgdmlzaWJsZSBhcmVhIHdpdGhpbiB0aGUgbGFyZ2VyIGJ1ZmZlciBvZiBvdXRwdXQuXG4gKiBMb2dpYyBmb3IgdGhlIHZpcnR1YWwgc2Nyb2xsIGJhciBpcyBpbmNsdWRlZCBpbiB0aGlzIG9iamVjdC5cbiAqIEBwYXJhbSB7VGVybWluYWx9IHRlcm1pbmFsIFRoZSBUZXJtaW5hbCBvYmplY3QuXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB2aWV3cG9ydEVsZW1lbnQgVGhlIERPTSBlbGVtZW50IGFjdGluZyBhcyB0aGUgdmlld3BvcnRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNoYXJNZWFzdXJlRWxlbWVudCBBIERPTSBlbGVtZW50IHVzZWQgdG8gbWVhc3VyZSB0aGUgY2hhcmFjdGVyIHNpemUgb2ZcbiAqICAgdGhlIHRlcm1pbmFsLlxuICovXG5mdW5jdGlvbiBWaWV3cG9ydCh0ZXJtaW5hbCwgdmlld3BvcnRFbGVtZW50LCBzY3JvbGxBcmVhLCBjaGFyTWVhc3VyZUVsZW1lbnQpIHtcbiAgdGhpcy50ZXJtaW5hbCA9IHRlcm1pbmFsO1xuICB0aGlzLnZpZXdwb3J0RWxlbWVudCA9IHZpZXdwb3J0RWxlbWVudDtcbiAgdGhpcy5zY3JvbGxBcmVhID0gc2Nyb2xsQXJlYTtcbiAgdGhpcy5jaGFyTWVhc3VyZUVsZW1lbnQgPSBjaGFyTWVhc3VyZUVsZW1lbnQ7XG4gIHRoaXMuY3VycmVudFJvd0hlaWdodCA9IDA7XG4gIHRoaXMubGFzdFJlY29yZGVkQnVmZmVyTGVuZ3RoID0gMDtcbiAgdGhpcy5sYXN0UmVjb3JkZWRWaWV3cG9ydEhlaWdodCA9IDA7XG5cbiAgdGhpcy50ZXJtaW5hbC5vbignc2Nyb2xsJywgdGhpcy5zeW5jU2Nyb2xsQXJlYS5iaW5kKHRoaXMpKTtcbiAgdGhpcy50ZXJtaW5hbC5vbigncmVzaXplJywgdGhpcy5zeW5jU2Nyb2xsQXJlYS5iaW5kKHRoaXMpKTtcbiAgdGhpcy52aWV3cG9ydEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5vblNjcm9sbC5iaW5kKHRoaXMpKTtcblxuICB0aGlzLnN5bmNTY3JvbGxBcmVhKCk7XG59XG5cbi8qKlxuICogUmVmcmVzaGVzIHJvdyBoZWlnaHQsIHNldHRpbmcgbGluZS1oZWlnaHQsIHZpZXdwb3J0IGhlaWdodCBhbmQgc2Nyb2xsIGFyZWEgaGVpZ2h0IGlmXG4gKiBuZWNlc3NhcnkuXG4gKiBAcGFyYW0ge251bWJlcnx1bmRlZmluZWR9IGNoYXJTaXplIEEgY2hhcmFjdGVyIHNpemUgbWVhc3VyZW1lbnQgYm91bmRpbmcgcmVjdCBvYmplY3QsIGlmIGl0XG4gKiAgIGRvZXNuJ3QgZXhpc3QgaXQgd2lsbCBiZSBjcmVhdGVkLlxuICovXG5WaWV3cG9ydC5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uIChjaGFyU2l6ZSkge1xuICB2YXIgc2l6ZSA9IGNoYXJTaXplIHx8IHRoaXMuY2hhck1lYXN1cmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBpZiAoc2l6ZS5oZWlnaHQgPiAwKSB7XG4gICAgdmFyIHJvd0hlaWdodENoYW5nZWQgPSBzaXplLmhlaWdodCAhPT0gdGhpcy5jdXJyZW50Um93SGVpZ2h0O1xuICAgIGlmIChyb3dIZWlnaHRDaGFuZ2VkKSB7XG4gICAgICB0aGlzLmN1cnJlbnRSb3dIZWlnaHQgPSBzaXplLmhlaWdodDtcbiAgICAgIHRoaXMudmlld3BvcnRFbGVtZW50LnN0eWxlLmxpbmVIZWlnaHQgPSBzaXplLmhlaWdodCArICdweCc7XG4gICAgICB0aGlzLnRlcm1pbmFsLnJvd0NvbnRhaW5lci5zdHlsZS5saW5lSGVpZ2h0ID0gc2l6ZS5oZWlnaHQgKyAncHgnO1xuICAgIH1cbiAgICB2YXIgdmlld3BvcnRIZWlnaHRDaGFuZ2VkID0gdGhpcy5sYXN0UmVjb3JkZWRWaWV3cG9ydEhlaWdodCAhPT0gdGhpcy50ZXJtaW5hbC5yb3dzO1xuICAgIGlmIChyb3dIZWlnaHRDaGFuZ2VkIHx8IHZpZXdwb3J0SGVpZ2h0Q2hhbmdlZCkge1xuICAgICAgdGhpcy5sYXN0UmVjb3JkZWRWaWV3cG9ydEhlaWdodCA9IHRoaXMudGVybWluYWwucm93cztcbiAgICAgIHRoaXMudmlld3BvcnRFbGVtZW50LnN0eWxlLmhlaWdodCA9IHNpemUuaGVpZ2h0ICogdGhpcy50ZXJtaW5hbC5yb3dzICsgJ3B4JztcbiAgICB9XG4gICAgdGhpcy5zY3JvbGxBcmVhLnN0eWxlLmhlaWdodCA9IHNpemUuaGVpZ2h0ICogdGhpcy5sYXN0UmVjb3JkZWRCdWZmZXJMZW5ndGggKyAncHgnO1xuICB9XG59O1xuXG4vKipcbiAqIFVwZGF0ZXMgZGltZW5zaW9ucyBhbmQgc3luY2hyb25pemVzIHRoZSBzY3JvbGwgYXJlYSBpZiBuZWNlc3NhcnkuXG4gKi9cblZpZXdwb3J0LnByb3RvdHlwZS5zeW5jU2Nyb2xsQXJlYSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMubGFzdFJlY29yZGVkQnVmZmVyTGVuZ3RoICE9PSB0aGlzLnRlcm1pbmFsLmxpbmVzLmxlbmd0aCkge1xuICAgIC8vIElmIGJ1ZmZlciBoZWlnaHQgY2hhbmdlZFxuICAgIHRoaXMubGFzdFJlY29yZGVkQnVmZmVyTGVuZ3RoID0gdGhpcy50ZXJtaW5hbC5saW5lcy5sZW5ndGg7XG4gICAgdGhpcy5yZWZyZXNoKCk7XG4gIH0gZWxzZSBpZiAodGhpcy5sYXN0UmVjb3JkZWRWaWV3cG9ydEhlaWdodCAhPT0gdGhpcy50ZXJtaW5hbC5yb3dzKSB7XG4gICAgLy8gSWYgdmlld3BvcnQgaGVpZ2h0IGNoYW5nZWRcbiAgICB0aGlzLnJlZnJlc2goKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBJZiBzaXplIGhhcyBjaGFuZ2VkLCByZWZyZXNoIHZpZXdwb3J0XG4gICAgdmFyIHNpemUgPSB0aGlzLmNoYXJNZWFzdXJlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBpZiAoc2l6ZS5oZWlnaHQgIT09IHRoaXMuY3VycmVudFJvd0hlaWdodCkge1xuICAgICAgdGhpcy5yZWZyZXNoKHNpemUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFN5bmMgc2Nyb2xsVG9wXG4gIHZhciBzY3JvbGxUb3AgPSB0aGlzLnRlcm1pbmFsLnlkaXNwICogdGhpcy5jdXJyZW50Um93SGVpZ2h0O1xuICBpZiAodGhpcy52aWV3cG9ydEVsZW1lbnQuc2Nyb2xsVG9wICE9PSBzY3JvbGxUb3ApIHtcbiAgICB0aGlzLnZpZXdwb3J0RWxlbWVudC5zY3JvbGxUb3AgPSBzY3JvbGxUb3A7XG4gIH1cbn07XG5cbi8qKlxuICogSGFuZGxlcyBzY3JvbGwgZXZlbnRzIG9uIHRoZSB2aWV3cG9ydCwgY2FsY3VsYXRpbmcgdGhlIG5ldyB2aWV3cG9ydCBhbmQgcmVxdWVzdGluZyB0aGVcbiAqIHRlcm1pbmFsIHRvIHNjcm9sbCB0byBpdC5cbiAqIEBwYXJhbSB7RXZlbnR9IGV2IFRoZSBzY3JvbGwgZXZlbnQuXG4gKi9cblZpZXdwb3J0LnByb3RvdHlwZS5vblNjcm9sbCA9IGZ1bmN0aW9uIChldikge1xuICB2YXIgbmV3Um93ID0gTWF0aC5yb3VuZCh0aGlzLnZpZXdwb3J0RWxlbWVudC5zY3JvbGxUb3AgLyB0aGlzLmN1cnJlbnRSb3dIZWlnaHQpO1xuICB2YXIgZGlmZiA9IG5ld1JvdyAtIHRoaXMudGVybWluYWwueWRpc3A7XG4gIHRoaXMudGVybWluYWwuc2Nyb2xsRGlzcChkaWZmLCB0cnVlKTtcbn07XG5cbi8qKlxuICogSGFuZGxlcyBtb3VzZSB3aGVlbCBldmVudHMgYnkgYWRqdXN0aW5nIHRoZSB2aWV3cG9ydCdzIHNjcm9sbFRvcCBhbmQgZGVsZWdhdGluZyB0aGUgYWN0dWFsXG4gKiBzY3JvbGxpbmcgdG8gYG9uU2Nyb2xsYCwgdGhpcyBldmVudCBuZWVkcyB0byBiZSBhdHRhY2hlZCBtYW51YWxseSBieSB0aGUgY29uc3VtZXIgb2ZcbiAqIGBWaWV3cG9ydGAuXG4gKiBAcGFyYW0ge1doZWVsRXZlbnR9IGV2IFRoZSBtb3VzZSB3aGVlbCBldmVudC5cbiAqL1xuVmlld3BvcnQucHJvdG90eXBlLm9uV2hlZWwgPSBmdW5jdGlvbiAoZXYpIHtcbiAgaWYgKGV2LmRlbHRhWSA9PT0gMCkge1xuICAgIC8vIERvIG5vdGhpbmcgaWYgaXQncyBub3QgYSB2ZXJ0aWNhbCBzY3JvbGwgZXZlbnRcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gRmFsbGJhY2sgdG8gV2hlZWxFdmVudC5ET01fREVMVEFfUElYRUxcbiAgdmFyIG11bHRpcGxpZXIgPSAxO1xuICBpZiAoZXYuZGVsdGFNb2RlID09PSBXaGVlbEV2ZW50LkRPTV9ERUxUQV9MSU5FKSB7XG4gICAgbXVsdGlwbGllciA9IHRoaXMuY3VycmVudFJvd0hlaWdodDtcbiAgfSBlbHNlIGlmIChldi5kZWx0YU1vZGUgPT09IFdoZWVsRXZlbnQuRE9NX0RFTFRBX1BBR0UpIHtcbiAgICBtdWx0aXBsaWVyID0gdGhpcy5jdXJyZW50Um93SGVpZ2h0ICogdGhpcy50ZXJtaW5hbC5yb3dzO1xuICB9XG4gIHRoaXMudmlld3BvcnRFbGVtZW50LnNjcm9sbFRvcCArPSBldi5kZWx0YVkgKiBtdWx0aXBsaWVyO1xuICAvLyBQcmV2ZW50IHRoZSBwYWdlIGZyb20gc2Nyb2xsaW5nIHdoZW4gdGhlIHRlcm1pbmFsIHNjcm9sbHNcbiAgZXYucHJldmVudERlZmF1bHQoKTtcbn07XG5cbmV4cG9ydHMuVmlld3BvcnQgPSBWaWV3cG9ydDtcblxufSx7fV0sNDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG4vKipcbiAqIHh0ZXJtLmpzOiB4dGVybSwgaW4gdGhlIGJyb3dzZXJcbiAqIENvcHlyaWdodCAoYykgMjAxNiwgU291cmNlTGFpciBQcml2YXRlIENvbXBhbnkgPHd3dy5zb3VyY2VsYWlyLmNvbT4gKE1JVCBMaWNlbnNlKVxuICovXG5cbi8qKlxuICogQ2xpcGJvYXJkIGhhbmRsZXIgbW9kdWxlLiBUaGlzIG1vZHVsZSBjb250YWlucyBtZXRob2RzIGZvciBoYW5kbGluZyBhbGxcbiAqIGNsaXBib2FyZC1yZWxhdGVkIGV2ZW50cyBhcHByb3ByaWF0ZWx5IGluIHRoZSB0ZXJtaW5hbC5cbiAqIEBtb2R1bGUgeHRlcm0vaGFuZGxlcnMvQ2xpcGJvYXJkXG4gKi9cblxuLyoqXG4gKiBQcmVwYXJlcyB0ZXh0IGNvcGllZCBmcm9tIHRlcm1pbmFsIHNlbGVjdGlvbiwgdG8gYmUgc2F2ZWQgaW4gdGhlIGNsaXBib2FyZCBieTpcbiAqICAgMS4gc3RyaXBwaW5nIGFsbCB0cmFpbGluZyB3aGl0ZSBzcGFjZXNcbiAqICAgMi4gY29udmVydGluZyBhbGwgbm9uLWJyZWFraW5nIHNwYWNlcyB0byByZWd1bGFyIHNwYWNlc1xuICogQHBhcmFtIHtzdHJpbmd9IHRleHQgVGhlIGNvcGllZCB0ZXh0IHRoYXQgbmVlZHMgcHJvY2Vzc2luZyBmb3Igc3RvcmluZyBpbiBjbGlwYm9hcmRcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHByZXBhcmVUZXh0Rm9yQ2xpcGJvYXJkKHRleHQpIHtcbiAgdmFyIHNwYWNlID0gU3RyaW5nLmZyb21DaGFyQ29kZSgzMiksXG4gICAgICBub25CcmVha2luZ1NwYWNlID0gU3RyaW5nLmZyb21DaGFyQ29kZSgxNjApLFxuICAgICAgYWxsTm9uQnJlYWtpbmdTcGFjZXMgPSBuZXcgUmVnRXhwKG5vbkJyZWFraW5nU3BhY2UsICdnJyksXG4gICAgICBwcm9jZXNzZWRUZXh0ID0gdGV4dC5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgLy8gU3RyaXAgYWxsIHRyYWlsaW5nIHdoaXRlIHNwYWNlcyBhbmQgY29udmVydCBhbGwgbm9uLWJyZWFraW5nIHNwYWNlc1xuICAgIC8vIHRvIHJlZ3VsYXIgc3BhY2VzLlxuICAgIHZhciBwcm9jZXNzZWRMaW5lID0gbGluZS5yZXBsYWNlKC9cXHMrJC9nLCAnJykucmVwbGFjZShhbGxOb25CcmVha2luZ1NwYWNlcywgc3BhY2UpO1xuXG4gICAgcmV0dXJuIHByb2Nlc3NlZExpbmU7XG4gIH0pLmpvaW4oJ1xcbicpO1xuXG4gIHJldHVybiBwcm9jZXNzZWRUZXh0O1xufVxuXG4vKipcbiAqIEJpbmRzIGNvcHkgZnVuY3Rpb25hbGl0eSB0byB0aGUgZ2l2ZW4gdGVybWluYWwuXG4gKiBAcGFyYW0ge0NsaXBib2FyZEV2ZW50fSBldiBUaGUgb3JpZ2luYWwgY29weSBldmVudCB0byBiZSBoYW5kbGVkXG4gKi9cbmZ1bmN0aW9uIGNvcHlIYW5kbGVyKGV2KSB7XG4gIHZhciBjb3BpZWRUZXh0ID0gd2luZG93LmdldFNlbGVjdGlvbigpLnRvU3RyaW5nKCksXG4gICAgICB0ZXh0ID0gcHJlcGFyZVRleHRGb3JDbGlwYm9hcmQoY29waWVkVGV4dCk7XG5cbiAgZXYuY2xpcGJvYXJkRGF0YS5zZXREYXRhKCd0ZXh0L3BsYWluJywgdGV4dCk7XG4gIGV2LnByZXZlbnREZWZhdWx0KCk7IC8vIFByZXZlbnQgb3IgdGhlIG9yaWdpbmFsIHRleHQgd2lsbCBiZSBjb3BpZWQuXG59XG5cbi8qKlxuICogUmVkaXJlY3QgdGhlIGNsaXBib2FyZCdzIGRhdGEgdG8gdGhlIHRlcm1pbmFsJ3MgaW5wdXQgaGFuZGxlci5cbiAqIEBwYXJhbSB7Q2xpcGJvYXJkRXZlbnR9IGV2IFRoZSBvcmlnaW5hbCBwYXN0ZSBldmVudCB0byBiZSBoYW5kbGVkXG4gKiBAcGFyYW0ge1Rlcm1pbmFsfSB0ZXJtIFRoZSB0ZXJtaW5hbCBvbiB3aGljaCB0byBhcHBseSB0aGUgaGFuZGxlZCBwYXN0ZSBldmVudFxuICovXG5mdW5jdGlvbiBwYXN0ZUhhbmRsZXIoZXYsIHRlcm0pIHtcbiAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIGlmIChldi5jbGlwYm9hcmREYXRhKSB7XG4gICAgdmFyIHRleHQgPSBldi5jbGlwYm9hcmREYXRhLmdldERhdGEoJ3RleHQvcGxhaW4nKTtcbiAgICB0ZXJtLmhhbmRsZXIodGV4dCk7XG4gICAgdGVybS50ZXh0YXJlYS52YWx1ZSA9ICcnO1xuICAgIHJldHVybiB0ZXJtLmNhbmNlbChldik7XG4gIH1cbn1cblxuLyoqXG4gKiBCaW5kIHRvIHJpZ2h0LWNsaWNrIGV2ZW50IGFuZCBhbGxvdyByaWdodC1jbGljayBjb3B5IGFuZCBwYXN0ZS5cbiAqXG4gKiAqKkxvZ2ljKipcbiAqIElmIHRleHQgaXMgc2VsZWN0ZWQgYW5kIHJpZ2h0LWNsaWNrIGhhcHBlbnMgb24gc2VsZWN0ZWQgdGV4dCwgdGhlblxuICogZG8gbm90aGluZyB0byBhbGxvdyBzZWFtbGVzcyBjb3B5aW5nLlxuICogSWYgbm8gdGV4dCBpcyBzZWxlY3RlZCBvciByaWdodC1jbGljayBpcyBvdXRzaWRlIG9mIHRoZSBzZWxlY3Rpb25cbiAqIGFyZWEsIHRoZW4gYnJpbmcgdGhlIHRlcm1pbmFsJ3MgaW5wdXQgYmVsb3cgdGhlIGN1cnNvciwgaW4gb3JkZXIgdG9cbiAqIHRyaWdnZXIgdGhlIGV2ZW50IG9uIHRoZSB0ZXh0YXJlYSBhbmQgYWxsb3ctcmlnaHQgY2xpY2sgcGFzdGUsIHdpdGhvdXRcbiAqIGNhcmluZyBhYm91dCBkaXNhcHBlYXJpbmcgc2VsZWN0aW9uLlxuICogQHBhcmFtIHtDbGlwYm9hcmRFdmVudH0gZXYgVGhlIG9yaWdpbmFsIHBhc3RlIGV2ZW50IHRvIGJlIGhhbmRsZWRcbiAqIEBwYXJhbSB7VGVybWluYWx9IHRlcm0gVGhlIHRlcm1pbmFsIG9uIHdoaWNoIHRvIGFwcGx5IHRoZSBoYW5kbGVkIHBhc3RlIGV2ZW50XG4gKi9cbmZ1bmN0aW9uIHJpZ2h0Q2xpY2tIYW5kbGVyKGV2LCB0ZXJtKSB7XG4gIHZhciBzID0gZG9jdW1lbnQuZ2V0U2VsZWN0aW9uKCksXG4gICAgICBzVGV4dCA9IHByZXBhcmVUZXh0Rm9yQ2xpcGJvYXJkKHMudG9TdHJpbmcoKSksXG4gICAgICByID0gcy5nZXRSYW5nZUF0KDApO1xuXG4gIHZhciB4ID0gZXYuY2xpZW50WCxcbiAgICAgIHkgPSBldi5jbGllbnRZO1xuXG4gIHZhciBjciA9IHIuZ2V0Q2xpZW50UmVjdHMoKSxcbiAgICAgIGNsaWNrSXNPblNlbGVjdGlvbiA9IGZhbHNlLFxuICAgICAgaSxcbiAgICAgIHJlY3Q7XG5cbiAgZm9yIChpID0gMDsgaSA8IGNyLmxlbmd0aDsgaSsrKSB7XG4gICAgcmVjdCA9IGNyW2ldO1xuICAgIGNsaWNrSXNPblNlbGVjdGlvbiA9IHggPiByZWN0LmxlZnQgJiYgeCA8IHJlY3QucmlnaHQgJiYgeSA+IHJlY3QudG9wICYmIHkgPCByZWN0LmJvdHRvbTtcbiAgICAvLyBJZiB3ZSBjbGlja2VkIG9uIHNlbGVjdGlvbiBhbmQgc2VsZWN0aW9uIGlzIG5vdCBhIHNpbmdsZSBzcGFjZSxcbiAgICAvLyB0aGVuIG1hcmsgdGhlIHJpZ2h0IGNsaWNrIGFzIGNvcHktb25seS4gV2UgY2hlY2sgZm9yIHRoZSBzaW5nbGVcbiAgICAvLyBzcGFjZSBzZWxlY3Rpb24sIGFzIHRoaXMgY2FuIGhhcHBlbiB3aGVuIGNsaWNraW5nIG9uIGFuICZuYnNwO1xuICAgIC8vIGFuZCB0aGVyZSBpcyBub3QgbXVjaCBwb2ludGluZyBpbiBjb3B5aW5nIGEgc2luZ2xlIHNwYWNlLlxuICAgIC8vIFNpbmdsZSBzcGFjZSBpcyBjaGFyXG4gICAgaWYgKGNsaWNrSXNPblNlbGVjdGlvbiAmJiBzVGV4dCAhPT0gJyAnKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAvLyBCcmluZyB0ZXh0YXJlYSBhdCB0aGUgY3Vyc29yIHBvc2l0aW9uXG4gIGlmICghY2xpY2tJc09uU2VsZWN0aW9uKSB7XG4gICAgdGVybS50ZXh0YXJlYS5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gICAgdGVybS50ZXh0YXJlYS5zdHlsZS53aWR0aCA9ICcxMHB4JztcbiAgICB0ZXJtLnRleHRhcmVhLnN0eWxlLmhlaWdodCA9ICcxMHB4JztcbiAgICB0ZXJtLnRleHRhcmVhLnN0eWxlLmxlZnQgPSB4ICsgJ3B4JztcbiAgICB0ZXJtLnRleHRhcmVhLnN0eWxlLnRvcCA9IHkgKyAncHgnO1xuICAgIHRlcm0udGV4dGFyZWEuc3R5bGUuekluZGV4ID0gMTAwMDtcbiAgICB0ZXJtLnRleHRhcmVhLmZvY3VzKCk7XG5cbiAgICAvLyBSZXNldCB0aGUgdGVybWluYWwgdGV4dGFyZWEncyBzdHlsaW5nXG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICB0ZXJtLnRleHRhcmVhLnN0eWxlLnBvc2l0aW9uID0gbnVsbDtcbiAgICAgIHRlcm0udGV4dGFyZWEuc3R5bGUud2lkdGggPSBudWxsO1xuICAgICAgdGVybS50ZXh0YXJlYS5zdHlsZS5oZWlnaHQgPSBudWxsO1xuICAgICAgdGVybS50ZXh0YXJlYS5zdHlsZS5sZWZ0ID0gbnVsbDtcbiAgICAgIHRlcm0udGV4dGFyZWEuc3R5bGUudG9wID0gbnVsbDtcbiAgICAgIHRlcm0udGV4dGFyZWEuc3R5bGUuekluZGV4ID0gbnVsbDtcbiAgICB9LCAxKTtcbiAgfVxufVxuXG5leHBvcnRzLnByZXBhcmVUZXh0Rm9yQ2xpcGJvYXJkID0gcHJlcGFyZVRleHRGb3JDbGlwYm9hcmQ7XG5leHBvcnRzLmNvcHlIYW5kbGVyID0gY29weUhhbmRsZXI7XG5leHBvcnRzLnBhc3RlSGFuZGxlciA9IHBhc3RlSGFuZGxlcjtcbmV4cG9ydHMucmlnaHRDbGlja0hhbmRsZXIgPSByaWdodENsaWNrSGFuZGxlcjtcblxufSx7fV0sNTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKF9fZGlybmFtZSl7XG4ndXNlIHN0cmljdCc7dmFyIF90eXBlb2Y9dHlwZW9mIFN5bWJvbD09PVwiZnVuY3Rpb25cIiYmdHlwZW9mIFN5bWJvbC5pdGVyYXRvcj09PVwic3ltYm9sXCI/ZnVuY3Rpb24ob2JqKXtyZXR1cm4gdHlwZW9mIG9iajt9OmZ1bmN0aW9uKG9iail7cmV0dXJuIG9iaiYmdHlwZW9mIFN5bWJvbD09PVwiZnVuY3Rpb25cIiYmb2JqLmNvbnN0cnVjdG9yPT09U3ltYm9sJiZvYmohPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIG9iajt9Oy8qKlxuICogeHRlcm0uanM6IHh0ZXJtLCBpbiB0aGUgYnJvd3NlclxuICogQ29weXJpZ2h0IChjKSAyMDE0LTIwMTQsIFNvdXJjZUxhaXIgUHJpdmF0ZSBDb21wYW55IDx3d3cuc291cmNlbGFpci5jb20+IChNSVQgTGljZW5zZSlcbiAqIENvcHlyaWdodCAoYykgMjAxMi0yMDEzLCBDaHJpc3RvcGhlciBKZWZmcmV5IChNSVQgTGljZW5zZSlcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGpqL3Rlcm0uanNcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICpcbiAqIE9yaWdpbmFsbHkgZm9ya2VkIGZyb20gKHdpdGggdGhlIGF1dGhvcidzIHBlcm1pc3Npb24pOlxuICogICBGYWJyaWNlIEJlbGxhcmQncyBqYXZhc2NyaXB0IHZ0MTAwIGZvciBqc2xpbnV4OlxuICogICBodHRwOi8vYmVsbGFyZC5vcmcvanNsaW51eC9cbiAqICAgQ29weXJpZ2h0IChjKSAyMDExIEZhYnJpY2UgQmVsbGFyZFxuICogICBUaGUgb3JpZ2luYWwgZGVzaWduIHJlbWFpbnMuIFRoZSB0ZXJtaW5hbCBpdHNlbGZcbiAqICAgaGFzIGJlZW4gZXh0ZW5kZWQgdG8gaW5jbHVkZSB4dGVybSBDU0kgY29kZXMsIGFtb25nXG4gKiAgIG90aGVyIGZlYXR1cmVzLlxuICovdmFyIF9Db21wb3NpdGlvbkhlbHBlcj1fZGVyZXFfKCcuL0NvbXBvc2l0aW9uSGVscGVyLmpzJyk7dmFyIF9FdmVudEVtaXR0ZXI9X2RlcmVxXygnLi9FdmVudEVtaXR0ZXIuanMnKTt2YXIgX1ZpZXdwb3J0PV9kZXJlcV8oJy4vVmlld3BvcnQuanMnKTt2YXIgX0NsaXBib2FyZD1fZGVyZXFfKCcuL2hhbmRsZXJzL0NsaXBib2FyZC5qcycpOy8qKlxuICogVGVybWluYWwgRW11bGF0aW9uIFJlZmVyZW5jZXM6XG4gKiAgIGh0dHA6Ly92dDEwMC5uZXQvXG4gKiAgIGh0dHA6Ly9pbnZpc2libGUtaXNsYW5kLm5ldC94dGVybS9jdGxzZXFzL2N0bHNlcXMudHh0XG4gKiAgIGh0dHA6Ly9pbnZpc2libGUtaXNsYW5kLm5ldC94dGVybS9jdGxzZXFzL2N0bHNlcXMuaHRtbFxuICogICBodHRwOi8vaW52aXNpYmxlLWlzbGFuZC5uZXQvdnR0ZXN0L1xuICogICBodHRwOi8vd3d3Lmlud2FwLmNvbS9wZHAxMC9hbnNpY29kZS50eHRcbiAqICAgaHR0cDovL2xpbnV4LmRpZS5uZXQvbWFuLzQvY29uc29sZV9jb2Rlc1xuICogICBodHRwOi8vbGludXguZGllLm5ldC9tYW4vNy91cnh2dFxuICovLy8gTGV0IGl0IHdvcmsgaW5zaWRlIE5vZGUuanMgZm9yIGF1dG9tYXRlZCB0ZXN0aW5nIHB1cnBvc2VzLlxudmFyIGRvY3VtZW50PXR5cGVvZiB3aW5kb3chPSd1bmRlZmluZWQnP3dpbmRvdy5kb2N1bWVudDpudWxsOy8qKlxuICogU3RhdGVzXG4gKi92YXIgbm9ybWFsPTAsZXNjYXBlZD0xLGNzaT0yLG9zYz0zLGNoYXJzZXQ9NCxkY3M9NSxpZ25vcmU9NjsvKipcbiAqIFRlcm1pbmFsXG4gKi8vKipcbiAqIENyZWF0ZXMgYSBuZXcgYFRlcm1pbmFsYCBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgYSBzZXQgb2Ygb3B0aW9ucywgdGhlIGF2YWlsYWJsZSBvcHRpb25zIGFyZTpcbiAqICAgLSBjdXJzb3JCbGluayAoYm9vbGVhbik6IFdoZXRoZXIgdGhlIHRlcm1pbmFsIGN1cnNvciBibGlua3NcbiAqXG4gKiBAcHVibGljXG4gKiBAY2xhc3MgWHRlcm0gWHRlcm1cbiAqIEBhbGlhcyBtb2R1bGU6eHRlcm0vc3JjL3h0ZXJtXG4gKi9mdW5jdGlvbiBUZXJtaW5hbChvcHRpb25zKXt2YXIgc2VsZj10aGlzO2lmKCEodGhpcyBpbnN0YW5jZW9mIFRlcm1pbmFsKSl7cmV0dXJuIG5ldyBUZXJtaW5hbChhcmd1bWVudHNbMF0sYXJndW1lbnRzWzFdLGFyZ3VtZW50c1syXSk7fXNlbGYuY2FuY2VsPVRlcm1pbmFsLmNhbmNlbDtfRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO2lmKHR5cGVvZiBvcHRpb25zPT09J251bWJlcicpe29wdGlvbnM9e2NvbHM6YXJndW1lbnRzWzBdLHJvd3M6YXJndW1lbnRzWzFdLGhhbmRsZXI6YXJndW1lbnRzWzJdfTt9b3B0aW9ucz1vcHRpb25zfHx7fTtPYmplY3Qua2V5cyhUZXJtaW5hbC5kZWZhdWx0cykuZm9yRWFjaChmdW5jdGlvbihrZXkpe2lmKG9wdGlvbnNba2V5XT09bnVsbCl7b3B0aW9uc1trZXldPVRlcm1pbmFsLm9wdGlvbnNba2V5XTtpZihUZXJtaW5hbFtrZXldIT09VGVybWluYWwuZGVmYXVsdHNba2V5XSl7b3B0aW9uc1trZXldPVRlcm1pbmFsW2tleV07fX1zZWxmW2tleV09b3B0aW9uc1trZXldO30pO2lmKG9wdGlvbnMuY29sb3JzLmxlbmd0aD09PTgpe29wdGlvbnMuY29sb3JzPW9wdGlvbnMuY29sb3JzLmNvbmNhdChUZXJtaW5hbC5fY29sb3JzLnNsaWNlKDgpKTt9ZWxzZSBpZihvcHRpb25zLmNvbG9ycy5sZW5ndGg9PT0xNil7b3B0aW9ucy5jb2xvcnM9b3B0aW9ucy5jb2xvcnMuY29uY2F0KFRlcm1pbmFsLl9jb2xvcnMuc2xpY2UoMTYpKTt9ZWxzZSBpZihvcHRpb25zLmNvbG9ycy5sZW5ndGg9PT0xMCl7b3B0aW9ucy5jb2xvcnM9b3B0aW9ucy5jb2xvcnMuc2xpY2UoMCwtMikuY29uY2F0KFRlcm1pbmFsLl9jb2xvcnMuc2xpY2UoOCwtMiksb3B0aW9ucy5jb2xvcnMuc2xpY2UoLTIpKTt9ZWxzZSBpZihvcHRpb25zLmNvbG9ycy5sZW5ndGg9PT0xOCl7b3B0aW9ucy5jb2xvcnM9b3B0aW9ucy5jb2xvcnMuY29uY2F0KFRlcm1pbmFsLl9jb2xvcnMuc2xpY2UoMTYsLTIpLG9wdGlvbnMuY29sb3JzLnNsaWNlKC0yKSk7fXRoaXMuY29sb3JzPW9wdGlvbnMuY29sb3JzO3RoaXMub3B0aW9ucz1vcHRpb25zOy8vIHRoaXMuY29udGV4dCA9IG9wdGlvbnMuY29udGV4dCB8fCB3aW5kb3c7XG4vLyB0aGlzLmRvY3VtZW50ID0gb3B0aW9ucy5kb2N1bWVudCB8fCBkb2N1bWVudDtcbnRoaXMucGFyZW50PW9wdGlvbnMuYm9keXx8b3B0aW9ucy5wYXJlbnR8fChkb2N1bWVudD9kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYm9keScpWzBdOm51bGwpO3RoaXMuY29scz1vcHRpb25zLmNvbHN8fG9wdGlvbnMuZ2VvbWV0cnlbMF07dGhpcy5yb3dzPW9wdGlvbnMucm93c3x8b3B0aW9ucy5nZW9tZXRyeVsxXTtpZihvcHRpb25zLmhhbmRsZXIpe3RoaXMub24oJ2RhdGEnLG9wdGlvbnMuaGFuZGxlcik7fS8qKlxuICAgKiBUaGUgc2Nyb2xsIHBvc2l0aW9uIG9mIHRoZSB5IGN1cnNvciwgaWUuIHliYXNlICsgeSA9IHRoZSB5IHBvc2l0aW9uIHdpdGhpbiB0aGUgZW50aXJlXG4gICAqIGJ1ZmZlclxuICAgKi90aGlzLnliYXNlPTA7LyoqXG4gICAqIFRoZSBzY3JvbGwgcG9zaXRpb24gb2YgdGhlIHZpZXdwb3J0XG4gICAqL3RoaXMueWRpc3A9MDsvKipcbiAgICogVGhlIGN1cnNvcidzIHggcG9zaXRpb24gYWZ0ZXIgeWJhc2VcbiAgICovdGhpcy54PTA7LyoqXG4gICAqIFRoZSBjdXJzb3IncyB5IHBvc2l0aW9uIGFmdGVyIHliYXNlXG4gICAqL3RoaXMueT0wOy8qKlxuICAgKiBVc2VkIHRvIGRlYm91bmNlIHRoZSByZWZyZXNoIGZ1bmN0aW9uXG4gICAqL3RoaXMuaXNSZWZyZXNoaW5nPWZhbHNlOy8qKlxuICAgKiBXaGV0aGVyIHRoZXJlIGlzIGEgZnVsbCB0ZXJtaW5hbCByZWZyZXNoIHF1ZXVlZFxuICAgKi90aGlzLmN1cnNvclN0YXRlPTA7dGhpcy5jdXJzb3JIaWRkZW49ZmFsc2U7dGhpcy5jb252ZXJ0RW9sO3RoaXMuc3RhdGU9MDt0aGlzLnF1ZXVlPScnO3RoaXMuc2Nyb2xsVG9wPTA7dGhpcy5zY3JvbGxCb3R0b209dGhpcy5yb3dzLTE7dGhpcy5jdXN0b21LZXlkb3duSGFuZGxlcj1udWxsOy8vIG1vZGVzXG50aGlzLmFwcGxpY2F0aW9uS2V5cGFkPWZhbHNlO3RoaXMuYXBwbGljYXRpb25DdXJzb3I9ZmFsc2U7dGhpcy5vcmlnaW5Nb2RlPWZhbHNlO3RoaXMuaW5zZXJ0TW9kZT1mYWxzZTt0aGlzLndyYXBhcm91bmRNb2RlPXRydWU7Ly8gZGVmYXVsdHM6IHh0ZXJtIC0gdHJ1ZSwgdnQxMDAgLSBmYWxzZVxudGhpcy5ub3JtYWw9bnVsbDsvLyBjaGFyc2V0XG50aGlzLmNoYXJzZXQ9bnVsbDt0aGlzLmdjaGFyc2V0PW51bGw7dGhpcy5nbGV2ZWw9MDt0aGlzLmNoYXJzZXRzPVtudWxsXTsvLyBtb3VzZSBwcm9wZXJ0aWVzXG50aGlzLmRlY0xvY2F0b3I7dGhpcy54MTBNb3VzZTt0aGlzLnZ0MjAwTW91c2U7dGhpcy52dDMwME1vdXNlO3RoaXMubm9ybWFsTW91c2U7dGhpcy5tb3VzZUV2ZW50czt0aGlzLnNlbmRGb2N1czt0aGlzLnV0Zk1vdXNlO3RoaXMuc2dyTW91c2U7dGhpcy51cnh2dE1vdXNlOy8vIG1pc2NcbnRoaXMuZWxlbWVudDt0aGlzLmNoaWxkcmVuO3RoaXMucmVmcmVzaFN0YXJ0O3RoaXMucmVmcmVzaEVuZDt0aGlzLnNhdmVkWDt0aGlzLnNhdmVkWTt0aGlzLnNhdmVkQ29sczsvLyBzdHJlYW1cbnRoaXMucmVhZGFibGU9dHJ1ZTt0aGlzLndyaXRhYmxlPXRydWU7dGhpcy5kZWZBdHRyPTA8PDE4fDI1Nzw8OXwyNTY8PDA7dGhpcy5jdXJBdHRyPXRoaXMuZGVmQXR0cjt0aGlzLnBhcmFtcz1bXTt0aGlzLmN1cnJlbnRQYXJhbT0wO3RoaXMucHJlZml4PScnO3RoaXMucG9zdGZpeD0nJzsvLyBsZWZ0b3ZlciBzdXJyb2dhdGUgaGlnaCBmcm9tIHByZXZpb3VzIHdyaXRlIGludm9jYXRpb25cbnRoaXMuc3Vycm9nYXRlX2hpZ2g9Jyc7LyoqXG4gICAqIEFuIGFycmF5IG9mIGFsbCBsaW5lcyBpbiB0aGUgZW50aXJlIGJ1ZmZlciwgaW5jbHVkaW5nIHRoZSBwcm9tcHQuIFRoZSBsaW5lcyBhcmUgYXJyYXkgb2ZcbiAgICogY2hhcmFjdGVycyB3aGljaCBhcmUgMi1sZW5ndGggYXJyYXlzIHdoZXJlIFswXSBpcyBhbiBhdHRyaWJ1dGUgYW5kIFsxXSBpcyB0aGUgY2hhcmFjdGVyLlxuICAgKi90aGlzLmxpbmVzPVtdO3ZhciBpPXRoaXMucm93czt3aGlsZShpLS0pe3RoaXMubGluZXMucHVzaCh0aGlzLmJsYW5rTGluZSgpKTt9dGhpcy50YWJzO3RoaXMuc2V0dXBTdG9wcygpO31pbmhlcml0cyhUZXJtaW5hbCxfRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlcik7LyoqXG4gKiBiYWNrX2NvbG9yX2VyYXNlIGZlYXR1cmUgZm9yIHh0ZXJtLlxuICovVGVybWluYWwucHJvdG90eXBlLmVyYXNlQXR0cj1mdW5jdGlvbigpey8vIGlmICh0aGlzLmlzKCdzY3JlZW4nKSkgcmV0dXJuIHRoaXMuZGVmQXR0cjtcbnJldHVybiB0aGlzLmRlZkF0dHImfjB4MWZmfHRoaXMuY3VyQXR0ciYweDFmZjt9Oy8qKlxuICogQ29sb3JzXG4gKi8vLyBDb2xvcnMgMC0xNVxuVGVybWluYWwudGFuZ29Db2xvcnM9Wy8vIGRhcms6XG4nIzJlMzQzNicsJyNjYzAwMDAnLCcjNGU5YTA2JywnI2M0YTAwMCcsJyMzNDY1YTQnLCcjNzU1MDdiJywnIzA2OTg5YScsJyNkM2Q3Y2YnLC8vIGJyaWdodDpcbicjNTU1NzUzJywnI2VmMjkyOScsJyM4YWUyMzQnLCcjZmNlOTRmJywnIzcyOWZjZicsJyNhZDdmYTgnLCcjMzRlMmUyJywnI2VlZWVlYyddOy8vIENvbG9ycyAwLTE1ICsgMTYtMjU1XG4vLyBNdWNoIHRoYW5rcyB0byBUb29UYWxsTmF0ZSBmb3Igd3JpdGluZyB0aGlzLlxuVGVybWluYWwuY29sb3JzPWZ1bmN0aW9uKCl7dmFyIGNvbG9ycz1UZXJtaW5hbC50YW5nb0NvbG9ycy5zbGljZSgpLHI9WzB4MDAsMHg1ZiwweDg3LDB4YWYsMHhkNywweGZmXSxpOy8vIDE2LTIzMVxuaT0wO2Zvcig7aTwyMTY7aSsrKXtvdXQocltpLzM2JTZ8MF0scltpLzYlNnwwXSxyW2klNl0pO30vLyAyMzItMjU1IChncmV5KVxuaT0wO2Zvcig7aTwyNDtpKyspe3I9OCtpKjEwO291dChyLHIscik7fWZ1bmN0aW9uIG91dChyLGcsYil7Y29sb3JzLnB1c2goJyMnK2hleChyKStoZXgoZykraGV4KGIpKTt9ZnVuY3Rpb24gaGV4KGMpe2M9Yy50b1N0cmluZygxNik7cmV0dXJuIGMubGVuZ3RoPDI/JzAnK2M6Yzt9cmV0dXJuIGNvbG9yczt9KCk7VGVybWluYWwuX2NvbG9ycz1UZXJtaW5hbC5jb2xvcnMuc2xpY2UoKTtUZXJtaW5hbC52Y29sb3JzPWZ1bmN0aW9uKCl7dmFyIG91dD1bXSxjb2xvcnM9VGVybWluYWwuY29sb3JzLGk9MCxjb2xvcjtmb3IoO2k8MjU2O2krKyl7Y29sb3I9cGFyc2VJbnQoY29sb3JzW2ldLnN1YnN0cmluZygxKSwxNik7b3V0LnB1c2goW2NvbG9yPj4xNiYweGZmLGNvbG9yPj44JjB4ZmYsY29sb3ImMHhmZl0pO31yZXR1cm4gb3V0O30oKTsvKipcbiAqIE9wdGlvbnNcbiAqL1Rlcm1pbmFsLmRlZmF1bHRzPXtjb2xvcnM6VGVybWluYWwuY29sb3JzLHRoZW1lOidkZWZhdWx0Jyxjb252ZXJ0RW9sOmZhbHNlLHRlcm1OYW1lOid4dGVybScsZ2VvbWV0cnk6WzgwLDI0XSxjdXJzb3JCbGluazpmYWxzZSx2aXN1YWxCZWxsOmZhbHNlLHBvcE9uQmVsbDpmYWxzZSxzY3JvbGxiYWNrOjEwMDAsc2NyZWVuS2V5czpmYWxzZSxkZWJ1ZzpmYWxzZSxjYW5jZWxFdmVudHM6ZmFsc2UvLyBwcm9ncmFtRmVhdHVyZXM6IGZhbHNlLFxuLy8gZm9jdXNLZXlzOiBmYWxzZSxcbn07VGVybWluYWwub3B0aW9ucz17fTtUZXJtaW5hbC5mb2N1cz1udWxsO2VhY2goa2V5cyhUZXJtaW5hbC5kZWZhdWx0cyksZnVuY3Rpb24oa2V5KXtUZXJtaW5hbFtrZXldPVRlcm1pbmFsLmRlZmF1bHRzW2tleV07VGVybWluYWwub3B0aW9uc1trZXldPVRlcm1pbmFsLmRlZmF1bHRzW2tleV07fSk7LyoqXG4gKiBGb2N1cyB0aGUgdGVybWluYWwuIERlbGVnYXRlcyBmb2N1cyBoYW5kbGluZyB0byB0aGUgdGVybWluYWwncyBET00gZWxlbWVudC5cbiAqL1Rlcm1pbmFsLnByb3RvdHlwZS5mb2N1cz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRleHRhcmVhLmZvY3VzKCk7fTsvKipcbiAqIFJldHJpZXZlcyBhbiBvcHRpb24ncyB2YWx1ZSBmcm9tIHRoZSB0ZXJtaW5hbC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIG9wdGlvbiBrZXkuXG4gKi9UZXJtaW5hbC5wcm90b3R5cGUuZ2V0T3B0aW9uPWZ1bmN0aW9uKGtleSx2YWx1ZSl7aWYoIShrZXkgaW4gVGVybWluYWwuZGVmYXVsdHMpKXt0aHJvdyBuZXcgRXJyb3IoJ05vIG9wdGlvbiB3aXRoIGtleSBcIicra2V5KydcIicpO31pZih0eXBlb2YgdGhpcy5vcHRpb25zW2tleV0hPT0ndW5kZWZpbmVkJyl7cmV0dXJuIHRoaXMub3B0aW9uc1trZXldO31yZXR1cm4gdGhpc1trZXldO307LyoqXG4gKiBTZXRzIGFuIG9wdGlvbiBvbiB0aGUgdGVybWluYWwuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBvcHRpb24ga2V5LlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIFRoZSBvcHRpb24gdmFsdWUuXG4gKi9UZXJtaW5hbC5wcm90b3R5cGUuc2V0T3B0aW9uPWZ1bmN0aW9uKGtleSx2YWx1ZSl7aWYoIShrZXkgaW4gVGVybWluYWwuZGVmYXVsdHMpKXt0aHJvdyBuZXcgRXJyb3IoJ05vIG9wdGlvbiB3aXRoIGtleSBcIicra2V5KydcIicpO310aGlzW2tleV09dmFsdWU7dGhpcy5vcHRpb25zW2tleV09dmFsdWU7fTsvKipcbiAqIEJpbmRzIHRoZSBkZXNpcmVkIGZvY3VzIGJlaGF2aW9yIG9uIGEgZ2l2ZW4gdGVybWluYWwgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqL1Rlcm1pbmFsLmJpbmRGb2N1cz1mdW5jdGlvbih0ZXJtKXtvbih0ZXJtLnRleHRhcmVhLCdmb2N1cycsZnVuY3Rpb24oZXYpe2lmKHRlcm0uc2VuZEZvY3VzKXt0ZXJtLnNlbmQoJ1xceDFiW0knKTt9dGVybS5lbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2ZvY3VzJyk7dGVybS5zaG93Q3Vyc29yKCk7VGVybWluYWwuZm9jdXM9dGVybTt0ZXJtLmVtaXQoJ2ZvY3VzJyx7dGVybWluYWw6dGVybX0pO30pO307LyoqXG4gKiBCbHVyIHRoZSB0ZXJtaW5hbC4gRGVsZWdhdGVzIGJsdXIgaGFuZGxpbmcgdG8gdGhlIHRlcm1pbmFsJ3MgRE9NIGVsZW1lbnQuXG4gKi9UZXJtaW5hbC5wcm90b3R5cGUuYmx1cj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRleHRhcmVhLmJsdXIoKTt9Oy8qKlxuICogQmluZHMgdGhlIGRlc2lyZWQgYmx1ciBiZWhhdmlvciBvbiBhIGdpdmVuIHRlcm1pbmFsIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKi9UZXJtaW5hbC5iaW5kQmx1cj1mdW5jdGlvbih0ZXJtKXtvbih0ZXJtLnRleHRhcmVhLCdibHVyJyxmdW5jdGlvbihldil7dGVybS5yZWZyZXNoKHRlcm0ueSx0ZXJtLnkpO2lmKHRlcm0uc2VuZEZvY3VzKXt0ZXJtLnNlbmQoJ1xceDFiW08nKTt9dGVybS5lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ2ZvY3VzJyk7VGVybWluYWwuZm9jdXM9bnVsbDt0ZXJtLmVtaXQoJ2JsdXInLHt0ZXJtaW5hbDp0ZXJtfSk7fSk7fTsvKipcbiAqIEluaXRpYWxpemUgZGVmYXVsdCBiZWhhdmlvclxuICovVGVybWluYWwucHJvdG90eXBlLmluaXRHbG9iYWw9ZnVuY3Rpb24oKXt2YXIgdGVybT10aGlzO1Rlcm1pbmFsLmJpbmRLZXlzKHRoaXMpO1Rlcm1pbmFsLmJpbmRGb2N1cyh0aGlzKTtUZXJtaW5hbC5iaW5kQmx1cih0aGlzKTsvLyBCaW5kIGNsaXBib2FyZCBmdW5jdGlvbmFsaXR5XG5vbih0aGlzLmVsZW1lbnQsJ2NvcHknLF9DbGlwYm9hcmQuY29weUhhbmRsZXIpO29uKHRoaXMudGV4dGFyZWEsJ3Bhc3RlJyxmdW5jdGlvbihldil7X0NsaXBib2FyZC5wYXN0ZUhhbmRsZXIuY2FsbCh0aGlzLGV2LHRlcm0pO30pO29uKHRoaXMuZWxlbWVudCwnY29udGV4dG1lbnUnLGZ1bmN0aW9uKGV2KXtfQ2xpcGJvYXJkLnJpZ2h0Q2xpY2tIYW5kbGVyLmNhbGwodGhpcyxldix0ZXJtKTt9KTt9Oy8qKlxuICogQXBwbHkga2V5IGhhbmRsaW5nIHRvIHRoZSB0ZXJtaW5hbFxuICovVGVybWluYWwuYmluZEtleXM9ZnVuY3Rpb24odGVybSl7b24odGVybS5lbGVtZW50LCdrZXlkb3duJyxmdW5jdGlvbihldil7aWYoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCE9dGhpcyl7cmV0dXJuO310ZXJtLmtleURvd24oZXYpO30sdHJ1ZSk7b24odGVybS5lbGVtZW50LCdrZXlwcmVzcycsZnVuY3Rpb24oZXYpe2lmKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQhPXRoaXMpe3JldHVybjt9dGVybS5rZXlQcmVzcyhldik7fSx0cnVlKTtvbih0ZXJtLmVsZW1lbnQsJ2tleXVwJyx0ZXJtLmZvY3VzLmJpbmQodGVybSkpO29uKHRlcm0udGV4dGFyZWEsJ2tleWRvd24nLGZ1bmN0aW9uKGV2KXt0ZXJtLmtleURvd24oZXYpO30sdHJ1ZSk7b24odGVybS50ZXh0YXJlYSwna2V5cHJlc3MnLGZ1bmN0aW9uKGV2KXt0ZXJtLmtleVByZXNzKGV2KTsvLyBUcnVuY2F0ZSB0aGUgdGV4dGFyZWEncyB2YWx1ZSwgc2luY2UgaXQgaXMgbm90IG5lZWRlZFxudGhpcy52YWx1ZT0nJzt9LHRydWUpO29uKHRlcm0udGV4dGFyZWEsJ2NvbXBvc2l0aW9uc3RhcnQnLHRlcm0uY29tcG9zaXRpb25IZWxwZXIuY29tcG9zaXRpb25zdGFydC5iaW5kKHRlcm0uY29tcG9zaXRpb25IZWxwZXIpKTtvbih0ZXJtLnRleHRhcmVhLCdjb21wb3NpdGlvbnVwZGF0ZScsdGVybS5jb21wb3NpdGlvbkhlbHBlci5jb21wb3NpdGlvbnVwZGF0ZS5iaW5kKHRlcm0uY29tcG9zaXRpb25IZWxwZXIpKTtvbih0ZXJtLnRleHRhcmVhLCdjb21wb3NpdGlvbmVuZCcsdGVybS5jb21wb3NpdGlvbkhlbHBlci5jb21wb3NpdGlvbmVuZC5iaW5kKHRlcm0uY29tcG9zaXRpb25IZWxwZXIpKTt0ZXJtLm9uKCdyZWZyZXNoJyx0ZXJtLmNvbXBvc2l0aW9uSGVscGVyLnVwZGF0ZUNvbXBvc2l0aW9uRWxlbWVudHMuYmluZCh0ZXJtLmNvbXBvc2l0aW9uSGVscGVyKSk7fTsvKipcbiAqIEluc2VydCB0aGUgZ2l2ZW4gcm93IHRvIHRoZSB0ZXJtaW5hbCBvciBwcm9kdWNlIGEgbmV3IG9uZVxuICogaWYgbm8gcm93IGFyZ3VtZW50IGlzIHBhc3NlZC4gUmV0dXJuIHRoZSBpbnNlcnRlZCByb3cuXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSByb3cgKG9wdGlvbmFsKSBUaGUgcm93IHRvIGFwcGVuZCB0byB0aGUgdGVybWluYWwuXG4gKi9UZXJtaW5hbC5wcm90b3R5cGUuaW5zZXJ0Um93PWZ1bmN0aW9uKHJvdyl7aWYoKHR5cGVvZiByb3c9PT0ndW5kZWZpbmVkJz8ndW5kZWZpbmVkJzpfdHlwZW9mKHJvdykpIT0nb2JqZWN0Jyl7cm93PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO310aGlzLnJvd0NvbnRhaW5lci5hcHBlbmRDaGlsZChyb3cpO3RoaXMuY2hpbGRyZW4ucHVzaChyb3cpO3JldHVybiByb3c7fTsvKipcbiAqIE9wZW5zIHRoZSB0ZXJtaW5hbCB3aXRoaW4gYW4gZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJlbnQgVGhlIGVsZW1lbnQgdG8gY3JlYXRlIHRoZSB0ZXJtaW5hbCB3aXRoaW4uXG4gKi9UZXJtaW5hbC5wcm90b3R5cGUub3Blbj1mdW5jdGlvbihwYXJlbnQpe3ZhciBzZWxmPXRoaXMsaT0wLGRpdjt0aGlzLnBhcmVudD1wYXJlbnR8fHRoaXMucGFyZW50O2lmKCF0aGlzLnBhcmVudCl7dGhyb3cgbmV3IEVycm9yKCdUZXJtaW5hbCByZXF1aXJlcyBhIHBhcmVudCBlbGVtZW50LicpO30vLyBHcmFiIGdsb2JhbCBlbGVtZW50c1xudGhpcy5jb250ZXh0PXRoaXMucGFyZW50Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7dGhpcy5kb2N1bWVudD10aGlzLnBhcmVudC5vd25lckRvY3VtZW50O3RoaXMuYm9keT10aGlzLmRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdib2R5JylbMF07Ly8gUGFyc2UgVXNlci1BZ2VudFxuaWYodGhpcy5jb250ZXh0Lm5hdmlnYXRvciYmdGhpcy5jb250ZXh0Lm5hdmlnYXRvci51c2VyQWdlbnQpe3RoaXMuaXNNU0lFPSEhfnRoaXMuY29udGV4dC5uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ01TSUUnKTt9Ly8gRmluZCB0aGUgdXNlcnMgcGxhdGZvcm0uIFdlIHVzZSB0aGlzIHRvIGludGVycHJldCB0aGUgbWV0YSBrZXlcbi8vIGFuZCBJU08gdGhpcmQgbGV2ZWwgc2hpZnRzLlxuLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3EvMTk4Nzc5MjQvNTc3NTk4XG5pZih0aGlzLmNvbnRleHQubmF2aWdhdG9yJiZ0aGlzLmNvbnRleHQubmF2aWdhdG9yLnBsYXRmb3JtKXt0aGlzLmlzTWFjPWNvbnRhaW5zKHRoaXMuY29udGV4dC5uYXZpZ2F0b3IucGxhdGZvcm0sWydNYWNpbnRvc2gnLCdNYWNJbnRlbCcsJ01hY1BQQycsJ01hYzY4SyddKTt0aGlzLmlzSXBhZD10aGlzLmNvbnRleHQubmF2aWdhdG9yLnBsYXRmb3JtPT09J2lQYWQnO3RoaXMuaXNJcGhvbmU9dGhpcy5jb250ZXh0Lm5hdmlnYXRvci5wbGF0Zm9ybT09PSdpUGhvbmUnO3RoaXMuaXNNU1dpbmRvd3M9Y29udGFpbnModGhpcy5jb250ZXh0Lm5hdmlnYXRvci5wbGF0Zm9ybSxbJ1dpbmRvd3MnLCdXaW4xNicsJ1dpbjMyJywnV2luQ0UnXSk7fS8vQ3JlYXRlIG1haW4gZWxlbWVudCBjb250YWluZXJcbnRoaXMuZWxlbWVudD10aGlzLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO3RoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKCd0ZXJtaW5hbCcpO3RoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKCd4dGVybScpO3RoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKCd4dGVybS10aGVtZS0nK3RoaXMudGhlbWUpO3RoaXMuZWxlbWVudC5zdHlsZS5oZWlnaHQ7dGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLDApO3RoaXMudmlld3BvcnRFbGVtZW50PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO3RoaXMudmlld3BvcnRFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ3h0ZXJtLXZpZXdwb3J0Jyk7dGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKHRoaXMudmlld3BvcnRFbGVtZW50KTt0aGlzLnZpZXdwb3J0U2Nyb2xsQXJlYT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTt0aGlzLnZpZXdwb3J0U2Nyb2xsQXJlYS5jbGFzc0xpc3QuYWRkKCd4dGVybS1zY3JvbGwtYXJlYScpO3RoaXMudmlld3BvcnRFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMudmlld3BvcnRTY3JvbGxBcmVhKTsvLyBDcmVhdGUgdGhlIGNvbnRhaW5lciB0aGF0IHdpbGwgaG9sZCB0aGUgbGluZXMgb2YgdGhlIHRlcm1pbmFsIGFuZCB0aGVuXG4vLyBwcm9kdWNlIHRoZSBsaW5lcyB0aGUgbGluZXMuXG50aGlzLnJvd0NvbnRhaW5lcj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTt0aGlzLnJvd0NvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCd4dGVybS1yb3dzJyk7dGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKHRoaXMucm93Q29udGFpbmVyKTt0aGlzLmNoaWxkcmVuPVtdOy8vIENyZWF0ZSB0aGUgY29udGFpbmVyIHRoYXQgd2lsbCBob2xkIGhlbHBlcnMgbGlrZSB0aGUgdGV4dGFyZWEgZm9yXG4vLyBjYXB0dXJpbmcgRE9NIEV2ZW50cy4gVGhlbiBwcm9kdWNlIHRoZSBoZWxwZXJzLlxudGhpcy5oZWxwZXJDb250YWluZXI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7dGhpcy5oZWxwZXJDb250YWluZXIuY2xhc3NMaXN0LmFkZCgneHRlcm0taGVscGVycycpOy8vIFRPRE86IFRoaXMgc2hvdWxkIHByb2JhYmx5IGJlIGluc2VydGVkIG9uY2UgaXQncyBmaWxsZWQgdG8gcHJldmVudCBhbiBhZGRpdGlvbmFsIGxheW91dFxudGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuaGVscGVyQ29udGFpbmVyKTt0aGlzLnRleHRhcmVhPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJyk7dGhpcy50ZXh0YXJlYS5jbGFzc0xpc3QuYWRkKCd4dGVybS1oZWxwZXItdGV4dGFyZWEnKTt0aGlzLnRleHRhcmVhLnNldEF0dHJpYnV0ZSgnYXV0b2NvcnJlY3QnLCdvZmYnKTt0aGlzLnRleHRhcmVhLnNldEF0dHJpYnV0ZSgnYXV0b2NhcGl0YWxpemUnLCdvZmYnKTt0aGlzLnRleHRhcmVhLnNldEF0dHJpYnV0ZSgnc3BlbGxjaGVjaycsJ2ZhbHNlJyk7dGhpcy50ZXh0YXJlYS50YWJJbmRleD0wO3RoaXMudGV4dGFyZWEuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLGZ1bmN0aW9uKCl7c2VsZi5lbWl0KCdmb2N1cycse3Rlcm1pbmFsOnNlbGZ9KTt9KTt0aGlzLnRleHRhcmVhLmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLGZ1bmN0aW9uKCl7c2VsZi5lbWl0KCdibHVyJyx7dGVybWluYWw6c2VsZn0pO30pO3RoaXMuaGVscGVyQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMudGV4dGFyZWEpO3RoaXMuY29tcG9zaXRpb25WaWV3PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO3RoaXMuY29tcG9zaXRpb25WaWV3LmNsYXNzTGlzdC5hZGQoJ2NvbXBvc2l0aW9uLXZpZXcnKTt0aGlzLmNvbXBvc2l0aW9uSGVscGVyPW5ldyBfQ29tcG9zaXRpb25IZWxwZXIuQ29tcG9zaXRpb25IZWxwZXIodGhpcy50ZXh0YXJlYSx0aGlzLmNvbXBvc2l0aW9uVmlldyx0aGlzKTt0aGlzLmhlbHBlckNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmNvbXBvc2l0aW9uVmlldyk7dGhpcy5jaGFyTWVhc3VyZUVsZW1lbnQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7dGhpcy5jaGFyTWVhc3VyZUVsZW1lbnQuY2xhc3NMaXN0LmFkZCgneHRlcm0tY2hhci1tZWFzdXJlLWVsZW1lbnQnKTt0aGlzLmNoYXJNZWFzdXJlRWxlbWVudC5pbm5lckhUTUw9J1cnO3RoaXMuaGVscGVyQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuY2hhck1lYXN1cmVFbGVtZW50KTtmb3IoO2k8dGhpcy5yb3dzO2krKyl7dGhpcy5pbnNlcnRSb3coKTt9dGhpcy5wYXJlbnQuYXBwZW5kQ2hpbGQodGhpcy5lbGVtZW50KTt0aGlzLnZpZXdwb3J0PW5ldyBfVmlld3BvcnQuVmlld3BvcnQodGhpcyx0aGlzLnZpZXdwb3J0RWxlbWVudCx0aGlzLnZpZXdwb3J0U2Nyb2xsQXJlYSx0aGlzLmNoYXJNZWFzdXJlRWxlbWVudCk7Ly8gRHJhdyB0aGUgc2NyZWVuLlxudGhpcy5yZWZyZXNoKDAsdGhpcy5yb3dzLTEpOy8vIEluaXRpYWxpemUgZ2xvYmFsIGFjdGlvbnMgdGhhdFxuLy8gbmVlZCB0byBiZSB0YWtlbiBvbiB0aGUgZG9jdW1lbnQuXG50aGlzLmluaXRHbG9iYWwoKTsvLyBFbnN1cmUgdGhlcmUgaXMgYSBUZXJtaW5hbC5mb2N1cy5cbnRoaXMuZm9jdXMoKTtvbih0aGlzLmVsZW1lbnQsJ2NsaWNrJyxmdW5jdGlvbigpe3ZhciBzZWxlY3Rpb249ZG9jdW1lbnQuZ2V0U2VsZWN0aW9uKCksY29sbGFwc2VkPXNlbGVjdGlvbi5pc0NvbGxhcHNlZCxpc1JhbmdlPXR5cGVvZiBjb2xsYXBzZWQ9PSdib29sZWFuJz8hY29sbGFwc2VkOnNlbGVjdGlvbi50eXBlPT0nUmFuZ2UnO2lmKCFpc1JhbmdlKXtzZWxmLmZvY3VzKCk7fX0pOy8vIExpc3RlbiBmb3IgbW91c2UgZXZlbnRzIGFuZCB0cmFuc2xhdGVcbi8vIHRoZW0gaW50byB0ZXJtaW5hbCBtb3VzZSBwcm90b2NvbHMuXG50aGlzLmJpbmRNb3VzZSgpOy8vIEZpZ3VyZSBvdXQgd2hldGhlciBib2xkbmVzcyBhZmZlY3RzXG4vLyB0aGUgY2hhcmFjdGVyIHdpZHRoIG9mIG1vbm9zcGFjZSBmb250cy5cbmlmKFRlcm1pbmFsLmJyb2tlbkJvbGQ9PW51bGwpe1Rlcm1pbmFsLmJyb2tlbkJvbGQ9aXNCb2xkQnJva2VuKHRoaXMuZG9jdW1lbnQpO310aGlzLmVtaXQoJ29wZW4nKTt9Oy8qKlxuICogQXR0ZW1wdHMgdG8gbG9hZCBhbiBhZGQtb24gdXNpbmcgQ29tbW9uSlMgb3IgUmVxdWlyZUpTICh3aGljaGV2ZXIgaXMgYXZhaWxhYmxlKS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBhZGRvbiBUaGUgbmFtZSBvZiB0aGUgYWRkb24gdG8gbG9hZFxuICogQHN0YXRpY1xuICovVGVybWluYWwubG9hZEFkZG9uPWZ1bmN0aW9uKGFkZG9uLGNhbGxiYWNrKXtpZigodHlwZW9mIGV4cG9ydHM9PT0ndW5kZWZpbmVkJz8ndW5kZWZpbmVkJzpfdHlwZW9mKGV4cG9ydHMpKT09PSdvYmplY3QnJiYodHlwZW9mIG1vZHVsZT09PSd1bmRlZmluZWQnPyd1bmRlZmluZWQnOl90eXBlb2YobW9kdWxlKSk9PT0nb2JqZWN0Jyl7Ly8gQ29tbW9uSlNcbnJldHVybiBfZGVyZXFfKF9fZGlybmFtZSsnLy4uL2FkZG9ucy8nK2FkZG9uKTt9ZWxzZSBpZih0eXBlb2YgZGVmaW5lPT0nZnVuY3Rpb24nKXsvLyBSZXF1aXJlSlNcbnJldHVybiBfZGVyZXFfKFsnLi4vYWRkb25zLycrYWRkb24rJy8nK2FkZG9uXSxjYWxsYmFjayk7fWVsc2V7Y29uc29sZS5lcnJvcignQ2Fubm90IGxvYWQgYSBtb2R1bGUgd2l0aG91dCBhIENvbW1vbkpTIG9yIFJlcXVpcmVKUyBlbnZpcm9ubWVudC4nKTtyZXR1cm4gZmFsc2U7fX07LyoqXG4gKiBYVGVybSBtb3VzZSBldmVudHNcbiAqIGh0dHA6Ly9pbnZpc2libGUtaXNsYW5kLm5ldC94dGVybS9jdGxzZXFzL2N0bHNlcXMuaHRtbCNNb3VzZSUyMFRyYWNraW5nXG4gKiBUbyBiZXR0ZXIgdW5kZXJzdGFuZCB0aGVzZVxuICogdGhlIHh0ZXJtIGNvZGUgaXMgdmVyeSBoZWxwZnVsOlxuICogUmVsZXZhbnQgZmlsZXM6XG4gKiAgIGJ1dHRvbi5jLCBjaGFycHJvYy5jLCBtaXNjLmNcbiAqIFJlbGV2YW50IGZ1bmN0aW9ucyBpbiB4dGVybS9idXR0b24uYzpcbiAqICAgQnRuQ29kZSwgRW1pdEJ1dHRvbkNvZGUsIEVkaXRvckJ1dHRvbiwgU2VuZE1vdXNlUG9zaXRpb25cbiAqL1Rlcm1pbmFsLnByb3RvdHlwZS5iaW5kTW91c2U9ZnVuY3Rpb24oKXt2YXIgZWw9dGhpcy5lbGVtZW50LHNlbGY9dGhpcyxwcmVzc2VkPTMyOy8vIG1vdXNldXAsIG1vdXNlZG93biwgd2hlZWxcbi8vIGxlZnQgY2xpY2s6IF5bW00gMzxeW1tNIzM8XG4vLyB3aGVlbCB1cDogXltbTWAzPlxuZnVuY3Rpb24gc2VuZEJ1dHRvbihldil7dmFyIGJ1dHRvbixwb3M7Ly8gZ2V0IHRoZSB4dGVybS1zdHlsZSBidXR0b25cbmJ1dHRvbj1nZXRCdXR0b24oZXYpOy8vIGdldCBtb3VzZSBjb29yZGluYXRlc1xucG9zPWdldENvb3Jkcyhldik7aWYoIXBvcylyZXR1cm47c2VuZEV2ZW50KGJ1dHRvbixwb3MpO3N3aXRjaChldi5vdmVycmlkZVR5cGV8fGV2LnR5cGUpe2Nhc2UnbW91c2Vkb3duJzpwcmVzc2VkPWJ1dHRvbjticmVhaztjYXNlJ21vdXNldXAnOi8vIGtlZXAgaXQgYXQgdGhlIGxlZnRcbi8vIGJ1dHRvbiwganVzdCBpbiBjYXNlLlxucHJlc3NlZD0zMjticmVhaztjYXNlJ3doZWVsJzovLyBub3RoaW5nLiBkb24ndFxuLy8gaW50ZXJmZXJlIHdpdGhcbi8vIGBwcmVzc2VkYC5cbmJyZWFrO319Ly8gbW90aW9uIGV4YW1wbGUgb2YgYSBsZWZ0IGNsaWNrOlxuLy8gXltbTSAzPF5bW01ANDxeW1tNQDU8XltbTUA2PF5bW01ANzxeW1tNIzc8XG5mdW5jdGlvbiBzZW5kTW92ZShldil7dmFyIGJ1dHRvbj1wcmVzc2VkLHBvcztwb3M9Z2V0Q29vcmRzKGV2KTtpZighcG9zKXJldHVybjsvLyBidXR0b25zIG1hcmtlZCBhcyBtb3Rpb25zXG4vLyBhcmUgaW5jcmVtZW50ZWQgYnkgMzJcbmJ1dHRvbis9MzI7c2VuZEV2ZW50KGJ1dHRvbixwb3MpO30vLyBlbmNvZGUgYnV0dG9uIGFuZFxuLy8gcG9zaXRpb24gdG8gY2hhcmFjdGVyc1xuZnVuY3Rpb24gZW5jb2RlKGRhdGEsY2gpe2lmKCFzZWxmLnV0Zk1vdXNlKXtpZihjaD09PTI1NSlyZXR1cm4gZGF0YS5wdXNoKDApO2lmKGNoPjEyNyljaD0xMjc7ZGF0YS5wdXNoKGNoKTt9ZWxzZXtpZihjaD09PTIwNDcpcmV0dXJuIGRhdGEucHVzaCgwKTtpZihjaDwxMjcpe2RhdGEucHVzaChjaCk7fWVsc2V7aWYoY2g+MjA0NyljaD0yMDQ3O2RhdGEucHVzaCgweEMwfGNoPj42KTtkYXRhLnB1c2goMHg4MHxjaCYweDNGKTt9fX0vLyBzZW5kIGEgbW91c2UgZXZlbnQ6XG4vLyByZWd1bGFyL3V0Zjg6IF5bW00gQ2IgQ3ggQ3lcbi8vIHVyeHZ0OiBeW1sgQ2IgOyBDeCA7IEN5IE1cbi8vIHNncjogXltbIENiIDsgQ3ggOyBDeSBNL21cbi8vIHZ0MzAwOiBeW1sgMjQoMS8zLzUpfiBbIEN4ICwgQ3kgXSBcXHJcbi8vIGxvY2F0b3I6IENTSSBQIGUgOyBQIGIgOyBQIHIgOyBQIGMgOyBQIHAgJiB3XG5mdW5jdGlvbiBzZW5kRXZlbnQoYnV0dG9uLHBvcyl7Ly8gc2VsZi5lbWl0KCdtb3VzZScsIHtcbi8vICAgeDogcG9zLnggLSAzMixcbi8vICAgeTogcG9zLnggLSAzMixcbi8vICAgYnV0dG9uOiBidXR0b25cbi8vIH0pO1xuaWYoc2VsZi52dDMwME1vdXNlKXsvLyBOT1RFOiBVbnN0YWJsZS5cbi8vIGh0dHA6Ly93d3cudnQxMDAubmV0L2RvY3MvdnQzeHgtZ3AvY2hhcHRlcjE1Lmh0bWxcbmJ1dHRvbiY9Mztwb3MueC09MzI7cG9zLnktPTMyO3ZhciBkYXRhPSdcXHgxYlsyNCc7aWYoYnV0dG9uPT09MClkYXRhKz0nMSc7ZWxzZSBpZihidXR0b249PT0xKWRhdGErPSczJztlbHNlIGlmKGJ1dHRvbj09PTIpZGF0YSs9JzUnO2Vsc2UgaWYoYnV0dG9uPT09MylyZXR1cm47ZWxzZSBkYXRhKz0nMCc7ZGF0YSs9J35bJytwb3MueCsnLCcrcG9zLnkrJ11cXHInO3NlbGYuc2VuZChkYXRhKTtyZXR1cm47fWlmKHNlbGYuZGVjTG9jYXRvcil7Ly8gTk9URTogVW5zdGFibGUuXG5idXR0b24mPTM7cG9zLngtPTMyO3Bvcy55LT0zMjtpZihidXR0b249PT0wKWJ1dHRvbj0yO2Vsc2UgaWYoYnV0dG9uPT09MSlidXR0b249NDtlbHNlIGlmKGJ1dHRvbj09PTIpYnV0dG9uPTY7ZWxzZSBpZihidXR0b249PT0zKWJ1dHRvbj0zO3NlbGYuc2VuZCgnXFx4MWJbJytidXR0b24rJzsnKyhidXR0b249PT0zPzQ6MCkrJzsnK3Bvcy55Kyc7Jytwb3MueCsnOycrKHBvcy5wYWdlfHwwKSsnJncnKTtyZXR1cm47fWlmKHNlbGYudXJ4dnRNb3VzZSl7cG9zLngtPTMyO3Bvcy55LT0zMjtwb3MueCsrO3Bvcy55Kys7c2VsZi5zZW5kKCdcXHgxYlsnK2J1dHRvbisnOycrcG9zLngrJzsnK3Bvcy55KydNJyk7cmV0dXJuO31pZihzZWxmLnNnck1vdXNlKXtwb3MueC09MzI7cG9zLnktPTMyO3NlbGYuc2VuZCgnXFx4MWJbPCcrKChidXR0b24mMyk9PT0zP2J1dHRvbiZ+MzpidXR0b24pKyc7Jytwb3MueCsnOycrcG9zLnkrKChidXR0b24mMyk9PT0zPydtJzonTScpKTtyZXR1cm47fXZhciBkYXRhPVtdO2VuY29kZShkYXRhLGJ1dHRvbik7ZW5jb2RlKGRhdGEscG9zLngpO2VuY29kZShkYXRhLHBvcy55KTtzZWxmLnNlbmQoJ1xceDFiW00nK1N0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLGRhdGEpKTt9ZnVuY3Rpb24gZ2V0QnV0dG9uKGV2KXt2YXIgYnV0dG9uLHNoaWZ0LG1ldGEsY3RybCxtb2Q7Ly8gdHdvIGxvdyBiaXRzOlxuLy8gMCA9IGxlZnRcbi8vIDEgPSBtaWRkbGVcbi8vIDIgPSByaWdodFxuLy8gMyA9IHJlbGVhc2Vcbi8vIHdoZWVsIHVwL2Rvd246XG4vLyAxLCBhbmQgMiAtIHdpdGggNjQgYWRkZWRcbnN3aXRjaChldi5vdmVycmlkZVR5cGV8fGV2LnR5cGUpe2Nhc2UnbW91c2Vkb3duJzpidXR0b249ZXYuYnV0dG9uIT1udWxsPytldi5idXR0b246ZXYud2hpY2ghPW51bGw/ZXYud2hpY2gtMTpudWxsO2lmKHNlbGYuaXNNU0lFKXtidXR0b249YnV0dG9uPT09MT8wOmJ1dHRvbj09PTQ/MTpidXR0b247fWJyZWFrO2Nhc2UnbW91c2V1cCc6YnV0dG9uPTM7YnJlYWs7Y2FzZSdET01Nb3VzZVNjcm9sbCc6YnV0dG9uPWV2LmRldGFpbDwwPzY0OjY1O2JyZWFrO2Nhc2Und2hlZWwnOmJ1dHRvbj1ldi53aGVlbERlbHRhWT4wPzY0OjY1O2JyZWFrO30vLyBuZXh0IHRocmVlIGJpdHMgYXJlIHRoZSBtb2RpZmllcnM6XG4vLyA0ID0gc2hpZnQsIDggPSBtZXRhLCAxNiA9IGNvbnRyb2xcbnNoaWZ0PWV2LnNoaWZ0S2V5PzQ6MDttZXRhPWV2Lm1ldGFLZXk/ODowO2N0cmw9ZXYuY3RybEtleT8xNjowO21vZD1zaGlmdHxtZXRhfGN0cmw7Ly8gbm8gbW9kc1xuaWYoc2VsZi52dDIwME1vdXNlKXsvLyBjdHJsIG9ubHlcbm1vZCY9Y3RybDt9ZWxzZSBpZighc2VsZi5ub3JtYWxNb3VzZSl7bW9kPTA7fS8vIGluY3JlbWVudCB0byBTUFxuYnV0dG9uPTMyKyhtb2Q8PDIpK2J1dHRvbjtyZXR1cm4gYnV0dG9uO30vLyBtb3VzZSBjb29yZGluYXRlcyBtZWFzdXJlZCBpbiBjb2xzL3Jvd3NcbmZ1bmN0aW9uIGdldENvb3Jkcyhldil7dmFyIHgseSx3LGgsZWw7Ly8gaWdub3JlIGJyb3dzZXJzIHdpdGhvdXQgcGFnZVggZm9yIG5vd1xuaWYoZXYucGFnZVg9PW51bGwpcmV0dXJuO3g9ZXYucGFnZVg7eT1ldi5wYWdlWTtlbD1zZWxmLmVsZW1lbnQ7Ly8gc2hvdWxkIHByb2JhYmx5IGNoZWNrIG9mZnNldFBhcmVudFxuLy8gYnV0IHRoaXMgaXMgbW9yZSBwb3J0YWJsZVxud2hpbGUoZWwmJmVsIT09c2VsZi5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpe3gtPWVsLm9mZnNldExlZnQ7eS09ZWwub2Zmc2V0VG9wO2VsPSdvZmZzZXRQYXJlbnQnaW4gZWw/ZWwub2Zmc2V0UGFyZW50OmVsLnBhcmVudE5vZGU7fS8vIGNvbnZlcnQgdG8gY29scy9yb3dzXG53PXNlbGYuZWxlbWVudC5jbGllbnRXaWR0aDtoPXNlbGYuZWxlbWVudC5jbGllbnRIZWlnaHQ7eD1NYXRoLmNlaWwoeC93KnNlbGYuY29scyk7eT1NYXRoLmNlaWwoeS9oKnNlbGYucm93cyk7Ly8gYmUgc3VyZSB0byBhdm9pZCBzZW5kaW5nXG4vLyBiYWQgcG9zaXRpb25zIHRvIHRoZSBwcm9ncmFtXG5pZih4PDApeD0wO2lmKHg+c2VsZi5jb2xzKXg9c2VsZi5jb2xzO2lmKHk8MCl5PTA7aWYoeT5zZWxmLnJvd3MpeT1zZWxmLnJvd3M7Ly8geHRlcm0gc2VuZHMgcmF3IGJ5dGVzIGFuZFxuLy8gc3RhcnRzIGF0IDMyIChTUCkgZm9yIGVhY2guXG54Kz0zMjt5Kz0zMjtyZXR1cm57eDp4LHk6eSx0eXBlOid3aGVlbCd9O31vbihlbCwnbW91c2Vkb3duJyxmdW5jdGlvbihldil7aWYoIXNlbGYubW91c2VFdmVudHMpcmV0dXJuOy8vIHNlbmQgdGhlIGJ1dHRvblxuc2VuZEJ1dHRvbihldik7Ly8gZW5zdXJlIGZvY3VzXG5zZWxmLmZvY3VzKCk7Ly8gZml4IGZvciBvZGQgYnVnXG4vL2lmIChzZWxmLnZ0MjAwTW91c2UgJiYgIXNlbGYubm9ybWFsTW91c2UpIHtcbmlmKHNlbGYudnQyMDBNb3VzZSl7ZXYub3ZlcnJpZGVUeXBlPSdtb3VzZXVwJztzZW5kQnV0dG9uKGV2KTtyZXR1cm4gc2VsZi5jYW5jZWwoZXYpO30vLyBiaW5kIGV2ZW50c1xuaWYoc2VsZi5ub3JtYWxNb3VzZSlvbihzZWxmLmRvY3VtZW50LCdtb3VzZW1vdmUnLHNlbmRNb3ZlKTsvLyB4MTAgY29tcGF0aWJpbGl0eSBtb2RlIGNhbid0IHNlbmQgYnV0dG9uIHJlbGVhc2VzXG5pZighc2VsZi54MTBNb3VzZSl7b24oc2VsZi5kb2N1bWVudCwnbW91c2V1cCcsZnVuY3Rpb24gdXAoZXYpe3NlbmRCdXR0b24oZXYpO2lmKHNlbGYubm9ybWFsTW91c2Upb2ZmKHNlbGYuZG9jdW1lbnQsJ21vdXNlbW92ZScsc2VuZE1vdmUpO29mZihzZWxmLmRvY3VtZW50LCdtb3VzZXVwJyx1cCk7cmV0dXJuIHNlbGYuY2FuY2VsKGV2KTt9KTt9cmV0dXJuIHNlbGYuY2FuY2VsKGV2KTt9KTsvL2lmIChzZWxmLm5vcm1hbE1vdXNlKSB7XG4vLyAgb24oc2VsZi5kb2N1bWVudCwgJ21vdXNlbW92ZScsIHNlbmRNb3ZlKTtcbi8vfVxub24oZWwsJ3doZWVsJyxmdW5jdGlvbihldil7aWYoIXNlbGYubW91c2VFdmVudHMpcmV0dXJuO2lmKHNlbGYueDEwTW91c2V8fHNlbGYudnQzMDBNb3VzZXx8c2VsZi5kZWNMb2NhdG9yKXJldHVybjtzZW5kQnV0dG9uKGV2KTtyZXR1cm4gc2VsZi5jYW5jZWwoZXYpO30pOy8vIGFsbG93IHdoZWVsIHNjcm9sbGluZyBpblxuLy8gdGhlIHNoZWxsIGZvciBleGFtcGxlXG5vbihlbCwnd2hlZWwnLGZ1bmN0aW9uKGV2KXtpZihzZWxmLm1vdXNlRXZlbnRzKXJldHVybjtzZWxmLnZpZXdwb3J0Lm9uV2hlZWwoZXYpO3JldHVybiBzZWxmLmNhbmNlbChldik7fSk7fTsvKipcbiAqIERlc3Ryb3lzIHRoZSB0ZXJtaW5hbC5cbiAqL1Rlcm1pbmFsLnByb3RvdHlwZS5kZXN0cm95PWZ1bmN0aW9uKCl7dGhpcy5yZWFkYWJsZT1mYWxzZTt0aGlzLndyaXRhYmxlPWZhbHNlO3RoaXMuX2V2ZW50cz17fTt0aGlzLmhhbmRsZXI9ZnVuY3Rpb24oKXt9O3RoaXMud3JpdGU9ZnVuY3Rpb24oKXt9O2lmKHRoaXMuZWxlbWVudC5wYXJlbnROb2RlKXt0aGlzLmVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmVsZW1lbnQpO30vL3RoaXMuZW1pdCgnY2xvc2UnKTtcbn07LyoqXG4gKiBGbGFncyB1c2VkIHRvIHJlbmRlciB0ZXJtaW5hbCB0ZXh0IHByb3Blcmx5XG4gKi9UZXJtaW5hbC5mbGFncz17Qk9MRDoxLFVOREVSTElORToyLEJMSU5LOjQsSU5WRVJTRTo4LElOVklTSUJMRToxNn07LyoqXG4gKiBSZWZyZXNoZXMgKHJlLXJlbmRlcnMpIHRlcm1pbmFsIGNvbnRlbnQgd2l0aGluIHR3byByb3dzIChpbmNsdXNpdmUpXG4gKlxuICogUmVuZGVyaW5nIEVuZ2luZTpcbiAqXG4gKiBJbiB0aGUgc2NyZWVuIGJ1ZmZlciwgZWFjaCBjaGFyYWN0ZXIgaXMgc3RvcmVkIGFzIGEgYW4gYXJyYXkgd2l0aCBhIGNoYXJhY3RlclxuICogYW5kIGEgMzItYml0IGludGVnZXI6XG4gKiAgIC0gRmlyc3QgdmFsdWU6IGEgdXRmLTE2IGNoYXJhY3Rlci5cbiAqICAgLSBTZWNvbmQgdmFsdWU6XG4gKiAgIC0gTmV4dCA5IGJpdHM6IGJhY2tncm91bmQgY29sb3IgKDAtNTExKS5cbiAqICAgLSBOZXh0IDkgYml0czogZm9yZWdyb3VuZCBjb2xvciAoMC01MTEpLlxuICogICAtIE5leHQgMTQgYml0czogYSBtYXNrIGZvciBtaXNjLiBmbGFnczpcbiAqICAgICAtIDE9Ym9sZFxuICogICAgIC0gMj11bmRlcmxpbmVcbiAqICAgICAtIDQ9YmxpbmtcbiAqICAgICAtIDg9aW52ZXJzZVxuICogICAgIC0gMTY9aW52aXNpYmxlXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSByb3cgdG8gc3RhcnQgZnJvbSAoYmV0d2VlbiAwIGFuZCB0ZXJtaW5hbCdzIGhlaWdodCB0ZXJtaW5hbCAtIDEpXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSByb3cgdG8gZW5kIGF0IChiZXR3ZWVuIGZyb21Sb3cgYW5kIHRlcm1pbmFsJ3MgaGVpZ2h0IHRlcm1pbmFsIC0gMSlcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcXVldWUgV2hldGhlciB0aGUgcmVmcmVzaCBzaG91bGQgcmFuIHJpZ2h0IG5vdyBvciBiZSBxdWV1ZWRcbiAqL1Rlcm1pbmFsLnByb3RvdHlwZS5yZWZyZXNoPWZ1bmN0aW9uKHN0YXJ0LGVuZCxxdWV1ZSl7dmFyIHNlbGY9dGhpczsvLyBxdWV1ZSBkZWZhdWx0cyB0byB0cnVlXG5xdWV1ZT10eXBlb2YgcXVldWU9PSd1bmRlZmluZWQnP3RydWU6cXVldWU7LyoqXG4gICAqIFRoZSByZWZyZXNoIHF1ZXVlIGFsbG93cyByZWZyZXNoIHRvIGV4ZWN1dGUgb25seSBhcHByb3hpbWF0ZWx5IDMwIHRpbWVzIGEgc2Vjb25kLiBGb3JcbiAgICogY29tbWFuZHMgdGhhdCBwYXNzIGEgc2lnbmlmaWNhbnQgYW1vdW50IG9mIG91dHB1dCB0byB0aGUgd3JpdGUgZnVuY3Rpb24sIHRoaXMgcHJldmVudHMgdGhlXG4gICAqIHRlcm1pbmFsIGZyb20gbWF4aW5nIG91dCB0aGUgQ1BVIGFuZCBtYWtpbmcgdGhlIFVJIHVucmVzcG9uc2l2ZS4gV2hpbGUgY29tbWFuZHMgY2FuIHN0aWxsXG4gICAqIHJ1biBiZXlvbmQgd2hhdCB0aGV5IGRvIG9uIHRoZSB0ZXJtaW5hbCwgaXQgaXMgZmFyIGJldHRlciB3aXRoIGEgZGVib3VuY2UgaW4gcGxhY2UgYXNcbiAgICogZXZlcnkgc2luZ2xlIHRlcm1pbmFsIG1hbmlwdWxhdGlvbiBkb2VzIG5vdCBuZWVkIHRvIGJlIGNvbnN0cnVjdGVkIGluIHRoZSBET00uXG4gICAqXG4gICAqIEEgc2lkZS1lZmZlY3Qgb2YgdGhpcyBpcyB0aGF0IGl0IG1ha2VzIF5DIHRvIGludGVycnVwdCBhIHByb2Nlc3Mgc2VlbSBtb3JlIHJlc3BvbnNpdmUuXG4gICAqL2lmKHF1ZXVlKXsvLyBJZiByZWZyZXNoIHNob3VsZCBiZSBxdWV1ZWQsIG9yZGVyIHRoZSByZWZyZXNoIGFuZCByZXR1cm4uXG5pZih0aGlzLl9yZWZyZXNoSXNRdWV1ZWQpey8vIElmIGEgcmVmcmVzaCBoYXMgYWxyZWFkeSBiZWVuIHF1ZXVlZCwganVzdCBvcmRlciBhIGZ1bGwgcmVmcmVzaCBuZXh0XG50aGlzLl9mdWxsUmVmcmVzaE5leHQ9dHJ1ZTt9ZWxzZXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7c2VsZi5yZWZyZXNoKHN0YXJ0LGVuZCxmYWxzZSk7fSwzNCk7dGhpcy5fcmVmcmVzaElzUXVldWVkPXRydWU7fXJldHVybjt9Ly8gSWYgcmVmcmVzaCBzaG91bGQgYmUgcnVuIHJpZ2h0IG5vdyAobm90IGJlIHF1ZXVlZCksIHJlbGVhc2UgdGhlIGxvY2tcbnRoaXMuX3JlZnJlc2hJc1F1ZXVlZD1mYWxzZTsvLyBJZiBtdWx0aXBsZSByZWZyZXNoZXMgd2VyZSByZXF1ZXN0ZWQsIG1ha2UgYSBmdWxsIHJlZnJlc2guXG5pZih0aGlzLl9mdWxsUmVmcmVzaE5leHQpe3N0YXJ0PTA7ZW5kPXRoaXMucm93cy0xO3RoaXMuX2Z1bGxSZWZyZXNoTmV4dD1mYWxzZTsvLyByZXNldCBsb2NrXG59dmFyIHgseSxpLGxpbmUsb3V0LGNoLGNoX3dpZHRoLHdpZHRoLGRhdGEsYXR0cixiZyxmZyxmbGFncyxyb3cscGFyZW50LGZvY3VzZWQ9ZG9jdW1lbnQuYWN0aXZlRWxlbWVudDsvLyBJZiB0aGlzIGlzIGEgYmlnIHJlZnJlc2gsIHJlbW92ZSB0aGUgdGVybWluYWwgcm93cyBmcm9tIHRoZSBET00gZm9yIGZhc3RlciBjYWxjdWxhdGlvbnNcbmlmKGVuZC1zdGFydD49dGhpcy5yb3dzLzIpe3BhcmVudD10aGlzLmVsZW1lbnQucGFyZW50Tm9kZTtpZihwYXJlbnQpe3RoaXMuZWxlbWVudC5yZW1vdmVDaGlsZCh0aGlzLnJvd0NvbnRhaW5lcik7fX13aWR0aD10aGlzLmNvbHM7eT1zdGFydDtpZihlbmQ+PXRoaXMucm93cy5sZW5ndGgpe3RoaXMubG9nKCdgZW5kYCBpcyB0b28gbGFyZ2UuIE1vc3QgbGlrZWx5IGEgYmFkIENTUi4nKTtlbmQ9dGhpcy5yb3dzLmxlbmd0aC0xO31mb3IoO3k8PWVuZDt5Kyspe3Jvdz15K3RoaXMueWRpc3A7bGluZT10aGlzLmxpbmVzW3Jvd107b3V0PScnO2lmKHRoaXMueT09PXktKHRoaXMueWJhc2UtdGhpcy55ZGlzcCkmJnRoaXMuY3Vyc29yU3RhdGUmJiF0aGlzLmN1cnNvckhpZGRlbil7eD10aGlzLng7fWVsc2V7eD0tMTt9YXR0cj10aGlzLmRlZkF0dHI7aT0wO2Zvcig7aTx3aWR0aDtpKyspe2RhdGE9bGluZVtpXVswXTtjaD1saW5lW2ldWzFdO2NoX3dpZHRoPWxpbmVbaV1bMl07aWYoIWNoX3dpZHRoKWNvbnRpbnVlO2lmKGk9PT14KWRhdGE9LTE7aWYoZGF0YSE9PWF0dHIpe2lmKGF0dHIhPT10aGlzLmRlZkF0dHIpe291dCs9Jzwvc3Bhbj4nO31pZihkYXRhIT09dGhpcy5kZWZBdHRyKXtpZihkYXRhPT09LTEpe291dCs9JzxzcGFuIGNsYXNzPVwicmV2ZXJzZS12aWRlbyB0ZXJtaW5hbC1jdXJzb3InO2lmKHRoaXMuY3Vyc29yQmxpbmspe291dCs9JyBibGlua2luZyc7fW91dCs9J1wiPic7fWVsc2V7dmFyIGNsYXNzTmFtZXM9W107Ymc9ZGF0YSYweDFmZjtmZz1kYXRhPj45JjB4MWZmO2ZsYWdzPWRhdGE+PjE4O2lmKGZsYWdzJlRlcm1pbmFsLmZsYWdzLkJPTEQpe2lmKCFUZXJtaW5hbC5icm9rZW5Cb2xkKXtjbGFzc05hbWVzLnB1c2goJ3h0ZXJtLWJvbGQnKTt9Ly8gU2VlOiBYVGVybSpib2xkQ29sb3JzXG5pZihmZzw4KWZnKz04O31pZihmbGFncyZUZXJtaW5hbC5mbGFncy5VTkRFUkxJTkUpe2NsYXNzTmFtZXMucHVzaCgneHRlcm0tdW5kZXJsaW5lJyk7fWlmKGZsYWdzJlRlcm1pbmFsLmZsYWdzLkJMSU5LKXtjbGFzc05hbWVzLnB1c2goJ3h0ZXJtLWJsaW5rJyk7fS8vIElmIGludmVyc2UgZmxhZyBpcyBvbiwgdGhlbiBzd2FwIHRoZSBmb3JlZ3JvdW5kIGFuZCBiYWNrZ3JvdW5kIHZhcmlhYmxlcy5cbmlmKGZsYWdzJlRlcm1pbmFsLmZsYWdzLklOVkVSU0Upey8qIE9uZS1saW5lIHZhcmlhYmxlIHN3YXAgaW4gSmF2YVNjcmlwdDogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTYyMDE3MzAgKi9iZz1bZmcsZmc9YmddWzBdOy8vIFNob3VsZCBpbnZlcnNlIGp1c3QgYmUgYmVmb3JlIHRoZVxuLy8gYWJvdmUgYm9sZENvbG9ycyBlZmZlY3QgaW5zdGVhZD9cbmlmKGZsYWdzJjEmJmZnPDgpZmcrPTg7fWlmKGZsYWdzJlRlcm1pbmFsLmZsYWdzLklOVklTSUJMRSl7Y2xhc3NOYW1lcy5wdXNoKCd4dGVybS1oaWRkZW4nKTt9LyoqXG4gICAgICAgICAgICAgKiBXZWlyZCBzaXR1YXRpb246IEludmVydCBmbGFnIHVzZWQgYmxhY2sgZm9yZWdyb3VuZCBhbmQgd2hpdGUgYmFja2dyb3VuZCByZXN1bHRzXG4gICAgICAgICAgICAgKiBpbiBpbnZhbGlkIGJhY2tncm91bmQgY29sb3IsIHBvc2l0aW9uZWQgYXQgdGhlIDI1NiBpbmRleCBvZiB0aGUgMjU2IHRlcm1pbmFsXG4gICAgICAgICAgICAgKiBjb2xvciBtYXAuIFBpbiB0aGUgY29sb3JzIG1hbnVhbGx5IGluIHN1Y2ggYSBjYXNlLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIFNvdXJjZTogaHR0cHM6Ly9naXRodWIuY29tL3NvdXJjZWxhaXIveHRlcm0uanMvaXNzdWVzLzU3XG4gICAgICAgICAgICAgKi9pZihmbGFncyZUZXJtaW5hbC5mbGFncy5JTlZFUlNFKXtpZihiZz09MjU3KXtiZz0xNTt9aWYoZmc9PTI1Nil7Zmc9MDt9fWlmKGJnPDI1Nil7Y2xhc3NOYW1lcy5wdXNoKCd4dGVybS1iZy1jb2xvci0nK2JnKTt9aWYoZmc8MjU2KXtjbGFzc05hbWVzLnB1c2goJ3h0ZXJtLWNvbG9yLScrZmcpO31vdXQrPSc8c3Bhbic7aWYoY2xhc3NOYW1lcy5sZW5ndGgpe291dCs9JyBjbGFzcz1cIicrY2xhc3NOYW1lcy5qb2luKCcgJykrJ1wiJzt9b3V0Kz0nPic7fX19c3dpdGNoKGNoKXtjYXNlJyYnOm91dCs9JyZhbXA7JzticmVhaztjYXNlJzwnOm91dCs9JyZsdDsnO2JyZWFrO2Nhc2UnPic6b3V0Kz0nJmd0Oyc7YnJlYWs7ZGVmYXVsdDppZihjaDw9JyAnKXtvdXQrPScmbmJzcDsnO31lbHNle291dCs9Y2g7fWJyZWFrO31hdHRyPWRhdGE7fWlmKGF0dHIhPT10aGlzLmRlZkF0dHIpe291dCs9Jzwvc3Bhbj4nO310aGlzLmNoaWxkcmVuW3ldLmlubmVySFRNTD1vdXQ7fWlmKHBhcmVudCl7dGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKHRoaXMucm93Q29udGFpbmVyKTt9dGhpcy5lbWl0KCdyZWZyZXNoJyx7ZWxlbWVudDp0aGlzLmVsZW1lbnQsc3RhcnQ6c3RhcnQsZW5kOmVuZH0pO307LyoqXG4gKiBEaXNwbGF5IHRoZSBjdXJzb3IgZWxlbWVudFxuICovVGVybWluYWwucHJvdG90eXBlLnNob3dDdXJzb3I9ZnVuY3Rpb24oKXtpZighdGhpcy5jdXJzb3JTdGF0ZSl7dGhpcy5jdXJzb3JTdGF0ZT0xO3RoaXMucmVmcmVzaCh0aGlzLnksdGhpcy55KTt9fTsvKipcbiAqIFNjcm9sbCB0aGUgdGVybWluYWxcbiAqL1Rlcm1pbmFsLnByb3RvdHlwZS5zY3JvbGw9ZnVuY3Rpb24oKXt2YXIgcm93O2lmKCsrdGhpcy55YmFzZT09PXRoaXMuc2Nyb2xsYmFjayl7dGhpcy55YmFzZT10aGlzLnliYXNlLzJ8MDt0aGlzLmxpbmVzPXRoaXMubGluZXMuc2xpY2UoLSh0aGlzLnliYXNlK3RoaXMucm93cykrMSk7fXRoaXMueWRpc3A9dGhpcy55YmFzZTsvLyBsYXN0IGxpbmVcbnJvdz10aGlzLnliYXNlK3RoaXMucm93cy0xOy8vIHN1YnRyYWN0IHRoZSBib3R0b20gc2Nyb2xsIHJlZ2lvblxucm93LT10aGlzLnJvd3MtMS10aGlzLnNjcm9sbEJvdHRvbTtpZihyb3c9PT10aGlzLmxpbmVzLmxlbmd0aCl7Ly8gcG90ZW50aWFsIG9wdGltaXphdGlvbjpcbi8vIHB1c2hpbmcgaXMgZmFzdGVyIHRoYW4gc3BsaWNpbmdcbi8vIHdoZW4gdGhleSBhbW91bnQgdG8gdGhlIHNhbWVcbi8vIGJlaGF2aW9yLlxudGhpcy5saW5lcy5wdXNoKHRoaXMuYmxhbmtMaW5lKCkpO31lbHNley8vIGFkZCBvdXIgbmV3IGxpbmVcbnRoaXMubGluZXMuc3BsaWNlKHJvdywwLHRoaXMuYmxhbmtMaW5lKCkpO31pZih0aGlzLnNjcm9sbFRvcCE9PTApe2lmKHRoaXMueWJhc2UhPT0wKXt0aGlzLnliYXNlLS07dGhpcy55ZGlzcD10aGlzLnliYXNlO310aGlzLmxpbmVzLnNwbGljZSh0aGlzLnliYXNlK3RoaXMuc2Nyb2xsVG9wLDEpO30vLyB0aGlzLm1heFJhbmdlKCk7XG50aGlzLnVwZGF0ZVJhbmdlKHRoaXMuc2Nyb2xsVG9wKTt0aGlzLnVwZGF0ZVJhbmdlKHRoaXMuc2Nyb2xsQm90dG9tKTt0aGlzLmVtaXQoJ3Njcm9sbCcsdGhpcy55ZGlzcCk7fTsvKipcbiAqIFNjcm9sbCB0aGUgZGlzcGxheSBvZiB0aGUgdGVybWluYWxcbiAqIEBwYXJhbSB7bnVtYmVyfSBkaXNwIFRoZSBudW1iZXIgb2YgbGluZXMgdG8gc2Nyb2xsIGRvd24gKG5lZ2F0aXZlcyBzY3JvbGwgdXApLlxuICogQHBhcmFtIHtib29sZWFufSBzdXBwcmVzc1Njcm9sbEV2ZW50IERvbid0IGVtaXQgdGhlIHNjcm9sbCBldmVudCBhcyBzY3JvbGxEaXNwLiBUaGlzIGlzIHVzZWRcbiAqIHRvIGF2b2lkIHVud2FudGVkIGV2ZW50cyBiZWluZyBoYW5kbGVkIGJ5IHRoZSB2ZWl3cG9ydCB3aGVuIHRoZSBldmVudCB3YXMgdHJpZ2dlcmVkIGZyb20gdGhlXG4gKiB2aWV3cG9ydCBvcmlnaW5hbGx5LlxuICovVGVybWluYWwucHJvdG90eXBlLnNjcm9sbERpc3A9ZnVuY3Rpb24oZGlzcCxzdXBwcmVzc1Njcm9sbEV2ZW50KXt0aGlzLnlkaXNwKz1kaXNwO2lmKHRoaXMueWRpc3A+dGhpcy55YmFzZSl7dGhpcy55ZGlzcD10aGlzLnliYXNlO31lbHNlIGlmKHRoaXMueWRpc3A8MCl7dGhpcy55ZGlzcD0wO31pZighc3VwcHJlc3NTY3JvbGxFdmVudCl7dGhpcy5lbWl0KCdzY3JvbGwnLHRoaXMueWRpc3ApO310aGlzLnJlZnJlc2goMCx0aGlzLnJvd3MtMSk7fTsvKipcbiAqIFdyaXRlcyB0ZXh0IHRvIHRoZSB0ZXJtaW5hbC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFRoZSB0ZXh0IHRvIHdyaXRlIHRvIHRoZSB0ZXJtaW5hbC5cbiAqL1Rlcm1pbmFsLnByb3RvdHlwZS53cml0ZT1mdW5jdGlvbihkYXRhKXt2YXIgbD1kYXRhLmxlbmd0aCxpPTAsaixjcyxjaCxjb2RlLGxvdyxjaF93aWR0aCxyb3c7dGhpcy5yZWZyZXNoU3RhcnQ9dGhpcy55O3RoaXMucmVmcmVzaEVuZD10aGlzLnk7aWYodGhpcy55YmFzZSE9PXRoaXMueWRpc3Ape3RoaXMueWRpc3A9dGhpcy55YmFzZTt0aGlzLmVtaXQoJ3Njcm9sbCcsdGhpcy55ZGlzcCk7dGhpcy5tYXhSYW5nZSgpO30vLyBhcHBseSBsZWZ0b3ZlciBzdXJyb2dhdGUgaGlnaCBmcm9tIGxhc3Qgd3JpdGVcbmlmKHRoaXMuc3Vycm9nYXRlX2hpZ2gpe2RhdGE9dGhpcy5zdXJyb2dhdGVfaGlnaCtkYXRhO3RoaXMuc3Vycm9nYXRlX2hpZ2g9Jyc7fWZvcig7aTxsO2krKyl7Y2g9ZGF0YVtpXTsvLyBGSVhNRTogaGlnaGVyIGNoYXJzIHRoYW4gMHhhMCBhcmUgbm90IGFsbG93ZWQgaW4gZXNjYXBlIHNlcXVlbmNlc1xuLy8gICAgICAgIC0tPiBtYXliZSBtb3ZlIHRvIGRlZmF1bHRcbmNvZGU9ZGF0YS5jaGFyQ29kZUF0KGkpO2lmKDB4RDgwMDw9Y29kZSYmY29kZTw9MHhEQkZGKXsvLyB3ZSBnb3QgYSBzdXJyb2dhdGUgaGlnaFxuLy8gZ2V0IHN1cnJvZ2F0ZSBsb3cgKG5leHQgMiBieXRlcylcbmxvdz1kYXRhLmNoYXJDb2RlQXQoaSsxKTtpZihpc05hTihsb3cpKXsvLyBlbmQgb2YgZGF0YSBzdHJlYW0sIHNhdmUgc3Vycm9nYXRlIGhpZ2hcbnRoaXMuc3Vycm9nYXRlX2hpZ2g9Y2g7Y29udGludWU7fWNvZGU9KGNvZGUtMHhEODAwKSoweDQwMCsobG93LTB4REMwMCkrMHgxMDAwMDtjaCs9ZGF0YS5jaGFyQXQoaSsxKTt9Ly8gc3Vycm9nYXRlIGxvdyAtIGFscmVhZHkgaGFuZGxlZCBhYm92ZVxuaWYoMHhEQzAwPD1jb2RlJiZjb2RlPD0weERGRkYpY29udGludWU7c3dpdGNoKHRoaXMuc3RhdGUpe2Nhc2Ugbm9ybWFsOnN3aXRjaChjaCl7Y2FzZSdcXHgwNyc6dGhpcy5iZWxsKCk7YnJlYWs7Ly8gJ1xcbicsICdcXHYnLCAnXFxmJ1xuY2FzZSdcXG4nOmNhc2UnXFx4MGInOmNhc2UnXFx4MGMnOmlmKHRoaXMuY29udmVydEVvbCl7dGhpcy54PTA7fXRoaXMueSsrO2lmKHRoaXMueT50aGlzLnNjcm9sbEJvdHRvbSl7dGhpcy55LS07dGhpcy5zY3JvbGwoKTt9YnJlYWs7Ly8gJ1xccidcbmNhc2UnXFxyJzp0aGlzLng9MDticmVhazsvLyAnXFxiJ1xuY2FzZSdcXHgwOCc6aWYodGhpcy54PjApe3RoaXMueC0tO31icmVhazsvLyAnXFx0J1xuY2FzZSdcXHQnOnRoaXMueD10aGlzLm5leHRTdG9wKCk7YnJlYWs7Ly8gc2hpZnQgb3V0XG5jYXNlJ1xceDBlJzp0aGlzLnNldGdMZXZlbCgxKTticmVhazsvLyBzaGlmdCBpblxuY2FzZSdcXHgwZic6dGhpcy5zZXRnTGV2ZWwoMCk7YnJlYWs7Ly8gJ1xcZSdcbmNhc2UnXFx4MWInOnRoaXMuc3RhdGU9ZXNjYXBlZDticmVhaztkZWZhdWx0Oi8vICcgJ1xuLy8gY2FsY3VsYXRlIHByaW50IHNwYWNlXG4vLyBleHBlbnNpdmUgY2FsbCwgdGhlcmVmb3JlIHdlIHNhdmUgd2lkdGggaW4gbGluZSBidWZmZXJcbmNoX3dpZHRoPXdjd2lkdGgoY29kZSk7aWYoY2g+PScgJyl7aWYodGhpcy5jaGFyc2V0JiZ0aGlzLmNoYXJzZXRbY2hdKXtjaD10aGlzLmNoYXJzZXRbY2hdO31yb3c9dGhpcy55K3RoaXMueWJhc2U7Ly8gaW5zZXJ0IGNvbWJpbmluZyBjaGFyIGluIGxhc3QgY2VsbFxuLy8gRklYTUU6IG5lZWRzIGhhbmRsaW5nIGFmdGVyIGN1cnNvciBqdW1wc1xuaWYoIWNoX3dpZHRoJiZ0aGlzLngpey8vIGRvbnQgb3ZlcmZsb3cgbGVmdFxuaWYodGhpcy5saW5lc1tyb3ddW3RoaXMueC0xXSl7aWYoIXRoaXMubGluZXNbcm93XVt0aGlzLngtMV1bMl0pey8vIGZvdW5kIGVtcHR5IGNlbGwgYWZ0ZXIgZnVsbHdpZHRoLCBuZWVkIHRvIGdvIDIgY2VsbHMgYmFja1xuaWYodGhpcy5saW5lc1tyb3ddW3RoaXMueC0yXSl0aGlzLmxpbmVzW3Jvd11bdGhpcy54LTJdWzFdKz1jaDt9ZWxzZXt0aGlzLmxpbmVzW3Jvd11bdGhpcy54LTFdWzFdKz1jaDt9dGhpcy51cGRhdGVSYW5nZSh0aGlzLnkpO31icmVhazt9Ly8gZ290byBuZXh0IGxpbmUgaWYgY2ggd291bGQgb3ZlcmZsb3dcbi8vIFRPRE86IG5lZWRzIGEgZ2xvYmFsIG1pbiB0ZXJtaW5hbCB3aWR0aCBvZiAyXG5pZih0aGlzLngrY2hfd2lkdGgtMT49dGhpcy5jb2xzKXsvLyBhdXRvd3JhcCAtIERFQ0FXTVxuaWYodGhpcy53cmFwYXJvdW5kTW9kZSl7dGhpcy54PTA7dGhpcy55Kys7aWYodGhpcy55PnRoaXMuc2Nyb2xsQm90dG9tKXt0aGlzLnktLTt0aGlzLnNjcm9sbCgpO319ZWxzZXt0aGlzLng9dGhpcy5jb2xzLTE7aWYoY2hfd2lkdGg9PT0yKS8vIEZJWE1FOiBjaGVjayBmb3IgeHRlcm0gYmVoYXZpb3JcbmNvbnRpbnVlO319cm93PXRoaXMueSt0aGlzLnliYXNlOy8vIGluc2VydCBtb2RlOiBtb3ZlIGNoYXJhY3RlcnMgdG8gcmlnaHRcbmlmKHRoaXMuaW5zZXJ0TW9kZSl7Ly8gZG8gdGhpcyB0d2ljZSBmb3IgYSBmdWxsd2lkdGggY2hhclxuZm9yKHZhciBtb3Zlcz0wO21vdmVzPGNoX3dpZHRoOysrbW92ZXMpey8vIHJlbW92ZSBsYXN0IGNlbGwsIGlmIGl0J3Mgd2lkdGggaXMgMFxuLy8gd2UgaGF2ZSB0byBhZGp1c3QgdGhlIHNlY29uZCBsYXN0IGNlbGwgYXMgd2VsbFxudmFyIHJlbW92ZWQ9dGhpcy5saW5lc1t0aGlzLnkrdGhpcy55YmFzZV0ucG9wKCk7aWYocmVtb3ZlZFsyXT09PTAmJnRoaXMubGluZXNbcm93XVt0aGlzLmNvbHMtMl0mJnRoaXMubGluZXNbcm93XVt0aGlzLmNvbHMtMl1bMl09PT0yKXRoaXMubGluZXNbcm93XVt0aGlzLmNvbHMtMl09W3RoaXMuY3VyQXR0ciwnICcsMV07Ly8gaW5zZXJ0IGVtcHR5IGNlbGwgYXQgY3Vyc29yXG50aGlzLmxpbmVzW3Jvd10uc3BsaWNlKHRoaXMueCwwLFt0aGlzLmN1ckF0dHIsJyAnLDFdKTt9fXRoaXMubGluZXNbcm93XVt0aGlzLnhdPVt0aGlzLmN1ckF0dHIsY2gsY2hfd2lkdGhdO3RoaXMueCsrO3RoaXMudXBkYXRlUmFuZ2UodGhpcy55KTsvLyBmdWxsd2lkdGggY2hhciAtIHNldCBuZXh0IGNlbGwgd2lkdGggdG8gemVybyBhbmQgYWR2YW5jZSBjdXJzb3JcbmlmKGNoX3dpZHRoPT09Mil7dGhpcy5saW5lc1tyb3ddW3RoaXMueF09W3RoaXMuY3VyQXR0ciwnJywwXTt0aGlzLngrKzt9fWJyZWFrO31icmVhaztjYXNlIGVzY2FwZWQ6c3dpdGNoKGNoKXsvLyBFU0MgWyBDb250cm9sIFNlcXVlbmNlIEludHJvZHVjZXIgKCBDU0kgaXMgMHg5YikuXG5jYXNlJ1snOnRoaXMucGFyYW1zPVtdO3RoaXMuY3VycmVudFBhcmFtPTA7dGhpcy5zdGF0ZT1jc2k7YnJlYWs7Ly8gRVNDIF0gT3BlcmF0aW5nIFN5c3RlbSBDb21tYW5kICggT1NDIGlzIDB4OWQpLlxuY2FzZSddJzp0aGlzLnBhcmFtcz1bXTt0aGlzLmN1cnJlbnRQYXJhbT0wO3RoaXMuc3RhdGU9b3NjO2JyZWFrOy8vIEVTQyBQIERldmljZSBDb250cm9sIFN0cmluZyAoIERDUyBpcyAweDkwKS5cbmNhc2UnUCc6dGhpcy5wYXJhbXM9W107dGhpcy5jdXJyZW50UGFyYW09MDt0aGlzLnN0YXRlPWRjczticmVhazsvLyBFU0MgXyBBcHBsaWNhdGlvbiBQcm9ncmFtIENvbW1hbmQgKCBBUEMgaXMgMHg5ZikuXG5jYXNlJ18nOnRoaXMuc3RhdGU9aWdub3JlO2JyZWFrOy8vIEVTQyBeIFByaXZhY3kgTWVzc2FnZSAoIFBNIGlzIDB4OWUpLlxuY2FzZSdeJzp0aGlzLnN0YXRlPWlnbm9yZTticmVhazsvLyBFU0MgYyBGdWxsIFJlc2V0IChSSVMpLlxuY2FzZSdjJzp0aGlzLnJlc2V0KCk7YnJlYWs7Ly8gRVNDIEUgTmV4dCBMaW5lICggTkVMIGlzIDB4ODUpLlxuLy8gRVNDIEQgSW5kZXggKCBJTkQgaXMgMHg4NCkuXG5jYXNlJ0UnOnRoaXMueD0wOztjYXNlJ0QnOnRoaXMuaW5kZXgoKTticmVhazsvLyBFU0MgTSBSZXZlcnNlIEluZGV4ICggUkkgaXMgMHg4ZCkuXG5jYXNlJ00nOnRoaXMucmV2ZXJzZUluZGV4KCk7YnJlYWs7Ly8gRVNDICUgU2VsZWN0IGRlZmF1bHQvdXRmLTggY2hhcmFjdGVyIHNldC5cbi8vIEAgPSBkZWZhdWx0LCBHID0gdXRmLThcbmNhc2UnJSc6Ly90aGlzLmNoYXJzZXQgPSBudWxsO1xudGhpcy5zZXRnTGV2ZWwoMCk7dGhpcy5zZXRnQ2hhcnNldCgwLFRlcm1pbmFsLmNoYXJzZXRzLlVTKTt0aGlzLnN0YXRlPW5vcm1hbDtpKys7YnJlYWs7Ly8gRVNDICgsKSwqLCssLSwuIERlc2lnbmF0ZSBHMC1HMiBDaGFyYWN0ZXIgU2V0LlxuY2FzZScoJzovLyA8LS0gdGhpcyBzZWVtcyB0byBnZXQgYWxsIHRoZSBhdHRlbnRpb25cbmNhc2UnKSc6Y2FzZScqJzpjYXNlJysnOmNhc2UnLSc6Y2FzZScuJzpzd2l0Y2goY2gpe2Nhc2UnKCc6dGhpcy5nY2hhcnNldD0wO2JyZWFrO2Nhc2UnKSc6dGhpcy5nY2hhcnNldD0xO2JyZWFrO2Nhc2UnKic6dGhpcy5nY2hhcnNldD0yO2JyZWFrO2Nhc2UnKyc6dGhpcy5nY2hhcnNldD0zO2JyZWFrO2Nhc2UnLSc6dGhpcy5nY2hhcnNldD0xO2JyZWFrO2Nhc2UnLic6dGhpcy5nY2hhcnNldD0yO2JyZWFrO310aGlzLnN0YXRlPWNoYXJzZXQ7YnJlYWs7Ly8gRGVzaWduYXRlIEczIENoYXJhY3RlciBTZXQgKFZUMzAwKS5cbi8vIEEgPSBJU08gTGF0aW4tMSBTdXBwbGVtZW50YWwuXG4vLyBOb3QgaW1wbGVtZW50ZWQuXG5jYXNlJy8nOnRoaXMuZ2NoYXJzZXQ9Mzt0aGlzLnN0YXRlPWNoYXJzZXQ7aS0tO2JyZWFrOy8vIEVTQyBOXG4vLyBTaW5nbGUgU2hpZnQgU2VsZWN0IG9mIEcyIENoYXJhY3RlciBTZXRcbi8vICggU1MyIGlzIDB4OGUpLiBUaGlzIGFmZmVjdHMgbmV4dCBjaGFyYWN0ZXIgb25seS5cbmNhc2UnTic6YnJlYWs7Ly8gRVNDIE9cbi8vIFNpbmdsZSBTaGlmdCBTZWxlY3Qgb2YgRzMgQ2hhcmFjdGVyIFNldFxuLy8gKCBTUzMgaXMgMHg4ZikuIFRoaXMgYWZmZWN0cyBuZXh0IGNoYXJhY3RlciBvbmx5LlxuY2FzZSdPJzpicmVhazsvLyBFU0MgblxuLy8gSW52b2tlIHRoZSBHMiBDaGFyYWN0ZXIgU2V0IGFzIEdMIChMUzIpLlxuY2FzZSduJzp0aGlzLnNldGdMZXZlbCgyKTticmVhazsvLyBFU0Mgb1xuLy8gSW52b2tlIHRoZSBHMyBDaGFyYWN0ZXIgU2V0IGFzIEdMIChMUzMpLlxuY2FzZSdvJzp0aGlzLnNldGdMZXZlbCgzKTticmVhazsvLyBFU0MgfFxuLy8gSW52b2tlIHRoZSBHMyBDaGFyYWN0ZXIgU2V0IGFzIEdSIChMUzNSKS5cbmNhc2UnfCc6dGhpcy5zZXRnTGV2ZWwoMyk7YnJlYWs7Ly8gRVNDIH1cbi8vIEludm9rZSB0aGUgRzIgQ2hhcmFjdGVyIFNldCBhcyBHUiAoTFMyUikuXG5jYXNlJ30nOnRoaXMuc2V0Z0xldmVsKDIpO2JyZWFrOy8vIEVTQyB+XG4vLyBJbnZva2UgdGhlIEcxIENoYXJhY3RlciBTZXQgYXMgR1IgKExTMVIpLlxuY2FzZSd+Jzp0aGlzLnNldGdMZXZlbCgxKTticmVhazsvLyBFU0MgNyBTYXZlIEN1cnNvciAoREVDU0MpLlxuY2FzZSc3Jzp0aGlzLnNhdmVDdXJzb3IoKTt0aGlzLnN0YXRlPW5vcm1hbDticmVhazsvLyBFU0MgOCBSZXN0b3JlIEN1cnNvciAoREVDUkMpLlxuY2FzZSc4Jzp0aGlzLnJlc3RvcmVDdXJzb3IoKTt0aGlzLnN0YXRlPW5vcm1hbDticmVhazsvLyBFU0MgIyAzIERFQyBsaW5lIGhlaWdodC93aWR0aFxuY2FzZScjJzp0aGlzLnN0YXRlPW5vcm1hbDtpKys7YnJlYWs7Ly8gRVNDIEggVGFiIFNldCAoSFRTIGlzIDB4ODgpLlxuY2FzZSdIJzp0aGlzLnRhYlNldCgpO2JyZWFrOy8vIEVTQyA9IEFwcGxpY2F0aW9uIEtleXBhZCAoREVDS1BBTSkuXG5jYXNlJz0nOnRoaXMubG9nKCdTZXJpYWwgcG9ydCByZXF1ZXN0ZWQgYXBwbGljYXRpb24ga2V5cGFkLicpO3RoaXMuYXBwbGljYXRpb25LZXlwYWQ9dHJ1ZTt0aGlzLnZpZXdwb3J0LnN5bmNTY3JvbGxBcmVhKCk7dGhpcy5zdGF0ZT1ub3JtYWw7YnJlYWs7Ly8gRVNDID4gTm9ybWFsIEtleXBhZCAoREVDS1BOTSkuXG5jYXNlJz4nOnRoaXMubG9nKCdTd2l0Y2hpbmcgYmFjayB0byBub3JtYWwga2V5cGFkLicpO3RoaXMuYXBwbGljYXRpb25LZXlwYWQ9ZmFsc2U7dGhpcy52aWV3cG9ydC5zeW5jU2Nyb2xsQXJlYSgpO3RoaXMuc3RhdGU9bm9ybWFsO2JyZWFrO2RlZmF1bHQ6dGhpcy5zdGF0ZT1ub3JtYWw7dGhpcy5lcnJvcignVW5rbm93biBFU0MgY29udHJvbDogJXMuJyxjaCk7YnJlYWs7fWJyZWFrO2Nhc2UgY2hhcnNldDpzd2l0Y2goY2gpe2Nhc2UnMCc6Ly8gREVDIFNwZWNpYWwgQ2hhcmFjdGVyIGFuZCBMaW5lIERyYXdpbmcgU2V0LlxuY3M9VGVybWluYWwuY2hhcnNldHMuU0NMRDticmVhaztjYXNlJ0EnOi8vIFVLXG5jcz1UZXJtaW5hbC5jaGFyc2V0cy5VSzticmVhaztjYXNlJ0InOi8vIFVuaXRlZCBTdGF0ZXMgKFVTQVNDSUkpLlxuY3M9VGVybWluYWwuY2hhcnNldHMuVVM7YnJlYWs7Y2FzZSc0JzovLyBEdXRjaFxuY3M9VGVybWluYWwuY2hhcnNldHMuRHV0Y2g7YnJlYWs7Y2FzZSdDJzovLyBGaW5uaXNoXG5jYXNlJzUnOmNzPVRlcm1pbmFsLmNoYXJzZXRzLkZpbm5pc2g7YnJlYWs7Y2FzZSdSJzovLyBGcmVuY2hcbmNzPVRlcm1pbmFsLmNoYXJzZXRzLkZyZW5jaDticmVhaztjYXNlJ1EnOi8vIEZyZW5jaENhbmFkaWFuXG5jcz1UZXJtaW5hbC5jaGFyc2V0cy5GcmVuY2hDYW5hZGlhbjticmVhaztjYXNlJ0snOi8vIEdlcm1hblxuY3M9VGVybWluYWwuY2hhcnNldHMuR2VybWFuO2JyZWFrO2Nhc2UnWSc6Ly8gSXRhbGlhblxuY3M9VGVybWluYWwuY2hhcnNldHMuSXRhbGlhbjticmVhaztjYXNlJ0UnOi8vIE5vcndlZ2lhbkRhbmlzaFxuY2FzZSc2Jzpjcz1UZXJtaW5hbC5jaGFyc2V0cy5Ob3J3ZWdpYW5EYW5pc2g7YnJlYWs7Y2FzZSdaJzovLyBTcGFuaXNoXG5jcz1UZXJtaW5hbC5jaGFyc2V0cy5TcGFuaXNoO2JyZWFrO2Nhc2UnSCc6Ly8gU3dlZGlzaFxuY2FzZSc3Jzpjcz1UZXJtaW5hbC5jaGFyc2V0cy5Td2VkaXNoO2JyZWFrO2Nhc2UnPSc6Ly8gU3dpc3NcbmNzPVRlcm1pbmFsLmNoYXJzZXRzLlN3aXNzO2JyZWFrO2Nhc2UnLyc6Ly8gSVNPTGF0aW4gKGFjdHVhbGx5IC9BKVxuY3M9VGVybWluYWwuY2hhcnNldHMuSVNPTGF0aW47aSsrO2JyZWFrO2RlZmF1bHQ6Ly8gRGVmYXVsdFxuY3M9VGVybWluYWwuY2hhcnNldHMuVVM7YnJlYWs7fXRoaXMuc2V0Z0NoYXJzZXQodGhpcy5nY2hhcnNldCxjcyk7dGhpcy5nY2hhcnNldD1udWxsO3RoaXMuc3RhdGU9bm9ybWFsO2JyZWFrO2Nhc2Ugb3NjOi8vIE9TQyBQcyA7IFB0IFNUXG4vLyBPU0MgUHMgOyBQdCBCRUxcbi8vICAgU2V0IFRleHQgUGFyYW1ldGVycy5cbmlmKGNoPT09J1xceDFiJ3x8Y2g9PT0nXFx4MDcnKXtpZihjaD09PSdcXHgxYicpaSsrO3RoaXMucGFyYW1zLnB1c2godGhpcy5jdXJyZW50UGFyYW0pO3N3aXRjaCh0aGlzLnBhcmFtc1swXSl7Y2FzZSAwOmNhc2UgMTpjYXNlIDI6aWYodGhpcy5wYXJhbXNbMV0pe3RoaXMudGl0bGU9dGhpcy5wYXJhbXNbMV07dGhpcy5oYW5kbGVUaXRsZSh0aGlzLnRpdGxlKTt9YnJlYWs7Y2FzZSAzOi8vIHNldCBYIHByb3BlcnR5XG5icmVhaztjYXNlIDQ6Y2FzZSA1Oi8vIGNoYW5nZSBkeW5hbWljIGNvbG9yc1xuYnJlYWs7Y2FzZSAxMDpjYXNlIDExOmNhc2UgMTI6Y2FzZSAxMzpjYXNlIDE0OmNhc2UgMTU6Y2FzZSAxNjpjYXNlIDE3OmNhc2UgMTg6Y2FzZSAxOTovLyBjaGFuZ2UgZHluYW1pYyB1aSBjb2xvcnNcbmJyZWFrO2Nhc2UgNDY6Ly8gY2hhbmdlIGxvZyBmaWxlXG5icmVhaztjYXNlIDUwOi8vIGR5bmFtaWMgZm9udFxuYnJlYWs7Y2FzZSA1MTovLyBlbWFjcyBzaGVsbFxuYnJlYWs7Y2FzZSA1MjovLyBtYW5pcHVsYXRlIHNlbGVjdGlvbiBkYXRhXG5icmVhaztjYXNlIDEwNDpjYXNlIDEwNTpjYXNlIDExMDpjYXNlIDExMTpjYXNlIDExMjpjYXNlIDExMzpjYXNlIDExNDpjYXNlIDExNTpjYXNlIDExNjpjYXNlIDExNzpjYXNlIDExODovLyByZXNldCBjb2xvcnNcbmJyZWFrO310aGlzLnBhcmFtcz1bXTt0aGlzLmN1cnJlbnRQYXJhbT0wO3RoaXMuc3RhdGU9bm9ybWFsO31lbHNle2lmKCF0aGlzLnBhcmFtcy5sZW5ndGgpe2lmKGNoPj0nMCcmJmNoPD0nOScpe3RoaXMuY3VycmVudFBhcmFtPXRoaXMuY3VycmVudFBhcmFtKjEwK2NoLmNoYXJDb2RlQXQoMCktNDg7fWVsc2UgaWYoY2g9PT0nOycpe3RoaXMucGFyYW1zLnB1c2godGhpcy5jdXJyZW50UGFyYW0pO3RoaXMuY3VycmVudFBhcmFtPScnO319ZWxzZXt0aGlzLmN1cnJlbnRQYXJhbSs9Y2g7fX1icmVhaztjYXNlIGNzaTovLyAnPycsICc+JywgJyEnXG5pZihjaD09PSc/J3x8Y2g9PT0nPid8fGNoPT09JyEnKXt0aGlzLnByZWZpeD1jaDticmVhazt9Ly8gMCAtIDlcbmlmKGNoPj0nMCcmJmNoPD0nOScpe3RoaXMuY3VycmVudFBhcmFtPXRoaXMuY3VycmVudFBhcmFtKjEwK2NoLmNoYXJDb2RlQXQoMCktNDg7YnJlYWs7fS8vICckJywgJ1wiJywgJyAnLCAnXFwnJ1xuaWYoY2g9PT0nJCd8fGNoPT09J1wiJ3x8Y2g9PT0nICd8fGNoPT09J1xcJycpe3RoaXMucG9zdGZpeD1jaDticmVhazt9dGhpcy5wYXJhbXMucHVzaCh0aGlzLmN1cnJlbnRQYXJhbSk7dGhpcy5jdXJyZW50UGFyYW09MDsvLyAnOydcbmlmKGNoPT09JzsnKWJyZWFrO3RoaXMuc3RhdGU9bm9ybWFsO3N3aXRjaChjaCl7Ly8gQ1NJIFBzIEFcbi8vIEN1cnNvciBVcCBQcyBUaW1lcyAoZGVmYXVsdCA9IDEpIChDVVUpLlxuY2FzZSdBJzp0aGlzLmN1cnNvclVwKHRoaXMucGFyYW1zKTticmVhazsvLyBDU0kgUHMgQlxuLy8gQ3Vyc29yIERvd24gUHMgVGltZXMgKGRlZmF1bHQgPSAxKSAoQ1VEKS5cbmNhc2UnQic6dGhpcy5jdXJzb3JEb3duKHRoaXMucGFyYW1zKTticmVhazsvLyBDU0kgUHMgQ1xuLy8gQ3Vyc29yIEZvcndhcmQgUHMgVGltZXMgKGRlZmF1bHQgPSAxKSAoQ1VGKS5cbmNhc2UnQyc6dGhpcy5jdXJzb3JGb3J3YXJkKHRoaXMucGFyYW1zKTticmVhazsvLyBDU0kgUHMgRFxuLy8gQ3Vyc29yIEJhY2t3YXJkIFBzIFRpbWVzIChkZWZhdWx0ID0gMSkgKENVQikuXG5jYXNlJ0QnOnRoaXMuY3Vyc29yQmFja3dhcmQodGhpcy5wYXJhbXMpO2JyZWFrOy8vIENTSSBQcyA7IFBzIEhcbi8vIEN1cnNvciBQb3NpdGlvbiBbcm93O2NvbHVtbl0gKGRlZmF1bHQgPSBbMSwxXSkgKENVUCkuXG5jYXNlJ0gnOnRoaXMuY3Vyc29yUG9zKHRoaXMucGFyYW1zKTticmVhazsvLyBDU0kgUHMgSiAgRXJhc2UgaW4gRGlzcGxheSAoRUQpLlxuY2FzZSdKJzp0aGlzLmVyYXNlSW5EaXNwbGF5KHRoaXMucGFyYW1zKTticmVhazsvLyBDU0kgUHMgSyAgRXJhc2UgaW4gTGluZSAoRUwpLlxuY2FzZSdLJzp0aGlzLmVyYXNlSW5MaW5lKHRoaXMucGFyYW1zKTticmVhazsvLyBDU0kgUG0gbSAgQ2hhcmFjdGVyIEF0dHJpYnV0ZXMgKFNHUikuXG5jYXNlJ20nOmlmKCF0aGlzLnByZWZpeCl7dGhpcy5jaGFyQXR0cmlidXRlcyh0aGlzLnBhcmFtcyk7fWJyZWFrOy8vIENTSSBQcyBuICBEZXZpY2UgU3RhdHVzIFJlcG9ydCAoRFNSKS5cbmNhc2Unbic6aWYoIXRoaXMucHJlZml4KXt0aGlzLmRldmljZVN0YXR1cyh0aGlzLnBhcmFtcyk7fWJyZWFrOy8qKlxuICAgICAgICAgICAgICogQWRkaXRpb25zXG4gICAgICAgICAgICAgKi8vLyBDU0kgUHMgQFxuLy8gSW5zZXJ0IFBzIChCbGFuaykgQ2hhcmFjdGVyKHMpIChkZWZhdWx0ID0gMSkgKElDSCkuXG5jYXNlJ0AnOnRoaXMuaW5zZXJ0Q2hhcnModGhpcy5wYXJhbXMpO2JyZWFrOy8vIENTSSBQcyBFXG4vLyBDdXJzb3IgTmV4dCBMaW5lIFBzIFRpbWVzIChkZWZhdWx0ID0gMSkgKENOTCkuXG5jYXNlJ0UnOnRoaXMuY3Vyc29yTmV4dExpbmUodGhpcy5wYXJhbXMpO2JyZWFrOy8vIENTSSBQcyBGXG4vLyBDdXJzb3IgUHJlY2VkaW5nIExpbmUgUHMgVGltZXMgKGRlZmF1bHQgPSAxKSAoQ05MKS5cbmNhc2UnRic6dGhpcy5jdXJzb3JQcmVjZWRpbmdMaW5lKHRoaXMucGFyYW1zKTticmVhazsvLyBDU0kgUHMgR1xuLy8gQ3Vyc29yIENoYXJhY3RlciBBYnNvbHV0ZSAgW2NvbHVtbl0gKGRlZmF1bHQgPSBbcm93LDFdKSAoQ0hBKS5cbmNhc2UnRyc6dGhpcy5jdXJzb3JDaGFyQWJzb2x1dGUodGhpcy5wYXJhbXMpO2JyZWFrOy8vIENTSSBQcyBMXG4vLyBJbnNlcnQgUHMgTGluZShzKSAoZGVmYXVsdCA9IDEpIChJTCkuXG5jYXNlJ0wnOnRoaXMuaW5zZXJ0TGluZXModGhpcy5wYXJhbXMpO2JyZWFrOy8vIENTSSBQcyBNXG4vLyBEZWxldGUgUHMgTGluZShzKSAoZGVmYXVsdCA9IDEpIChETCkuXG5jYXNlJ00nOnRoaXMuZGVsZXRlTGluZXModGhpcy5wYXJhbXMpO2JyZWFrOy8vIENTSSBQcyBQXG4vLyBEZWxldGUgUHMgQ2hhcmFjdGVyKHMpIChkZWZhdWx0ID0gMSkgKERDSCkuXG5jYXNlJ1AnOnRoaXMuZGVsZXRlQ2hhcnModGhpcy5wYXJhbXMpO2JyZWFrOy8vIENTSSBQcyBYXG4vLyBFcmFzZSBQcyBDaGFyYWN0ZXIocykgKGRlZmF1bHQgPSAxKSAoRUNIKS5cbmNhc2UnWCc6dGhpcy5lcmFzZUNoYXJzKHRoaXMucGFyYW1zKTticmVhazsvLyBDU0kgUG0gYCAgQ2hhcmFjdGVyIFBvc2l0aW9uIEFic29sdXRlXG4vLyAgIFtjb2x1bW5dIChkZWZhdWx0ID0gW3JvdywxXSkgKEhQQSkuXG5jYXNlJ2AnOnRoaXMuY2hhclBvc0Fic29sdXRlKHRoaXMucGFyYW1zKTticmVhazsvLyAxNDEgNjEgYSAqIEhQUiAtXG4vLyBIb3Jpem9udGFsIFBvc2l0aW9uIFJlbGF0aXZlXG5jYXNlJ2EnOnRoaXMuSFBvc2l0aW9uUmVsYXRpdmUodGhpcy5wYXJhbXMpO2JyZWFrOy8vIENTSSBQIHMgY1xuLy8gU2VuZCBEZXZpY2UgQXR0cmlidXRlcyAoUHJpbWFyeSBEQSkuXG4vLyBDU0kgPiBQIHMgY1xuLy8gU2VuZCBEZXZpY2UgQXR0cmlidXRlcyAoU2Vjb25kYXJ5IERBKVxuY2FzZSdjJzp0aGlzLnNlbmREZXZpY2VBdHRyaWJ1dGVzKHRoaXMucGFyYW1zKTticmVhazsvLyBDU0kgUG0gZFxuLy8gTGluZSBQb3NpdGlvbiBBYnNvbHV0ZSAgW3Jvd10gKGRlZmF1bHQgPSBbMSxjb2x1bW5dKSAoVlBBKS5cbmNhc2UnZCc6dGhpcy5saW5lUG9zQWJzb2x1dGUodGhpcy5wYXJhbXMpO2JyZWFrOy8vIDE0NSA2NSBlICogVlBSIC0gVmVydGljYWwgUG9zaXRpb24gUmVsYXRpdmVcbmNhc2UnZSc6dGhpcy5WUG9zaXRpb25SZWxhdGl2ZSh0aGlzLnBhcmFtcyk7YnJlYWs7Ly8gQ1NJIFBzIDsgUHMgZlxuLy8gICBIb3Jpem9udGFsIGFuZCBWZXJ0aWNhbCBQb3NpdGlvbiBbcm93O2NvbHVtbl0gKGRlZmF1bHQgPVxuLy8gICBbMSwxXSkgKEhWUCkuXG5jYXNlJ2YnOnRoaXMuSFZQb3NpdGlvbih0aGlzLnBhcmFtcyk7YnJlYWs7Ly8gQ1NJIFBtIGggIFNldCBNb2RlIChTTSkuXG4vLyBDU0kgPyBQbSBoIC0gbW91c2UgZXNjYXBlIGNvZGVzLCBjdXJzb3IgZXNjYXBlIGNvZGVzXG5jYXNlJ2gnOnRoaXMuc2V0TW9kZSh0aGlzLnBhcmFtcyk7YnJlYWs7Ly8gQ1NJIFBtIGwgIFJlc2V0IE1vZGUgKFJNKS5cbi8vIENTSSA/IFBtIGxcbmNhc2UnbCc6dGhpcy5yZXNldE1vZGUodGhpcy5wYXJhbXMpO2JyZWFrOy8vIENTSSBQcyA7IFBzIHJcbi8vICAgU2V0IFNjcm9sbGluZyBSZWdpb24gW3RvcDtib3R0b21dIChkZWZhdWx0ID0gZnVsbCBzaXplIG9mIHdpbi1cbi8vICAgZG93KSAoREVDU1RCTSkuXG4vLyBDU0kgPyBQbSByXG5jYXNlJ3InOnRoaXMuc2V0U2Nyb2xsUmVnaW9uKHRoaXMucGFyYW1zKTticmVhazsvLyBDU0kgc1xuLy8gICBTYXZlIGN1cnNvciAoQU5TSS5TWVMpLlxuY2FzZSdzJzp0aGlzLnNhdmVDdXJzb3IodGhpcy5wYXJhbXMpO2JyZWFrOy8vIENTSSB1XG4vLyAgIFJlc3RvcmUgY3Vyc29yIChBTlNJLlNZUykuXG5jYXNlJ3UnOnRoaXMucmVzdG9yZUN1cnNvcih0aGlzLnBhcmFtcyk7YnJlYWs7LyoqXG4gICAgICAgICAgICAgKiBMZXNzZXIgVXNlZFxuICAgICAgICAgICAgICovLy8gQ1NJIFBzIElcbi8vIEN1cnNvciBGb3J3YXJkIFRhYnVsYXRpb24gUHMgdGFiIHN0b3BzIChkZWZhdWx0ID0gMSkgKENIVCkuXG5jYXNlJ0knOnRoaXMuY3Vyc29yRm9yd2FyZFRhYih0aGlzLnBhcmFtcyk7YnJlYWs7Ly8gQ1NJIFBzIFMgIFNjcm9sbCB1cCBQcyBsaW5lcyAoZGVmYXVsdCA9IDEpIChTVSkuXG5jYXNlJ1MnOnRoaXMuc2Nyb2xsVXAodGhpcy5wYXJhbXMpO2JyZWFrOy8vIENTSSBQcyBUICBTY3JvbGwgZG93biBQcyBsaW5lcyAoZGVmYXVsdCA9IDEpIChTRCkuXG4vLyBDU0kgUHMgOyBQcyA7IFBzIDsgUHMgOyBQcyBUXG4vLyBDU0kgPiBQczsgUHMgVFxuY2FzZSdUJzovLyBpZiAodGhpcy5wcmVmaXggPT09ICc+Jykge1xuLy8gICB0aGlzLnJlc2V0VGl0bGVNb2Rlcyh0aGlzLnBhcmFtcyk7XG4vLyAgIGJyZWFrO1xuLy8gfVxuLy8gaWYgKHRoaXMucGFyYW1zLmxlbmd0aCA+IDIpIHtcbi8vICAgdGhpcy5pbml0TW91c2VUcmFja2luZyh0aGlzLnBhcmFtcyk7XG4vLyAgIGJyZWFrO1xuLy8gfVxuaWYodGhpcy5wYXJhbXMubGVuZ3RoPDImJiF0aGlzLnByZWZpeCl7dGhpcy5zY3JvbGxEb3duKHRoaXMucGFyYW1zKTt9YnJlYWs7Ly8gQ1NJIFBzIFpcbi8vIEN1cnNvciBCYWNrd2FyZCBUYWJ1bGF0aW9uIFBzIHRhYiBzdG9wcyAoZGVmYXVsdCA9IDEpIChDQlQpLlxuY2FzZSdaJzp0aGlzLmN1cnNvckJhY2t3YXJkVGFiKHRoaXMucGFyYW1zKTticmVhazsvLyBDU0kgUHMgYiAgUmVwZWF0IHRoZSBwcmVjZWRpbmcgZ3JhcGhpYyBjaGFyYWN0ZXIgUHMgdGltZXMgKFJFUCkuXG5jYXNlJ2InOnRoaXMucmVwZWF0UHJlY2VkaW5nQ2hhcmFjdGVyKHRoaXMucGFyYW1zKTticmVhazsvLyBDU0kgUHMgZyAgVGFiIENsZWFyIChUQkMpLlxuY2FzZSdnJzp0aGlzLnRhYkNsZWFyKHRoaXMucGFyYW1zKTticmVhazsvLyBDU0kgUG0gaSAgTWVkaWEgQ29weSAoTUMpLlxuLy8gQ1NJID8gUG0gaVxuLy8gY2FzZSAnaSc6XG4vLyAgIHRoaXMubWVkaWFDb3B5KHRoaXMucGFyYW1zKTtcbi8vICAgYnJlYWs7XG4vLyBDU0kgUG0gbSAgQ2hhcmFjdGVyIEF0dHJpYnV0ZXMgKFNHUikuXG4vLyBDU0kgPiBQczsgUHMgbVxuLy8gY2FzZSAnbSc6IC8vIGR1cGxpY2F0ZVxuLy8gICBpZiAodGhpcy5wcmVmaXggPT09ICc+Jykge1xuLy8gICAgIHRoaXMuc2V0UmVzb3VyY2VzKHRoaXMucGFyYW1zKTtcbi8vICAgfSBlbHNlIHtcbi8vICAgICB0aGlzLmNoYXJBdHRyaWJ1dGVzKHRoaXMucGFyYW1zKTtcbi8vICAgfVxuLy8gICBicmVhaztcbi8vIENTSSBQcyBuICBEZXZpY2UgU3RhdHVzIFJlcG9ydCAoRFNSKS5cbi8vIENTSSA+IFBzIG5cbi8vIGNhc2UgJ24nOiAvLyBkdXBsaWNhdGVcbi8vICAgaWYgKHRoaXMucHJlZml4ID09PSAnPicpIHtcbi8vICAgICB0aGlzLmRpc2FibGVNb2RpZmllcnModGhpcy5wYXJhbXMpO1xuLy8gICB9IGVsc2Uge1xuLy8gICAgIHRoaXMuZGV2aWNlU3RhdHVzKHRoaXMucGFyYW1zKTtcbi8vICAgfVxuLy8gICBicmVhaztcbi8vIENTSSA+IFBzIHAgIFNldCBwb2ludGVyIG1vZGUuXG4vLyBDU0kgISBwICAgU29mdCB0ZXJtaW5hbCByZXNldCAoREVDU1RSKS5cbi8vIENTSSBQcyQgcFxuLy8gICBSZXF1ZXN0IEFOU0kgbW9kZSAoREVDUlFNKS5cbi8vIENTSSA/IFBzJCBwXG4vLyAgIFJlcXVlc3QgREVDIHByaXZhdGUgbW9kZSAoREVDUlFNKS5cbi8vIENTSSBQcyA7IFBzIFwiIHBcbmNhc2UncCc6c3dpdGNoKHRoaXMucHJlZml4KXsvLyBjYXNlICc+Jzpcbi8vICAgdGhpcy5zZXRQb2ludGVyTW9kZSh0aGlzLnBhcmFtcyk7XG4vLyAgIGJyZWFrO1xuY2FzZSchJzp0aGlzLnNvZnRSZXNldCh0aGlzLnBhcmFtcyk7YnJlYWs7Ly8gY2FzZSAnPyc6XG4vLyAgIGlmICh0aGlzLnBvc3RmaXggPT09ICckJykge1xuLy8gICAgIHRoaXMucmVxdWVzdFByaXZhdGVNb2RlKHRoaXMucGFyYW1zKTtcbi8vICAgfVxuLy8gICBicmVhaztcbi8vIGRlZmF1bHQ6XG4vLyAgIGlmICh0aGlzLnBvc3RmaXggPT09ICdcIicpIHtcbi8vICAgICB0aGlzLnNldENvbmZvcm1hbmNlTGV2ZWwodGhpcy5wYXJhbXMpO1xuLy8gICB9IGVsc2UgaWYgKHRoaXMucG9zdGZpeCA9PT0gJyQnKSB7XG4vLyAgICAgdGhpcy5yZXF1ZXN0QW5zaU1vZGUodGhpcy5wYXJhbXMpO1xuLy8gICB9XG4vLyAgIGJyZWFrO1xufWJyZWFrOy8vIENTSSBQcyBxICBMb2FkIExFRHMgKERFQ0xMKS5cbi8vIENTSSBQcyBTUCBxXG4vLyBDU0kgUHMgXCIgcVxuLy8gY2FzZSAncSc6XG4vLyAgIGlmICh0aGlzLnBvc3RmaXggPT09ICcgJykge1xuLy8gICAgIHRoaXMuc2V0Q3Vyc29yU3R5bGUodGhpcy5wYXJhbXMpO1xuLy8gICAgIGJyZWFrO1xuLy8gICB9XG4vLyAgIGlmICh0aGlzLnBvc3RmaXggPT09ICdcIicpIHtcbi8vICAgICB0aGlzLnNldENoYXJQcm90ZWN0aW9uQXR0cih0aGlzLnBhcmFtcyk7XG4vLyAgICAgYnJlYWs7XG4vLyAgIH1cbi8vICAgdGhpcy5sb2FkTEVEcyh0aGlzLnBhcmFtcyk7XG4vLyAgIGJyZWFrO1xuLy8gQ1NJIFBzIDsgUHMgclxuLy8gICBTZXQgU2Nyb2xsaW5nIFJlZ2lvbiBbdG9wO2JvdHRvbV0gKGRlZmF1bHQgPSBmdWxsIHNpemUgb2Ygd2luLVxuLy8gICBkb3cpIChERUNTVEJNKS5cbi8vIENTSSA/IFBtIHJcbi8vIENTSSBQdDsgUGw7IFBiOyBQcjsgUHMkIHJcbi8vIGNhc2UgJ3InOiAvLyBkdXBsaWNhdGVcbi8vICAgaWYgKHRoaXMucHJlZml4ID09PSAnPycpIHtcbi8vICAgICB0aGlzLnJlc3RvcmVQcml2YXRlVmFsdWVzKHRoaXMucGFyYW1zKTtcbi8vICAgfSBlbHNlIGlmICh0aGlzLnBvc3RmaXggPT09ICckJykge1xuLy8gICAgIHRoaXMuc2V0QXR0ckluUmVjdGFuZ2xlKHRoaXMucGFyYW1zKTtcbi8vICAgfSBlbHNlIHtcbi8vICAgICB0aGlzLnNldFNjcm9sbFJlZ2lvbih0aGlzLnBhcmFtcyk7XG4vLyAgIH1cbi8vICAgYnJlYWs7XG4vLyBDU0kgcyAgICAgU2F2ZSBjdXJzb3IgKEFOU0kuU1lTKS5cbi8vIENTSSA/IFBtIHNcbi8vIGNhc2UgJ3MnOiAvLyBkdXBsaWNhdGVcbi8vICAgaWYgKHRoaXMucHJlZml4ID09PSAnPycpIHtcbi8vICAgICB0aGlzLnNhdmVQcml2YXRlVmFsdWVzKHRoaXMucGFyYW1zKTtcbi8vICAgfSBlbHNlIHtcbi8vICAgICB0aGlzLnNhdmVDdXJzb3IodGhpcy5wYXJhbXMpO1xuLy8gICB9XG4vLyAgIGJyZWFrO1xuLy8gQ1NJIFBzIDsgUHMgOyBQcyB0XG4vLyBDU0kgUHQ7IFBsOyBQYjsgUHI7IFBzJCB0XG4vLyBDU0kgPiBQczsgUHMgdFxuLy8gQ1NJIFBzIFNQIHRcbi8vIGNhc2UgJ3QnOlxuLy8gICBpZiAodGhpcy5wb3N0Zml4ID09PSAnJCcpIHtcbi8vICAgICB0aGlzLnJldmVyc2VBdHRySW5SZWN0YW5nbGUodGhpcy5wYXJhbXMpO1xuLy8gICB9IGVsc2UgaWYgKHRoaXMucG9zdGZpeCA9PT0gJyAnKSB7XG4vLyAgICAgdGhpcy5zZXRXYXJuaW5nQmVsbFZvbHVtZSh0aGlzLnBhcmFtcyk7XG4vLyAgIH0gZWxzZSB7XG4vLyAgICAgaWYgKHRoaXMucHJlZml4ID09PSAnPicpIHtcbi8vICAgICAgIHRoaXMuc2V0VGl0bGVNb2RlRmVhdHVyZSh0aGlzLnBhcmFtcyk7XG4vLyAgICAgfSBlbHNlIHtcbi8vICAgICAgIHRoaXMubWFuaXB1bGF0ZVdpbmRvdyh0aGlzLnBhcmFtcyk7XG4vLyAgICAgfVxuLy8gICB9XG4vLyAgIGJyZWFrO1xuLy8gQ1NJIHUgICAgIFJlc3RvcmUgY3Vyc29yIChBTlNJLlNZUykuXG4vLyBDU0kgUHMgU1AgdVxuLy8gY2FzZSAndSc6IC8vIGR1cGxpY2F0ZVxuLy8gICBpZiAodGhpcy5wb3N0Zml4ID09PSAnICcpIHtcbi8vICAgICB0aGlzLnNldE1hcmdpbkJlbGxWb2x1bWUodGhpcy5wYXJhbXMpO1xuLy8gICB9IGVsc2Uge1xuLy8gICAgIHRoaXMucmVzdG9yZUN1cnNvcih0aGlzLnBhcmFtcyk7XG4vLyAgIH1cbi8vICAgYnJlYWs7XG4vLyBDU0kgUHQ7IFBsOyBQYjsgUHI7IFBwOyBQdDsgUGw7IFBwJCB2XG4vLyBjYXNlICd2Jzpcbi8vICAgaWYgKHRoaXMucG9zdGZpeCA9PT0gJyQnKSB7XG4vLyAgICAgdGhpcy5jb3B5UmVjdGFnbGUodGhpcy5wYXJhbXMpO1xuLy8gICB9XG4vLyAgIGJyZWFrO1xuLy8gQ1NJIFB0IDsgUGwgOyBQYiA7IFByICcgd1xuLy8gY2FzZSAndyc6XG4vLyAgIGlmICh0aGlzLnBvc3RmaXggPT09ICdcXCcnKSB7XG4vLyAgICAgdGhpcy5lbmFibGVGaWx0ZXJSZWN0YW5nbGUodGhpcy5wYXJhbXMpO1xuLy8gICB9XG4vLyAgIGJyZWFrO1xuLy8gQ1NJIFBzIHggIFJlcXVlc3QgVGVybWluYWwgUGFyYW1ldGVycyAoREVDUkVRVFBBUk0pLlxuLy8gQ1NJIFBzIHggIFNlbGVjdCBBdHRyaWJ1dGUgQ2hhbmdlIEV4dGVudCAoREVDU0FDRSkuXG4vLyBDU0kgUGM7IFB0OyBQbDsgUGI7IFByJCB4XG4vLyBjYXNlICd4Jzpcbi8vICAgaWYgKHRoaXMucG9zdGZpeCA9PT0gJyQnKSB7XG4vLyAgICAgdGhpcy5maWxsUmVjdGFuZ2xlKHRoaXMucGFyYW1zKTtcbi8vICAgfSBlbHNlIHtcbi8vICAgICB0aGlzLnJlcXVlc3RQYXJhbWV0ZXJzKHRoaXMucGFyYW1zKTtcbi8vICAgICAvL3RoaXMuX18odGhpcy5wYXJhbXMpO1xuLy8gICB9XG4vLyAgIGJyZWFrO1xuLy8gQ1NJIFBzIDsgUHUgJyB6XG4vLyBDU0kgUHQ7IFBsOyBQYjsgUHIkIHpcbi8vIGNhc2UgJ3onOlxuLy8gICBpZiAodGhpcy5wb3N0Zml4ID09PSAnXFwnJykge1xuLy8gICAgIHRoaXMuZW5hYmxlTG9jYXRvclJlcG9ydGluZyh0aGlzLnBhcmFtcyk7XG4vLyAgIH0gZWxzZSBpZiAodGhpcy5wb3N0Zml4ID09PSAnJCcpIHtcbi8vICAgICB0aGlzLmVyYXNlUmVjdGFuZ2xlKHRoaXMucGFyYW1zKTtcbi8vICAgfVxuLy8gICBicmVhaztcbi8vIENTSSBQbSAnIHtcbi8vIENTSSBQdDsgUGw7IFBiOyBQciQge1xuLy8gY2FzZSAneyc6XG4vLyAgIGlmICh0aGlzLnBvc3RmaXggPT09ICdcXCcnKSB7XG4vLyAgICAgdGhpcy5zZXRMb2NhdG9yRXZlbnRzKHRoaXMucGFyYW1zKTtcbi8vICAgfSBlbHNlIGlmICh0aGlzLnBvc3RmaXggPT09ICckJykge1xuLy8gICAgIHRoaXMuc2VsZWN0aXZlRXJhc2VSZWN0YW5nbGUodGhpcy5wYXJhbXMpO1xuLy8gICB9XG4vLyAgIGJyZWFrO1xuLy8gQ1NJIFBzICcgfFxuLy8gY2FzZSAnfCc6XG4vLyAgIGlmICh0aGlzLnBvc3RmaXggPT09ICdcXCcnKSB7XG4vLyAgICAgdGhpcy5yZXF1ZXN0TG9jYXRvclBvc2l0aW9uKHRoaXMucGFyYW1zKTtcbi8vICAgfVxuLy8gICBicmVhaztcbi8vIENTSSBQIG0gU1AgfVxuLy8gSW5zZXJ0IFAgcyBDb2x1bW4ocykgKGRlZmF1bHQgPSAxKSAoREVDSUMpLCBWVDQyMCBhbmQgdXAuXG4vLyBjYXNlICd9Jzpcbi8vICAgaWYgKHRoaXMucG9zdGZpeCA9PT0gJyAnKSB7XG4vLyAgICAgdGhpcy5pbnNlcnRDb2x1bW5zKHRoaXMucGFyYW1zKTtcbi8vICAgfVxuLy8gICBicmVhaztcbi8vIENTSSBQIG0gU1AgflxuLy8gRGVsZXRlIFAgcyBDb2x1bW4ocykgKGRlZmF1bHQgPSAxKSAoREVDREMpLCBWVDQyMCBhbmQgdXBcbi8vIGNhc2UgJ34nOlxuLy8gICBpZiAodGhpcy5wb3N0Zml4ID09PSAnICcpIHtcbi8vICAgICB0aGlzLmRlbGV0ZUNvbHVtbnModGhpcy5wYXJhbXMpO1xuLy8gICB9XG4vLyAgIGJyZWFrO1xuZGVmYXVsdDp0aGlzLmVycm9yKCdVbmtub3duIENTSSBjb2RlOiAlcy4nLGNoKTticmVhazt9dGhpcy5wcmVmaXg9Jyc7dGhpcy5wb3N0Zml4PScnO2JyZWFrO2Nhc2UgZGNzOmlmKGNoPT09J1xceDFiJ3x8Y2g9PT0nXFx4MDcnKXtpZihjaD09PSdcXHgxYicpaSsrO3N3aXRjaCh0aGlzLnByZWZpeCl7Ly8gVXNlci1EZWZpbmVkIEtleXMgKERFQ1VESykuXG5jYXNlJyc6YnJlYWs7Ly8gUmVxdWVzdCBTdGF0dXMgU3RyaW5nIChERUNSUVNTKS5cbi8vIHRlc3Q6IGVjaG8gLWUgJ1xcZVAkcVwicFxcZVxcXFwnXG5jYXNlJyRxJzp2YXIgcHQ9dGhpcy5jdXJyZW50UGFyYW0sdmFsaWQ9ZmFsc2U7c3dpdGNoKHB0KXsvLyBERUNTQ0FcbmNhc2UnXCJxJzpwdD0nMFwicSc7YnJlYWs7Ly8gREVDU0NMXG5jYXNlJ1wicCc6cHQ9JzYxXCJwJzticmVhazsvLyBERUNTVEJNXG5jYXNlJ3InOnB0PScnKyh0aGlzLnNjcm9sbFRvcCsxKSsnOycrKHRoaXMuc2Nyb2xsQm90dG9tKzEpKydyJzticmVhazsvLyBTR1JcbmNhc2UnbSc6cHQ9JzBtJzticmVhaztkZWZhdWx0OnRoaXMuZXJyb3IoJ1Vua25vd24gRENTIFB0OiAlcy4nLHB0KTtwdD0nJzticmVhazt9dGhpcy5zZW5kKCdcXHgxYlAnKyArdmFsaWQrJyRyJytwdCsnXFx4MWJcXFxcJyk7YnJlYWs7Ly8gU2V0IFRlcm1jYXAvVGVybWluZm8gRGF0YSAoeHRlcm0sIGV4cGVyaW1lbnRhbCkuXG5jYXNlJytwJzpicmVhazsvLyBSZXF1ZXN0IFRlcm1jYXAvVGVybWluZm8gU3RyaW5nICh4dGVybSwgZXhwZXJpbWVudGFsKVxuLy8gUmVndWxhciB4dGVybSBkb2VzIG5vdCBldmVuIHJlc3BvbmQgdG8gdGhpcyBzZXF1ZW5jZS5cbi8vIFRoaXMgY2FuIGNhdXNlIGEgc21hbGwgZ2xpdGNoIGluIHZpbS5cbi8vIHRlc3Q6IGVjaG8gLW5lICdcXGVQK3E2YjY0XFxlXFxcXCdcbmNhc2UnK3EnOnZhciBwdD10aGlzLmN1cnJlbnRQYXJhbSx2YWxpZD1mYWxzZTt0aGlzLnNlbmQoJ1xceDFiUCcrICt2YWxpZCsnK3InK3B0KydcXHgxYlxcXFwnKTticmVhaztkZWZhdWx0OnRoaXMuZXJyb3IoJ1Vua25vd24gRENTIHByZWZpeDogJXMuJyx0aGlzLnByZWZpeCk7YnJlYWs7fXRoaXMuY3VycmVudFBhcmFtPTA7dGhpcy5wcmVmaXg9Jyc7dGhpcy5zdGF0ZT1ub3JtYWw7fWVsc2UgaWYoIXRoaXMuY3VycmVudFBhcmFtKXtpZighdGhpcy5wcmVmaXgmJmNoIT09JyQnJiZjaCE9PScrJyl7dGhpcy5jdXJyZW50UGFyYW09Y2g7fWVsc2UgaWYodGhpcy5wcmVmaXgubGVuZ3RoPT09Mil7dGhpcy5jdXJyZW50UGFyYW09Y2g7fWVsc2V7dGhpcy5wcmVmaXgrPWNoO319ZWxzZXt0aGlzLmN1cnJlbnRQYXJhbSs9Y2g7fWJyZWFrO2Nhc2UgaWdub3JlOi8vIEZvciBQTSBhbmQgQVBDLlxuaWYoY2g9PT0nXFx4MWInfHxjaD09PSdcXHgwNycpe2lmKGNoPT09J1xceDFiJylpKys7dGhpcy5zdGF0ZT1ub3JtYWw7fWJyZWFrO319dGhpcy51cGRhdGVSYW5nZSh0aGlzLnkpO3RoaXMucmVmcmVzaCh0aGlzLnJlZnJlc2hTdGFydCx0aGlzLnJlZnJlc2hFbmQpO307LyoqXG4gKiBXcml0ZXMgdGV4dCB0byB0aGUgdGVybWluYWwsIGZvbGxvd2VkIGJ5IGEgYnJlYWsgbGluZSBjaGFyYWN0ZXIgKFxcbikuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUaGUgdGV4dCB0byB3cml0ZSB0byB0aGUgdGVybWluYWwuXG4gKi9UZXJtaW5hbC5wcm90b3R5cGUud3JpdGVsbj1mdW5jdGlvbihkYXRhKXt0aGlzLndyaXRlKGRhdGErJ1xcclxcbicpO307LyoqXG4gKiBBdHRhY2hlcyBhIGN1c3RvbSBrZXlkb3duIGhhbmRsZXIgd2hpY2ggaXMgcnVuIGJlZm9yZSBrZXlzIGFyZSBwcm9jZXNzZWQsIGdpdmluZyBjb25zdW1lcnMgb2ZcbiAqIHh0ZXJtLmpzIHVsdGltYXRlIGNvbnRyb2wgYXMgdG8gd2hhdCBrZXlzIHNob3VsZCBiZSBwcm9jZXNzZWQgYnkgdGhlIHRlcm1pbmFsIGFuZCB3aGF0IGtleXNcbiAqIHNob3VsZCBub3QuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjdXN0b21LZXlkb3duSGFuZGxlciBUaGUgY3VzdG9tIEtleWJvYXJkRXZlbnQgaGFuZGxlciB0byBhdHRhY2guIFRoaXMgaXMgYVxuICogICBmdW5jdGlvbiB0aGF0IHRha2VzIGEgS2V5Ym9hcmRFdmVudCwgYWxsb3dpbmcgY29uc3VtZXJzIHRvIHN0b3AgcHJvcG9nYXRpb24gYW5kL29yIHByZXZlbnRcbiAqICAgdGhlIGRlZmF1bHQgYWN0aW9uLiBUaGUgZnVuY3Rpb24gcmV0dXJucyB3aGV0aGVyIHRoZSBldmVudCBzaG91bGQgYmUgcHJvY2Vzc2VkIGJ5IHh0ZXJtLmpzLlxuICovVGVybWluYWwucHJvdG90eXBlLmF0dGFjaEN1c3RvbUtleWRvd25IYW5kbGVyPWZ1bmN0aW9uKGN1c3RvbUtleWRvd25IYW5kbGVyKXt0aGlzLmN1c3RvbUtleWRvd25IYW5kbGVyPWN1c3RvbUtleWRvd25IYW5kbGVyO307LyoqXG4gKiBIYW5kbGUgYSBrZXlkb3duIGV2ZW50XG4gKiBLZXkgUmVzb3VyY2VzOlxuICogICAtIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvRE9NL0tleWJvYXJkRXZlbnRcbiAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZXYgVGhlIGtleWRvd24gZXZlbnQgdG8gYmUgaGFuZGxlZC5cbiAqL1Rlcm1pbmFsLnByb3RvdHlwZS5rZXlEb3duPWZ1bmN0aW9uKGV2KXtpZih0aGlzLmN1c3RvbUtleWRvd25IYW5kbGVyJiZ0aGlzLmN1c3RvbUtleWRvd25IYW5kbGVyKGV2KT09PWZhbHNlKXtyZXR1cm4gZmFsc2U7fWlmKCF0aGlzLmNvbXBvc2l0aW9uSGVscGVyLmtleWRvd24uYmluZCh0aGlzLmNvbXBvc2l0aW9uSGVscGVyKShldikpe3JldHVybiBmYWxzZTt9dmFyIHNlbGY9dGhpczt2YXIgcmVzdWx0PXRoaXMuZXZhbHVhdGVLZXlFc2NhcGVTZXF1ZW5jZShldik7aWYocmVzdWx0LnNjcm9sbERpc3Ape3RoaXMuc2Nyb2xsRGlzcChyZXN1bHQuc2Nyb2xsRGlzcCk7cmV0dXJuIHRoaXMuY2FuY2VsKGV2LHRydWUpO31pZihpc1RoaXJkTGV2ZWxTaGlmdCh0aGlzLGV2KSl7cmV0dXJuIHRydWU7fWlmKHJlc3VsdC5jYW5jZWwpey8vIFRoZSBldmVudCBpcyBjYW5jZWxlZCBhdCB0aGUgZW5kIGFscmVhZHksIGlzIHRoaXMgbmVjZXNzYXJ5P1xudGhpcy5jYW5jZWwoZXYsdHJ1ZSk7fWlmKCFyZXN1bHQua2V5KXtyZXR1cm4gdHJ1ZTt9dGhpcy5lbWl0KCdrZXlkb3duJyxldik7dGhpcy5lbWl0KCdrZXknLHJlc3VsdC5rZXksZXYpO3RoaXMuc2hvd0N1cnNvcigpO3RoaXMuaGFuZGxlcihyZXN1bHQua2V5KTtyZXR1cm4gdGhpcy5jYW5jZWwoZXYsdHJ1ZSk7fTsvKipcbiAqIFJldHVybnMgYW4gb2JqZWN0IHRoYXQgZGV0ZXJtaW5lcyBob3cgYSBLZXlib2FyZEV2ZW50IHNob3VsZCBiZSBoYW5kbGVkLiBUaGUga2V5IG9mIHRoZVxuICogcmV0dXJuZWQgdmFsdWUgaXMgdGhlIG5ldyBrZXkgY29kZSB0byBwYXNzIHRvIHRoZSBQVFkuXG4gKlxuICogUmVmZXJlbmNlOiBodHRwOi8vaW52aXNpYmxlLWlzbGFuZC5uZXQveHRlcm0vY3Rsc2Vxcy9jdGxzZXFzLmh0bWxcbiAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZXYgVGhlIGtleWJvYXJkIGV2ZW50IHRvIGJlIHRyYW5zbGF0ZWQgdG8ga2V5IGVzY2FwZSBzZXF1ZW5jZS5cbiAqL1Rlcm1pbmFsLnByb3RvdHlwZS5ldmFsdWF0ZUtleUVzY2FwZVNlcXVlbmNlPWZ1bmN0aW9uKGV2KXt2YXIgcmVzdWx0PXsvLyBXaGV0aGVyIHRvIGNhbmNlbCBldmVudCBwcm9wb2dhdGlvbiAoTk9URTogdGhpcyBtYXkgbm90IGJlIG5lZWRlZCBzaW5jZSB0aGUgZXZlbnQgaXNcbi8vIGNhbmNlbGVkIGF0IHRoZSBlbmQgb2Yga2V5RG93blxuY2FuY2VsOmZhbHNlLC8vIFRoZSBuZXcga2V5IGV2ZW4gdG8gZW1pdFxua2V5OnVuZGVmaW5lZCwvLyBUaGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgdG8gc2Nyb2xsLCBpZiB0aGlzIGlzIGRlZmluZWQgaXQgd2lsbCBjYW5jZWwgdGhlIGV2ZW50XG5zY3JvbGxEaXNwOnVuZGVmaW5lZH07dmFyIG1vZGlmaWVycz1ldi5zaGlmdEtleTw8MHxldi5hbHRLZXk8PDF8ZXYuY3RybEtleTw8Mnxldi5tZXRhS2V5PDwzO3N3aXRjaChldi5rZXlDb2RlKXtjYXNlIDg6Ly8gYmFja3NwYWNlXG5pZihldi5zaGlmdEtleSl7cmVzdWx0LmtleT0nXFx4MDgnOy8vIF5IXG5icmVhazt9cmVzdWx0LmtleT0nXFx4N2YnOy8vIF4/XG5icmVhaztjYXNlIDk6Ly8gdGFiXG5pZihldi5zaGlmdEtleSl7cmVzdWx0LmtleT0nXFx4MWJbWic7YnJlYWs7fXJlc3VsdC5rZXk9J1xcdCc7cmVzdWx0LmNhbmNlbD10cnVlO2JyZWFrO2Nhc2UgMTM6Ly8gcmV0dXJuL2VudGVyXG5yZXN1bHQua2V5PSdcXHInO3Jlc3VsdC5jYW5jZWw9dHJ1ZTticmVhaztjYXNlIDI3Oi8vIGVzY2FwZVxucmVzdWx0LmtleT0nXFx4MWInO3Jlc3VsdC5jYW5jZWw9dHJ1ZTticmVhaztjYXNlIDM3Oi8vIGxlZnQtYXJyb3dcbmlmKG1vZGlmaWVycyl7cmVzdWx0LmtleT0nXFx4MWJbMTsnKyhtb2RpZmllcnMrMSkrJ0QnOy8vIEhBQ0s6IE1ha2UgQWx0ICsgbGVmdC1hcnJvdyBiZWhhdmUgbGlrZSBDdHJsICsgbGVmdC1hcnJvdzogbW92ZSBvbmUgd29yZCBiYWNrd2FyZHNcbi8vIGh0dHA6Ly91bml4LnN0YWNrZXhjaGFuZ2UuY29tL2EvMTA4MTA2XG5pZihyZXN1bHQua2V5PT0nXFx4MWJbMTszRCcpe3Jlc3VsdC5rZXk9J1xceDFiWzE7NUQnO319ZWxzZSBpZih0aGlzLmFwcGxpY2F0aW9uQ3Vyc29yKXtyZXN1bHQua2V5PSdcXHgxYk9EJzt9ZWxzZXtyZXN1bHQua2V5PSdcXHgxYltEJzt9YnJlYWs7Y2FzZSAzOTovLyByaWdodC1hcnJvd1xuaWYobW9kaWZpZXJzKXtyZXN1bHQua2V5PSdcXHgxYlsxOycrKG1vZGlmaWVycysxKSsnQyc7Ly8gSEFDSzogTWFrZSBBbHQgKyByaWdodC1hcnJvdyBiZWhhdmUgbGlrZSBDdHJsICsgcmlnaHQtYXJyb3c6IG1vdmUgb25lIHdvcmQgZm9yd2FyZFxuLy8gaHR0cDovL3VuaXguc3RhY2tleGNoYW5nZS5jb20vYS8xMDgxMDZcbmlmKHJlc3VsdC5rZXk9PSdcXHgxYlsxOzNDJyl7cmVzdWx0LmtleT0nXFx4MWJbMTs1Qyc7fX1lbHNlIGlmKHRoaXMuYXBwbGljYXRpb25DdXJzb3Ipe3Jlc3VsdC5rZXk9J1xceDFiT0MnO31lbHNle3Jlc3VsdC5rZXk9J1xceDFiW0MnO31icmVhaztjYXNlIDM4Oi8vIHVwLWFycm93XG5pZihtb2RpZmllcnMpe3Jlc3VsdC5rZXk9J1xceDFiWzE7JysobW9kaWZpZXJzKzEpKydBJzsvLyBIQUNLOiBNYWtlIEFsdCArIHVwLWFycm93IGJlaGF2ZSBsaWtlIEN0cmwgKyB1cC1hcnJvd1xuLy8gaHR0cDovL3VuaXguc3RhY2tleGNoYW5nZS5jb20vYS8xMDgxMDZcbmlmKHJlc3VsdC5rZXk9PSdcXHgxYlsxOzNBJyl7cmVzdWx0LmtleT0nXFx4MWJbMTs1QSc7fX1lbHNlIGlmKHRoaXMuYXBwbGljYXRpb25DdXJzb3Ipe3Jlc3VsdC5rZXk9J1xceDFiT0EnO31lbHNle3Jlc3VsdC5rZXk9J1xceDFiW0EnO31icmVhaztjYXNlIDQwOi8vIGRvd24tYXJyb3dcbmlmKG1vZGlmaWVycyl7cmVzdWx0LmtleT0nXFx4MWJbMTsnKyhtb2RpZmllcnMrMSkrJ0InOy8vIEhBQ0s6IE1ha2UgQWx0ICsgZG93bi1hcnJvdyBiZWhhdmUgbGlrZSBDdHJsICsgZG93bi1hcnJvd1xuLy8gaHR0cDovL3VuaXguc3RhY2tleGNoYW5nZS5jb20vYS8xMDgxMDZcbmlmKHJlc3VsdC5rZXk9PSdcXHgxYlsxOzNCJyl7cmVzdWx0LmtleT0nXFx4MWJbMTs1Qic7fX1lbHNlIGlmKHRoaXMuYXBwbGljYXRpb25DdXJzb3Ipe3Jlc3VsdC5rZXk9J1xceDFiT0InO31lbHNle3Jlc3VsdC5rZXk9J1xceDFiW0InO31icmVhaztjYXNlIDQ1Oi8vIGluc2VydFxuaWYoIWV2LnNoaWZ0S2V5JiYhZXYuY3RybEtleSl7Ly8gPEN0cmw+IG9yIDxTaGlmdD4gKyA8SW5zZXJ0PiBhcmUgdXNlZCB0b1xuLy8gY29weS1wYXN0ZSBvbiBzb21lIHN5c3RlbXMuXG5yZXN1bHQua2V5PSdcXHgxYlsyfic7fWJyZWFrO2Nhc2UgNDY6Ly8gZGVsZXRlXG5pZihtb2RpZmllcnMpe3Jlc3VsdC5rZXk9J1xceDFiWzM7JysobW9kaWZpZXJzKzEpKyd+Jzt9ZWxzZXtyZXN1bHQua2V5PSdcXHgxYlszfic7fWJyZWFrO2Nhc2UgMzY6Ly8gaG9tZVxuaWYobW9kaWZpZXJzKXJlc3VsdC5rZXk9J1xceDFiWzE7JysobW9kaWZpZXJzKzEpKydIJztlbHNlIGlmKHRoaXMuYXBwbGljYXRpb25DdXJzb3IpcmVzdWx0LmtleT0nXFx4MWJPSCc7ZWxzZSByZXN1bHQua2V5PSdcXHgxYltIJzticmVhaztjYXNlIDM1Oi8vIGVuZFxuaWYobW9kaWZpZXJzKXJlc3VsdC5rZXk9J1xceDFiWzE7JysobW9kaWZpZXJzKzEpKydGJztlbHNlIGlmKHRoaXMuYXBwbGljYXRpb25DdXJzb3IpcmVzdWx0LmtleT0nXFx4MWJPRic7ZWxzZSByZXN1bHQua2V5PSdcXHgxYltGJzticmVhaztjYXNlIDMzOi8vIHBhZ2UgdXBcbmlmKGV2LnNoaWZ0S2V5KXtyZXN1bHQuc2Nyb2xsRGlzcD0tKHRoaXMucm93cy0xKTt9ZWxzZXtyZXN1bHQua2V5PSdcXHgxYls1fic7fWJyZWFrO2Nhc2UgMzQ6Ly8gcGFnZSBkb3duXG5pZihldi5zaGlmdEtleSl7cmVzdWx0LnNjcm9sbERpc3A9dGhpcy5yb3dzLTE7fWVsc2V7cmVzdWx0LmtleT0nXFx4MWJbNn4nO31icmVhaztjYXNlIDExMjovLyBGMS1GMTJcbmlmKG1vZGlmaWVycyl7cmVzdWx0LmtleT0nXFx4MWJbMTsnKyhtb2RpZmllcnMrMSkrJ1AnO31lbHNle3Jlc3VsdC5rZXk9J1xceDFiT1AnO31icmVhaztjYXNlIDExMzppZihtb2RpZmllcnMpe3Jlc3VsdC5rZXk9J1xceDFiWzE7JysobW9kaWZpZXJzKzEpKydRJzt9ZWxzZXtyZXN1bHQua2V5PSdcXHgxYk9RJzt9YnJlYWs7Y2FzZSAxMTQ6aWYobW9kaWZpZXJzKXtyZXN1bHQua2V5PSdcXHgxYlsxOycrKG1vZGlmaWVycysxKSsnUic7fWVsc2V7cmVzdWx0LmtleT0nXFx4MWJPUic7fWJyZWFrO2Nhc2UgMTE1OmlmKG1vZGlmaWVycyl7cmVzdWx0LmtleT0nXFx4MWJbMTsnKyhtb2RpZmllcnMrMSkrJ1MnO31lbHNle3Jlc3VsdC5rZXk9J1xceDFiT1MnO31icmVhaztjYXNlIDExNjppZihtb2RpZmllcnMpe3Jlc3VsdC5rZXk9J1xceDFiWzE1OycrKG1vZGlmaWVycysxKSsnfic7fWVsc2V7cmVzdWx0LmtleT0nXFx4MWJbMTV+Jzt9YnJlYWs7Y2FzZSAxMTc6aWYobW9kaWZpZXJzKXtyZXN1bHQua2V5PSdcXHgxYlsxNzsnKyhtb2RpZmllcnMrMSkrJ34nO31lbHNle3Jlc3VsdC5rZXk9J1xceDFiWzE3fic7fWJyZWFrO2Nhc2UgMTE4OmlmKG1vZGlmaWVycyl7cmVzdWx0LmtleT0nXFx4MWJbMTg7JysobW9kaWZpZXJzKzEpKyd+Jzt9ZWxzZXtyZXN1bHQua2V5PSdcXHgxYlsxOH4nO31icmVhaztjYXNlIDExOTppZihtb2RpZmllcnMpe3Jlc3VsdC5rZXk9J1xceDFiWzE5OycrKG1vZGlmaWVycysxKSsnfic7fWVsc2V7cmVzdWx0LmtleT0nXFx4MWJbMTl+Jzt9YnJlYWs7Y2FzZSAxMjA6aWYobW9kaWZpZXJzKXtyZXN1bHQua2V5PSdcXHgxYlsyMDsnKyhtb2RpZmllcnMrMSkrJ34nO31lbHNle3Jlc3VsdC5rZXk9J1xceDFiWzIwfic7fWJyZWFrO2Nhc2UgMTIxOmlmKG1vZGlmaWVycyl7cmVzdWx0LmtleT0nXFx4MWJbMjE7JysobW9kaWZpZXJzKzEpKyd+Jzt9ZWxzZXtyZXN1bHQua2V5PSdcXHgxYlsyMX4nO31icmVhaztjYXNlIDEyMjppZihtb2RpZmllcnMpe3Jlc3VsdC5rZXk9J1xceDFiWzIzOycrKG1vZGlmaWVycysxKSsnfic7fWVsc2V7cmVzdWx0LmtleT0nXFx4MWJbMjN+Jzt9YnJlYWs7Y2FzZSAxMjM6aWYobW9kaWZpZXJzKXtyZXN1bHQua2V5PSdcXHgxYlsyNDsnKyhtb2RpZmllcnMrMSkrJ34nO31lbHNle3Jlc3VsdC5rZXk9J1xceDFiWzI0fic7fWJyZWFrO2RlZmF1bHQ6Ly8gYS16IGFuZCBzcGFjZVxuaWYoZXYuY3RybEtleSYmIWV2LnNoaWZ0S2V5JiYhZXYuYWx0S2V5JiYhZXYubWV0YUtleSl7aWYoZXYua2V5Q29kZT49NjUmJmV2LmtleUNvZGU8PTkwKXtyZXN1bHQua2V5PVN0cmluZy5mcm9tQ2hhckNvZGUoZXYua2V5Q29kZS02NCk7fWVsc2UgaWYoZXYua2V5Q29kZT09PTMyKXsvLyBOVUxcbnJlc3VsdC5rZXk9U3RyaW5nLmZyb21DaGFyQ29kZSgwKTt9ZWxzZSBpZihldi5rZXlDb2RlPj01MSYmZXYua2V5Q29kZTw9NTUpey8vIGVzY2FwZSwgZmlsZSBzZXAsIGdyb3VwIHNlcCwgcmVjb3JkIHNlcCwgdW5pdCBzZXBcbnJlc3VsdC5rZXk9U3RyaW5nLmZyb21DaGFyQ29kZShldi5rZXlDb2RlLTUxKzI3KTt9ZWxzZSBpZihldi5rZXlDb2RlPT09NTYpey8vIGRlbGV0ZVxucmVzdWx0LmtleT1TdHJpbmcuZnJvbUNoYXJDb2RlKDEyNyk7fWVsc2UgaWYoZXYua2V5Q29kZT09PTIxOSl7Ly8gXlsgLSBlc2NhcGVcbnJlc3VsdC5rZXk9U3RyaW5nLmZyb21DaGFyQ29kZSgyNyk7fWVsc2UgaWYoZXYua2V5Q29kZT09PTIyMSl7Ly8gXl0gLSBncm91cCBzZXBcbnJlc3VsdC5rZXk9U3RyaW5nLmZyb21DaGFyQ29kZSgyOSk7fX1lbHNlIGlmKCF0aGlzLmlzTWFjJiZldi5hbHRLZXkmJiFldi5jdHJsS2V5JiYhZXYubWV0YUtleSl7Ly8gT24gTWFjIHRoaXMgaXMgYSB0aGlyZCBsZXZlbCBzaGlmdC4gVXNlIDxFc2M+IGluc3RlYWQuXG5pZihldi5rZXlDb2RlPj02NSYmZXYua2V5Q29kZTw9OTApe3Jlc3VsdC5rZXk9J1xceDFiJytTdHJpbmcuZnJvbUNoYXJDb2RlKGV2LmtleUNvZGUrMzIpO31lbHNlIGlmKGV2LmtleUNvZGU9PT0xOTIpe3Jlc3VsdC5rZXk9J1xceDFiYCc7fWVsc2UgaWYoZXYua2V5Q29kZT49NDgmJmV2LmtleUNvZGU8PTU3KXtyZXN1bHQua2V5PSdcXHgxYicrKGV2LmtleUNvZGUtNDgpO319YnJlYWs7fXJldHVybiByZXN1bHQ7fTsvKipcbiAqIFNldCB0aGUgRyBsZXZlbCBvZiB0aGUgdGVybWluYWxcbiAqIEBwYXJhbSBnXG4gKi9UZXJtaW5hbC5wcm90b3R5cGUuc2V0Z0xldmVsPWZ1bmN0aW9uKGcpe3RoaXMuZ2xldmVsPWc7dGhpcy5jaGFyc2V0PXRoaXMuY2hhcnNldHNbZ107fTsvKipcbiAqIFNldCB0aGUgY2hhcnNldCBmb3IgdGhlIGdpdmVuIEcgbGV2ZWwgb2YgdGhlIHRlcm1pbmFsXG4gKiBAcGFyYW0gZ1xuICogQHBhcmFtIGNoYXJzZXRcbiAqL1Rlcm1pbmFsLnByb3RvdHlwZS5zZXRnQ2hhcnNldD1mdW5jdGlvbihnLGNoYXJzZXQpe3RoaXMuY2hhcnNldHNbZ109Y2hhcnNldDtpZih0aGlzLmdsZXZlbD09PWcpe3RoaXMuY2hhcnNldD1jaGFyc2V0O319Oy8qKlxuICogSGFuZGxlIGEga2V5cHJlc3MgZXZlbnQuXG4gKiBLZXkgUmVzb3VyY2VzOlxuICogICAtIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvRE9NL0tleWJvYXJkRXZlbnRcbiAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZXYgVGhlIGtleXByZXNzIGV2ZW50IHRvIGJlIGhhbmRsZWQuXG4gKi9UZXJtaW5hbC5wcm90b3R5cGUua2V5UHJlc3M9ZnVuY3Rpb24oZXYpe3ZhciBrZXk7dGhpcy5jYW5jZWwoZXYpO2lmKGV2LmNoYXJDb2RlKXtrZXk9ZXYuY2hhckNvZGU7fWVsc2UgaWYoZXYud2hpY2g9PW51bGwpe2tleT1ldi5rZXlDb2RlO31lbHNlIGlmKGV2LndoaWNoIT09MCYmZXYuY2hhckNvZGUhPT0wKXtrZXk9ZXYud2hpY2g7fWVsc2V7cmV0dXJuIGZhbHNlO31pZigha2V5fHwoZXYuYWx0S2V5fHxldi5jdHJsS2V5fHxldi5tZXRhS2V5KSYmIWlzVGhpcmRMZXZlbFNoaWZ0KHRoaXMsZXYpKXtyZXR1cm4gZmFsc2U7fWtleT1TdHJpbmcuZnJvbUNoYXJDb2RlKGtleSk7dGhpcy5lbWl0KCdrZXlwcmVzcycsa2V5LGV2KTt0aGlzLmVtaXQoJ2tleScsa2V5LGV2KTt0aGlzLnNob3dDdXJzb3IoKTt0aGlzLmhhbmRsZXIoa2V5KTtyZXR1cm4gZmFsc2U7fTsvKipcbiAqIFNlbmQgZGF0YSBmb3IgaGFuZGxpbmcgdG8gdGhlIHRlcm1pbmFsXG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0YVxuICovVGVybWluYWwucHJvdG90eXBlLnNlbmQ9ZnVuY3Rpb24oZGF0YSl7dmFyIHNlbGY9dGhpcztpZighdGhpcy5xdWV1ZSl7c2V0VGltZW91dChmdW5jdGlvbigpe3NlbGYuaGFuZGxlcihzZWxmLnF1ZXVlKTtzZWxmLnF1ZXVlPScnO30sMSk7fXRoaXMucXVldWUrPWRhdGE7fTsvKipcbiAqIFJpbmcgdGhlIGJlbGwuXG4gKiBOb3RlOiBXZSBjb3VsZCBkbyBzd2VldCB0aGluZ3Mgd2l0aCB3ZWJhdWRpbyBoZXJlXG4gKi9UZXJtaW5hbC5wcm90b3R5cGUuYmVsbD1mdW5jdGlvbigpe2lmKCF0aGlzLnZpc3VhbEJlbGwpcmV0dXJuO3ZhciBzZWxmPXRoaXM7dGhpcy5lbGVtZW50LnN0eWxlLmJvcmRlckNvbG9yPSd3aGl0ZSc7c2V0VGltZW91dChmdW5jdGlvbigpe3NlbGYuZWxlbWVudC5zdHlsZS5ib3JkZXJDb2xvcj0nJzt9LDEwKTtpZih0aGlzLnBvcE9uQmVsbCl0aGlzLmZvY3VzKCk7fTsvKipcbiAqIExvZyB0aGUgY3VycmVudCBzdGF0ZSB0byB0aGUgY29uc29sZS5cbiAqL1Rlcm1pbmFsLnByb3RvdHlwZS5sb2c9ZnVuY3Rpb24oKXtpZighdGhpcy5kZWJ1ZylyZXR1cm47aWYoIXRoaXMuY29udGV4dC5jb25zb2xlfHwhdGhpcy5jb250ZXh0LmNvbnNvbGUubG9nKXJldHVybjt2YXIgYXJncz1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO3RoaXMuY29udGV4dC5jb25zb2xlLmxvZy5hcHBseSh0aGlzLmNvbnRleHQuY29uc29sZSxhcmdzKTt9Oy8qKlxuICogTG9nIHRoZSBjdXJyZW50IHN0YXRlIGFzIGVycm9yIHRvIHRoZSBjb25zb2xlLlxuICovVGVybWluYWwucHJvdG90eXBlLmVycm9yPWZ1bmN0aW9uKCl7aWYoIXRoaXMuZGVidWcpcmV0dXJuO2lmKCF0aGlzLmNvbnRleHQuY29uc29sZXx8IXRoaXMuY29udGV4dC5jb25zb2xlLmVycm9yKXJldHVybjt2YXIgYXJncz1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO3RoaXMuY29udGV4dC5jb25zb2xlLmVycm9yLmFwcGx5KHRoaXMuY29udGV4dC5jb25zb2xlLGFyZ3MpO307LyoqXG4gKiBSZXNpemVzIHRoZSB0ZXJtaW5hbC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0geCBUaGUgbnVtYmVyIG9mIGNvbHVtbnMgdG8gcmVzaXplIHRvLlxuICogQHBhcmFtIHtudW1iZXJ9IHkgVGhlIG51bWJlciBvZiByb3dzIHRvIHJlc2l6ZSB0by5cbiAqL1Rlcm1pbmFsLnByb3RvdHlwZS5yZXNpemU9ZnVuY3Rpb24oeCx5KXt2YXIgbGluZSxlbCxpLGosY2gsYWRkVG9ZO2lmKHg9PT10aGlzLmNvbHMmJnk9PT10aGlzLnJvd3Mpe3JldHVybjt9aWYoeDwxKXg9MTtpZih5PDEpeT0xOy8vIHJlc2l6ZSBjb2xzXG5qPXRoaXMuY29scztpZihqPHgpe2NoPVt0aGlzLmRlZkF0dHIsJyAnLDFdOy8vIGRvZXMgeHRlcm0gdXNlIHRoZSBkZWZhdWx0IGF0dHI/XG5pPXRoaXMubGluZXMubGVuZ3RoO3doaWxlKGktLSl7d2hpbGUodGhpcy5saW5lc1tpXS5sZW5ndGg8eCl7dGhpcy5saW5lc1tpXS5wdXNoKGNoKTt9fX1lbHNley8vIChqID4geClcbmk9dGhpcy5saW5lcy5sZW5ndGg7d2hpbGUoaS0tKXt3aGlsZSh0aGlzLmxpbmVzW2ldLmxlbmd0aD54KXt0aGlzLmxpbmVzW2ldLnBvcCgpO319fXRoaXMuc2V0dXBTdG9wcyhqKTt0aGlzLmNvbHM9eDsvLyByZXNpemUgcm93c1xuaj10aGlzLnJvd3M7YWRkVG9ZPTA7aWYoajx5KXtlbD10aGlzLmVsZW1lbnQ7d2hpbGUoaisrPHkpey8vIHkgaXMgcm93cywgbm90IHRoaXMueVxuaWYodGhpcy5saW5lcy5sZW5ndGg8eSt0aGlzLnliYXNlKXtpZih0aGlzLnliYXNlPjAmJnRoaXMubGluZXMubGVuZ3RoPD10aGlzLnliYXNlK3RoaXMueSthZGRUb1krMSl7Ly8gVGhlcmUgaXMgcm9vbSBhYm92ZSB0aGUgYnVmZmVyIGFuZCB0aGVyZSBhcmUgbm8gZW1wdHkgZWxlbWVudHMgYmVsb3cgdGhlIGxpbmUsXG4vLyBzY3JvbGwgdXBcbnRoaXMueWJhc2UtLTthZGRUb1krKztpZih0aGlzLnlkaXNwPjApey8vIFZpZXdwb3J0IGlzIGF0IHRoZSB0b3Agb2YgdGhlIGJ1ZmZlciwgbXVzdCBpbmNyZWFzZSBkb3dud2FyZHNcbnRoaXMueWRpc3AtLTt9fWVsc2V7Ly8gQWRkIGEgYmxhbmsgbGluZSBpZiB0aGVyZSBpcyBubyBidWZmZXIgbGVmdCBhdCB0aGUgdG9wIHRvIHNjcm9sbCB0bywgb3IgaWYgdGhlcmVcbi8vIGFyZSBibGFuayBsaW5lcyBhZnRlciB0aGUgY3Vyc29yXG50aGlzLmxpbmVzLnB1c2godGhpcy5ibGFua0xpbmUoKSk7fX1pZih0aGlzLmNoaWxkcmVuLmxlbmd0aDx5KXt0aGlzLmluc2VydFJvdygpO319fWVsc2V7Ly8gKGogPiB5KVxud2hpbGUoai0tPnkpe2lmKHRoaXMubGluZXMubGVuZ3RoPnkrdGhpcy55YmFzZSl7aWYodGhpcy5saW5lcy5sZW5ndGg+dGhpcy55YmFzZSt0aGlzLnkrMSl7Ly8gVGhlIGxpbmUgaXMgYSBibGFuayBsaW5lIGJlbG93IHRoZSBjdXJzb3IsIHJlbW92ZSBpdFxudGhpcy5saW5lcy5wb3AoKTt9ZWxzZXsvLyBUaGUgbGluZSBpcyB0aGUgY3Vyc29yLCBzY3JvbGwgZG93blxudGhpcy55YmFzZSsrO3RoaXMueWRpc3ArKzt9fWlmKHRoaXMuY2hpbGRyZW4ubGVuZ3RoPnkpe2VsPXRoaXMuY2hpbGRyZW4uc2hpZnQoKTtpZighZWwpY29udGludWU7ZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbCk7fX19dGhpcy5yb3dzPXk7Ly8gTWFrZSBzdXJlIHRoYXQgdGhlIGN1cnNvciBzdGF5cyBvbiBzY3JlZW5cbmlmKHRoaXMueT49eSl7dGhpcy55PXktMTt9aWYoYWRkVG9ZKXt0aGlzLnkrPWFkZFRvWTt9aWYodGhpcy54Pj14KXt0aGlzLng9eC0xO310aGlzLnNjcm9sbFRvcD0wO3RoaXMuc2Nyb2xsQm90dG9tPXktMTt0aGlzLnJlZnJlc2goMCx0aGlzLnJvd3MtMSk7dGhpcy5ub3JtYWw9bnVsbDt0aGlzLmVtaXQoJ3Jlc2l6ZScse3Rlcm1pbmFsOnRoaXMsY29sczp4LHJvd3M6eX0pO307LyoqXG4gKiBVcGRhdGVzIHRoZSByYW5nZSBvZiByb3dzIHRvIHJlZnJlc2hcbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFRoZSBudW1iZXIgb2Ygcm93cyB0byByZWZyZXNoIG5leHQuXG4gKi9UZXJtaW5hbC5wcm90b3R5cGUudXBkYXRlUmFuZ2U9ZnVuY3Rpb24oeSl7aWYoeTx0aGlzLnJlZnJlc2hTdGFydCl0aGlzLnJlZnJlc2hTdGFydD15O2lmKHk+dGhpcy5yZWZyZXNoRW5kKXRoaXMucmVmcmVzaEVuZD15Oy8vIGlmICh5ID4gdGhpcy5yZWZyZXNoRW5kKSB7XG4vLyAgIHRoaXMucmVmcmVzaEVuZCA9IHk7XG4vLyAgIGlmICh5ID4gdGhpcy5yb3dzIC0gMSkge1xuLy8gICAgIHRoaXMucmVmcmVzaEVuZCA9IHRoaXMucm93cyAtIDE7XG4vLyAgIH1cbi8vIH1cbn07LyoqXG4gKiBTZXQgdGhlIHJhbmdlIG9mIHJlZnJlc2hpbmcgdG8gdGhlIG1heGlteXVtIHZhbHVlXG4gKi9UZXJtaW5hbC5wcm90b3R5cGUubWF4UmFuZ2U9ZnVuY3Rpb24oKXt0aGlzLnJlZnJlc2hTdGFydD0wO3RoaXMucmVmcmVzaEVuZD10aGlzLnJvd3MtMTt9Oy8qKlxuICogU2V0dXAgdGhlIHRhYiBzdG9wcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpXG4gKi9UZXJtaW5hbC5wcm90b3R5cGUuc2V0dXBTdG9wcz1mdW5jdGlvbihpKXtpZihpIT1udWxsKXtpZighdGhpcy50YWJzW2ldKXtpPXRoaXMucHJldlN0b3AoaSk7fX1lbHNle3RoaXMudGFicz17fTtpPTA7fWZvcig7aTx0aGlzLmNvbHM7aSs9OCl7dGhpcy50YWJzW2ldPXRydWU7fX07LyoqXG4gKiBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhlIHByZXZpb3VzIHRhYiBzdG9wIGZyb20gdGhlIGdpdmVuIHBvc2l0aW9uIChkZWZhdWx0IGlzIGN1cnJlbnQpLlxuICogQHBhcmFtIHtudW1iZXJ9IHggVGhlIHBvc2l0aW9uIHRvIG1vdmUgdGhlIGN1cnNvciB0byB0aGUgcHJldmlvdXMgdGFiIHN0b3AuXG4gKi9UZXJtaW5hbC5wcm90b3R5cGUucHJldlN0b3A9ZnVuY3Rpb24oeCl7aWYoeD09bnVsbCl4PXRoaXMueDt3aGlsZSghdGhpcy50YWJzWy0teF0mJng+MCl7fXJldHVybiB4Pj10aGlzLmNvbHM/dGhpcy5jb2xzLTE6eDwwPzA6eDt9Oy8qKlxuICogTW92ZSB0aGUgY3Vyc29yIG9uZSB0YWIgc3RvcCBmb3J3YXJkIGZyb20gdGhlIGdpdmVuIHBvc2l0aW9uIChkZWZhdWx0IGlzIGN1cnJlbnQpLlxuICogQHBhcmFtIHtudW1iZXJ9IHggVGhlIHBvc2l0aW9uIHRvIG1vdmUgdGhlIGN1cnNvciBvbmUgdGFiIHN0b3AgZm9yd2FyZC5cbiAqL1Rlcm1pbmFsLnByb3RvdHlwZS5uZXh0U3RvcD1mdW5jdGlvbih4KXtpZih4PT1udWxsKXg9dGhpcy54O3doaWxlKCF0aGlzLnRhYnNbKyt4XSYmeDx0aGlzLmNvbHMpe31yZXR1cm4geD49dGhpcy5jb2xzP3RoaXMuY29scy0xOng8MD8wOng7fTsvKipcbiAqIEVyYXNlIGluIHRoZSBpZGVudGlmaWVkIGxpbmUgZXZlcnl0aGluZyBmcm9tIFwieFwiIHRvIHRoZSBlbmQgb2YgdGhlIGxpbmUgKHJpZ2h0KS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFRoZSBjb2x1bW4gZnJvbSB3aGljaCB0byBzdGFydCBlcmFzaW5nIHRvIHRoZSBlbmQgb2YgdGhlIGxpbmUuXG4gKiBAcGFyYW0ge251bWJlcn0geSBUaGUgbGluZSBpbiB3aGljaCB0byBvcGVyYXRlLlxuICovVGVybWluYWwucHJvdG90eXBlLmVyYXNlUmlnaHQ9ZnVuY3Rpb24oeCx5KXt2YXIgbGluZT10aGlzLmxpbmVzW3RoaXMueWJhc2UreV0sY2g9W3RoaXMuZXJhc2VBdHRyKCksJyAnLDFdOy8vIHh0ZXJtXG5mb3IoO3g8dGhpcy5jb2xzO3grKyl7bGluZVt4XT1jaDt9dGhpcy51cGRhdGVSYW5nZSh5KTt9Oy8qKlxuICogRXJhc2UgaW4gdGhlIGlkZW50aWZpZWQgbGluZSBldmVyeXRoaW5nIGZyb20gXCJ4XCIgdG8gdGhlIHN0YXJ0IG9mIHRoZSBsaW5lIChsZWZ0KS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFRoZSBjb2x1bW4gZnJvbSB3aGljaCB0byBzdGFydCBlcmFzaW5nIHRvIHRoZSBzdGFydCBvZiB0aGUgbGluZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFRoZSBsaW5lIGluIHdoaWNoIHRvIG9wZXJhdGUuXG4gKi9UZXJtaW5hbC5wcm90b3R5cGUuZXJhc2VMZWZ0PWZ1bmN0aW9uKHgseSl7dmFyIGxpbmU9dGhpcy5saW5lc1t0aGlzLnliYXNlK3ldLGNoPVt0aGlzLmVyYXNlQXR0cigpLCcgJywxXTsvLyB4dGVybVxueCsrO3doaWxlKHgtLSl7bGluZVt4XT1jaDt9dGhpcy51cGRhdGVSYW5nZSh5KTt9Oy8qKlxuICogQ2xlYXJzIHRoZSBlbnRpcmUgYnVmZmVyLCBtYWtpbmcgdGhlIHByb21wdCBsaW5lIHRoZSBuZXcgZmlyc3QgbGluZS5cbiAqL1Rlcm1pbmFsLnByb3RvdHlwZS5jbGVhcj1mdW5jdGlvbigpe2lmKHRoaXMueWJhc2U9PT0wJiZ0aGlzLnk9PT0wKXsvLyBEb24ndCBjbGVhciBpZiBpdCdzIGFscmVhZHkgY2xlYXJcbnJldHVybjt9dGhpcy5saW5lcz1bdGhpcy5saW5lc1t0aGlzLnliYXNlK3RoaXMueV1dO3RoaXMueWRpc3A9MDt0aGlzLnliYXNlPTA7dGhpcy55PTA7Zm9yKHZhciBpPTE7aTx0aGlzLnJvd3M7aSsrKXt0aGlzLmxpbmVzLnB1c2godGhpcy5ibGFua0xpbmUoKSk7fXRoaXMucmVmcmVzaCgwLHRoaXMucm93cy0xKTt0aGlzLmVtaXQoJ3Njcm9sbCcsdGhpcy55ZGlzcCk7fTsvKipcbiAqIEVyYXNlIGFsbCBjb250ZW50IGluIHRoZSBnaXZlbiBsaW5lXG4gKiBAcGFyYW0ge251bWJlcn0geSBUaGUgbGluZSB0byBlcmFzZSBhbGwgb2YgaXRzIGNvbnRlbnRzLlxuICovVGVybWluYWwucHJvdG90eXBlLmVyYXNlTGluZT1mdW5jdGlvbih5KXt0aGlzLmVyYXNlUmlnaHQoMCx5KTt9Oy8qKlxuICogUmV0dXJuIHRoZSBkYXRhIGFycmF5IG9mIGEgYmxhbmsgbGluZS9cbiAqIEBwYXJhbSB7bnVtYmVyfSBjdXIgRmlyc3QgYnVuY2ggb2YgZGF0YSBmb3IgZWFjaCBcImJsYW5rXCIgY2hhcmFjdGVyLlxuICovVGVybWluYWwucHJvdG90eXBlLmJsYW5rTGluZT1mdW5jdGlvbihjdXIpe3ZhciBhdHRyPWN1cj90aGlzLmVyYXNlQXR0cigpOnRoaXMuZGVmQXR0cjt2YXIgY2g9W2F0dHIsJyAnLDFdLy8gd2lkdGggZGVmYXVsdHMgdG8gMSBoYWxmd2lkdGggY2hhcmFjdGVyXG4sbGluZT1bXSxpPTA7Zm9yKDtpPHRoaXMuY29scztpKyspe2xpbmVbaV09Y2g7fXJldHVybiBsaW5lO307LyoqXG4gKiBJZiBjdXIgcmV0dXJuIHRoZSBiYWNrIGNvbG9yIHh0ZXJtIGZlYXR1cmUgYXR0cmlidXRlLiBFbHNlIHJldHVybiBkZWZBdHRyLlxuICogQHBhcmFtIHtvYmplY3R9IGN1clxuICovVGVybWluYWwucHJvdG90eXBlLmNoPWZ1bmN0aW9uKGN1cil7cmV0dXJuIGN1cj9bdGhpcy5lcmFzZUF0dHIoKSwnICcsMV06W3RoaXMuZGVmQXR0ciwnICcsMV07fTsvKipcbiAqIEV2YWx1YXRlIGlmIHRoZSBjdXJyZW50IGVybWluYWwgaXMgdGhlIGdpdmVuIGFyZ3VtZW50LlxuICogQHBhcmFtIHtvYmplY3R9IHRlcm0gVGhlIHRlcm1pbmFsIHRvIGV2YWx1YXRlXG4gKi9UZXJtaW5hbC5wcm90b3R5cGUuaXM9ZnVuY3Rpb24odGVybSl7dmFyIG5hbWU9dGhpcy50ZXJtTmFtZTtyZXR1cm4obmFtZSsnJykuaW5kZXhPZih0ZXJtKT09PTA7fTsvKipcbiAgICAgKiBFbWl0IHRoZSAnZGF0YScgZXZlbnQgYW5kIHBvcHVsYXRlIHRoZSBnaXZlbiBkYXRhLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhIFRoZSBkYXRhIHRvIHBvcHVsYXRlIGluIHRoZSBldmVudC5cbiAgICAgKi9UZXJtaW5hbC5wcm90b3R5cGUuaGFuZGxlcj1mdW5jdGlvbihkYXRhKXt0aGlzLmVtaXQoJ2RhdGEnLGRhdGEpO307LyoqXG4gKiBFbWl0IHRoZSAndGl0bGUnIGV2ZW50IGFuZCBwb3B1bGF0ZSB0aGUgZ2l2ZW4gdGl0bGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGl0bGUgVGhlIHRpdGxlIHRvIHBvcHVsYXRlIGluIHRoZSBldmVudC5cbiAqL1Rlcm1pbmFsLnByb3RvdHlwZS5oYW5kbGVUaXRsZT1mdW5jdGlvbih0aXRsZSl7dGhpcy5lbWl0KCd0aXRsZScsdGl0bGUpO307LyoqXG4gKiBFU0NcbiAqLy8qKlxuICogRVNDIEQgSW5kZXggKElORCBpcyAweDg0KS5cbiAqL1Rlcm1pbmFsLnByb3RvdHlwZS5pbmRleD1mdW5jdGlvbigpe3RoaXMueSsrO2lmKHRoaXMueT50aGlzLnNjcm9sbEJvdHRvbSl7dGhpcy55LS07dGhpcy5zY3JvbGwoKTt9dGhpcy5zdGF0ZT1ub3JtYWw7fTsvKipcbiAqIEVTQyBNIFJldmVyc2UgSW5kZXggKFJJIGlzIDB4OGQpLlxuICovVGVybWluYWwucHJvdG90eXBlLnJldmVyc2VJbmRleD1mdW5jdGlvbigpe3ZhciBqO3RoaXMueS0tO2lmKHRoaXMueTx0aGlzLnNjcm9sbFRvcCl7dGhpcy55Kys7Ly8gcG9zc2libHkgbW92ZSB0aGUgY29kZSBiZWxvdyB0byB0ZXJtLnJldmVyc2VTY3JvbGwoKTtcbi8vIHRlc3Q6IGVjaG8gLW5lICdcXGVbMTsxSFxcZVs0NG1cXGVNXFxlWzBtJ1xuLy8gYmxhbmtMaW5lKHRydWUpIGlzIHh0ZXJtL2xpbnV4IGJlaGF2aW9yXG50aGlzLmxpbmVzLnNwbGljZSh0aGlzLnkrdGhpcy55YmFzZSwwLHRoaXMuYmxhbmtMaW5lKHRydWUpKTtqPXRoaXMucm93cy0xLXRoaXMuc2Nyb2xsQm90dG9tO3RoaXMubGluZXMuc3BsaWNlKHRoaXMucm93cy0xK3RoaXMueWJhc2UtaisxLDEpOy8vIHRoaXMubWF4UmFuZ2UoKTtcbnRoaXMudXBkYXRlUmFuZ2UodGhpcy5zY3JvbGxUb3ApO3RoaXMudXBkYXRlUmFuZ2UodGhpcy5zY3JvbGxCb3R0b20pO310aGlzLnN0YXRlPW5vcm1hbDt9Oy8qKlxuICogRVNDIGMgRnVsbCBSZXNldCAoUklTKS5cbiAqL1Rlcm1pbmFsLnByb3RvdHlwZS5yZXNldD1mdW5jdGlvbigpe3RoaXMub3B0aW9ucy5yb3dzPXRoaXMucm93czt0aGlzLm9wdGlvbnMuY29scz10aGlzLmNvbHM7dmFyIGN1c3RvbUtleWRvd25IYW5kbGVyPXRoaXMuY3VzdG9tS2V5ZG93bkhhbmRsZXI7VGVybWluYWwuY2FsbCh0aGlzLHRoaXMub3B0aW9ucyk7dGhpcy5jdXN0b21LZXlkb3duSGFuZGxlcj1jdXN0b21LZXlkb3duSGFuZGxlcjt0aGlzLnJlZnJlc2goMCx0aGlzLnJvd3MtMSk7dGhpcy52aWV3cG9ydC5zeW5jU2Nyb2xsQXJlYSgpO307LyoqXG4gKiBFU0MgSCBUYWIgU2V0IChIVFMgaXMgMHg4OCkuXG4gKi9UZXJtaW5hbC5wcm90b3R5cGUudGFiU2V0PWZ1bmN0aW9uKCl7dGhpcy50YWJzW3RoaXMueF09dHJ1ZTt0aGlzLnN0YXRlPW5vcm1hbDt9Oy8qKlxuICogQ1NJXG4gKi8vKipcbiAqIENTSSBQcyBBXG4gKiBDdXJzb3IgVXAgUHMgVGltZXMgKGRlZmF1bHQgPSAxKSAoQ1VVKS5cbiAqL1Rlcm1pbmFsLnByb3RvdHlwZS5jdXJzb3JVcD1mdW5jdGlvbihwYXJhbXMpe3ZhciBwYXJhbT1wYXJhbXNbMF07aWYocGFyYW08MSlwYXJhbT0xO3RoaXMueS09cGFyYW07aWYodGhpcy55PDApdGhpcy55PTA7fTsvKipcbiAqIENTSSBQcyBCXG4gKiBDdXJzb3IgRG93biBQcyBUaW1lcyAoZGVmYXVsdCA9IDEpIChDVUQpLlxuICovVGVybWluYWwucHJvdG90eXBlLmN1cnNvckRvd249ZnVuY3Rpb24ocGFyYW1zKXt2YXIgcGFyYW09cGFyYW1zWzBdO2lmKHBhcmFtPDEpcGFyYW09MTt0aGlzLnkrPXBhcmFtO2lmKHRoaXMueT49dGhpcy5yb3dzKXt0aGlzLnk9dGhpcy5yb3dzLTE7fX07LyoqXG4gKiBDU0kgUHMgQ1xuICogQ3Vyc29yIEZvcndhcmQgUHMgVGltZXMgKGRlZmF1bHQgPSAxKSAoQ1VGKS5cbiAqL1Rlcm1pbmFsLnByb3RvdHlwZS5jdXJzb3JGb3J3YXJkPWZ1bmN0aW9uKHBhcmFtcyl7dmFyIHBhcmFtPXBhcmFtc1swXTtpZihwYXJhbTwxKXBhcmFtPTE7dGhpcy54Kz1wYXJhbTtpZih0aGlzLng+PXRoaXMuY29scyl7dGhpcy54PXRoaXMuY29scy0xO319Oy8qKlxuICogQ1NJIFBzIERcbiAqIEN1cnNvciBCYWNrd2FyZCBQcyBUaW1lcyAoZGVmYXVsdCA9IDEpIChDVUIpLlxuICovVGVybWluYWwucHJvdG90eXBlLmN1cnNvckJhY2t3YXJkPWZ1bmN0aW9uKHBhcmFtcyl7dmFyIHBhcmFtPXBhcmFtc1swXTtpZihwYXJhbTwxKXBhcmFtPTE7dGhpcy54LT1wYXJhbTtpZih0aGlzLng8MCl0aGlzLng9MDt9Oy8qKlxuICogQ1NJIFBzIDsgUHMgSFxuICogQ3Vyc29yIFBvc2l0aW9uIFtyb3c7Y29sdW1uXSAoZGVmYXVsdCA9IFsxLDFdKSAoQ1VQKS5cbiAqL1Rlcm1pbmFsLnByb3RvdHlwZS5jdXJzb3JQb3M9ZnVuY3Rpb24ocGFyYW1zKXt2YXIgcm93LGNvbDtyb3c9cGFyYW1zWzBdLTE7aWYocGFyYW1zLmxlbmd0aD49Mil7Y29sPXBhcmFtc1sxXS0xO31lbHNle2NvbD0wO31pZihyb3c8MCl7cm93PTA7fWVsc2UgaWYocm93Pj10aGlzLnJvd3Mpe3Jvdz10aGlzLnJvd3MtMTt9aWYoY29sPDApe2NvbD0wO31lbHNlIGlmKGNvbD49dGhpcy5jb2xzKXtjb2w9dGhpcy5jb2xzLTE7fXRoaXMueD1jb2w7dGhpcy55PXJvdzt9Oy8qKlxuICogQ1NJIFBzIEogIEVyYXNlIGluIERpc3BsYXkgKEVEKS5cbiAqICAgICBQcyA9IDAgIC0+IEVyYXNlIEJlbG93IChkZWZhdWx0KS5cbiAqICAgICBQcyA9IDEgIC0+IEVyYXNlIEFib3ZlLlxuICogICAgIFBzID0gMiAgLT4gRXJhc2UgQWxsLlxuICogICAgIFBzID0gMyAgLT4gRXJhc2UgU2F2ZWQgTGluZXMgKHh0ZXJtKS5cbiAqIENTSSA/IFBzIEpcbiAqICAgRXJhc2UgaW4gRGlzcGxheSAoREVDU0VEKS5cbiAqICAgICBQcyA9IDAgIC0+IFNlbGVjdGl2ZSBFcmFzZSBCZWxvdyAoZGVmYXVsdCkuXG4gKiAgICAgUHMgPSAxICAtPiBTZWxlY3RpdmUgRXJhc2UgQWJvdmUuXG4gKiAgICAgUHMgPSAyICAtPiBTZWxlY3RpdmUgRXJhc2UgQWxsLlxuICovVGVybWluYWwucHJvdG90eXBlLmVyYXNlSW5EaXNwbGF5PWZ1bmN0aW9uKHBhcmFtcyl7dmFyIGo7c3dpdGNoKHBhcmFtc1swXSl7Y2FzZSAwOnRoaXMuZXJhc2VSaWdodCh0aGlzLngsdGhpcy55KTtqPXRoaXMueSsxO2Zvcig7ajx0aGlzLnJvd3M7aisrKXt0aGlzLmVyYXNlTGluZShqKTt9YnJlYWs7Y2FzZSAxOnRoaXMuZXJhc2VMZWZ0KHRoaXMueCx0aGlzLnkpO2o9dGhpcy55O3doaWxlKGotLSl7dGhpcy5lcmFzZUxpbmUoaik7fWJyZWFrO2Nhc2UgMjpqPXRoaXMucm93czt3aGlsZShqLS0pe3RoaXMuZXJhc2VMaW5lKGopO31icmVhaztjYXNlIDM6Oy8vIG5vIHNhdmVkIGxpbmVzXG5icmVhazt9fTsvKipcbiAqIENTSSBQcyBLICBFcmFzZSBpbiBMaW5lIChFTCkuXG4gKiAgICAgUHMgPSAwICAtPiBFcmFzZSB0byBSaWdodCAoZGVmYXVsdCkuXG4gKiAgICAgUHMgPSAxICAtPiBFcmFzZSB0byBMZWZ0LlxuICogICAgIFBzID0gMiAgLT4gRXJhc2UgQWxsLlxuICogQ1NJID8gUHMgS1xuICogICBFcmFzZSBpbiBMaW5lIChERUNTRUwpLlxuICogICAgIFBzID0gMCAgLT4gU2VsZWN0aXZlIEVyYXNlIHRvIFJpZ2h0IChkZWZhdWx0KS5cbiAqICAgICBQcyA9IDEgIC0+IFNlbGVjdGl2ZSBFcmFzZSB0byBMZWZ0LlxuICogICAgIFBzID0gMiAgLT4gU2VsZWN0aXZlIEVyYXNlIEFsbC5cbiAqL1Rlcm1pbmFsLnByb3RvdHlwZS5lcmFzZUluTGluZT1mdW5jdGlvbihwYXJhbXMpe3N3aXRjaChwYXJhbXNbMF0pe2Nhc2UgMDp0aGlzLmVyYXNlUmlnaHQodGhpcy54LHRoaXMueSk7YnJlYWs7Y2FzZSAxOnRoaXMuZXJhc2VMZWZ0KHRoaXMueCx0aGlzLnkpO2JyZWFrO2Nhc2UgMjp0aGlzLmVyYXNlTGluZSh0aGlzLnkpO2JyZWFrO319Oy8qKlxuICogQ1NJIFBtIG0gIENoYXJhY3RlciBBdHRyaWJ1dGVzIChTR1IpLlxuICogICAgIFBzID0gMCAgLT4gTm9ybWFsIChkZWZhdWx0KS5cbiAqICAgICBQcyA9IDEgIC0+IEJvbGQuXG4gKiAgICAgUHMgPSA0ICAtPiBVbmRlcmxpbmVkLlxuICogICAgIFBzID0gNSAgLT4gQmxpbmsgKGFwcGVhcnMgYXMgQm9sZCkuXG4gKiAgICAgUHMgPSA3ICAtPiBJbnZlcnNlLlxuICogICAgIFBzID0gOCAgLT4gSW52aXNpYmxlLCBpLmUuLCBoaWRkZW4gKFZUMzAwKS5cbiAqICAgICBQcyA9IDIgMiAgLT4gTm9ybWFsIChuZWl0aGVyIGJvbGQgbm9yIGZhaW50KS5cbiAqICAgICBQcyA9IDIgNCAgLT4gTm90IHVuZGVybGluZWQuXG4gKiAgICAgUHMgPSAyIDUgIC0+IFN0ZWFkeSAobm90IGJsaW5raW5nKS5cbiAqICAgICBQcyA9IDIgNyAgLT4gUG9zaXRpdmUgKG5vdCBpbnZlcnNlKS5cbiAqICAgICBQcyA9IDIgOCAgLT4gVmlzaWJsZSwgaS5lLiwgbm90IGhpZGRlbiAoVlQzMDApLlxuICogICAgIFBzID0gMyAwICAtPiBTZXQgZm9yZWdyb3VuZCBjb2xvciB0byBCbGFjay5cbiAqICAgICBQcyA9IDMgMSAgLT4gU2V0IGZvcmVncm91bmQgY29sb3IgdG8gUmVkLlxuICogICAgIFBzID0gMyAyICAtPiBTZXQgZm9yZWdyb3VuZCBjb2xvciB0byBHcmVlbi5cbiAqICAgICBQcyA9IDMgMyAgLT4gU2V0IGZvcmVncm91bmQgY29sb3IgdG8gWWVsbG93LlxuICogICAgIFBzID0gMyA0ICAtPiBTZXQgZm9yZWdyb3VuZCBjb2xvciB0byBCbHVlLlxuICogICAgIFBzID0gMyA1ICAtPiBTZXQgZm9yZWdyb3VuZCBjb2xvciB0byBNYWdlbnRhLlxuICogICAgIFBzID0gMyA2ICAtPiBTZXQgZm9yZWdyb3VuZCBjb2xvciB0byBDeWFuLlxuICogICAgIFBzID0gMyA3ICAtPiBTZXQgZm9yZWdyb3VuZCBjb2xvciB0byBXaGl0ZS5cbiAqICAgICBQcyA9IDMgOSAgLT4gU2V0IGZvcmVncm91bmQgY29sb3IgdG8gZGVmYXVsdCAob3JpZ2luYWwpLlxuICogICAgIFBzID0gNCAwICAtPiBTZXQgYmFja2dyb3VuZCBjb2xvciB0byBCbGFjay5cbiAqICAgICBQcyA9IDQgMSAgLT4gU2V0IGJhY2tncm91bmQgY29sb3IgdG8gUmVkLlxuICogICAgIFBzID0gNCAyICAtPiBTZXQgYmFja2dyb3VuZCBjb2xvciB0byBHcmVlbi5cbiAqICAgICBQcyA9IDQgMyAgLT4gU2V0IGJhY2tncm91bmQgY29sb3IgdG8gWWVsbG93LlxuICogICAgIFBzID0gNCA0ICAtPiBTZXQgYmFja2dyb3VuZCBjb2xvciB0byBCbHVlLlxuICogICAgIFBzID0gNCA1ICAtPiBTZXQgYmFja2dyb3VuZCBjb2xvciB0byBNYWdlbnRhLlxuICogICAgIFBzID0gNCA2ICAtPiBTZXQgYmFja2dyb3VuZCBjb2xvciB0byBDeWFuLlxuICogICAgIFBzID0gNCA3ICAtPiBTZXQgYmFja2dyb3VuZCBjb2xvciB0byBXaGl0ZS5cbiAqICAgICBQcyA9IDQgOSAgLT4gU2V0IGJhY2tncm91bmQgY29sb3IgdG8gZGVmYXVsdCAob3JpZ2luYWwpLlxuICpcbiAqICAgSWYgMTYtY29sb3Igc3VwcG9ydCBpcyBjb21waWxlZCwgdGhlIGZvbGxvd2luZyBhcHBseS4gIEFzc3VtZVxuICogICB0aGF0IHh0ZXJtJ3MgcmVzb3VyY2VzIGFyZSBzZXQgc28gdGhhdCB0aGUgSVNPIGNvbG9yIGNvZGVzIGFyZVxuICogICB0aGUgZmlyc3QgOCBvZiBhIHNldCBvZiAxNi4gIFRoZW4gdGhlIGFpeHRlcm0gY29sb3JzIGFyZSB0aGVcbiAqICAgYnJpZ2h0IHZlcnNpb25zIG9mIHRoZSBJU08gY29sb3JzOlxuICogICAgIFBzID0gOSAwICAtPiBTZXQgZm9yZWdyb3VuZCBjb2xvciB0byBCbGFjay5cbiAqICAgICBQcyA9IDkgMSAgLT4gU2V0IGZvcmVncm91bmQgY29sb3IgdG8gUmVkLlxuICogICAgIFBzID0gOSAyICAtPiBTZXQgZm9yZWdyb3VuZCBjb2xvciB0byBHcmVlbi5cbiAqICAgICBQcyA9IDkgMyAgLT4gU2V0IGZvcmVncm91bmQgY29sb3IgdG8gWWVsbG93LlxuICogICAgIFBzID0gOSA0ICAtPiBTZXQgZm9yZWdyb3VuZCBjb2xvciB0byBCbHVlLlxuICogICAgIFBzID0gOSA1ICAtPiBTZXQgZm9yZWdyb3VuZCBjb2xvciB0byBNYWdlbnRhLlxuICogICAgIFBzID0gOSA2ICAtPiBTZXQgZm9yZWdyb3VuZCBjb2xvciB0byBDeWFuLlxuICogICAgIFBzID0gOSA3ICAtPiBTZXQgZm9yZWdyb3VuZCBjb2xvciB0byBXaGl0ZS5cbiAqICAgICBQcyA9IDEgMCAwICAtPiBTZXQgYmFja2dyb3VuZCBjb2xvciB0byBCbGFjay5cbiAqICAgICBQcyA9IDEgMCAxICAtPiBTZXQgYmFja2dyb3VuZCBjb2xvciB0byBSZWQuXG4gKiAgICAgUHMgPSAxIDAgMiAgLT4gU2V0IGJhY2tncm91bmQgY29sb3IgdG8gR3JlZW4uXG4gKiAgICAgUHMgPSAxIDAgMyAgLT4gU2V0IGJhY2tncm91bmQgY29sb3IgdG8gWWVsbG93LlxuICogICAgIFBzID0gMSAwIDQgIC0+IFNldCBiYWNrZ3JvdW5kIGNvbG9yIHRvIEJsdWUuXG4gKiAgICAgUHMgPSAxIDAgNSAgLT4gU2V0IGJhY2tncm91bmQgY29sb3IgdG8gTWFnZW50YS5cbiAqICAgICBQcyA9IDEgMCA2ICAtPiBTZXQgYmFja2dyb3VuZCBjb2xvciB0byBDeWFuLlxuICogICAgIFBzID0gMSAwIDcgIC0+IFNldCBiYWNrZ3JvdW5kIGNvbG9yIHRvIFdoaXRlLlxuICpcbiAqICAgSWYgeHRlcm0gaXMgY29tcGlsZWQgd2l0aCB0aGUgMTYtY29sb3Igc3VwcG9ydCBkaXNhYmxlZCwgaXRcbiAqICAgc3VwcG9ydHMgdGhlIGZvbGxvd2luZywgZnJvbSByeHZ0OlxuICogICAgIFBzID0gMSAwIDAgIC0+IFNldCBmb3JlZ3JvdW5kIGFuZCBiYWNrZ3JvdW5kIGNvbG9yIHRvXG4gKiAgICAgZGVmYXVsdC5cbiAqXG4gKiAgIElmIDg4LSBvciAyNTYtY29sb3Igc3VwcG9ydCBpcyBjb21waWxlZCwgdGhlIGZvbGxvd2luZyBhcHBseS5cbiAqICAgICBQcyA9IDMgOCAgOyA1ICA7IFBzIC0+IFNldCBmb3JlZ3JvdW5kIGNvbG9yIHRvIHRoZSBzZWNvbmRcbiAqICAgICBQcy5cbiAqICAgICBQcyA9IDQgOCAgOyA1ICA7IFBzIC0+IFNldCBiYWNrZ3JvdW5kIGNvbG9yIHRvIHRoZSBzZWNvbmRcbiAqICAgICBQcy5cbiAqL1Rlcm1pbmFsLnByb3RvdHlwZS5jaGFyQXR0cmlidXRlcz1mdW5jdGlvbihwYXJhbXMpey8vIE9wdGltaXplIGEgc2luZ2xlIFNHUjAuXG5pZihwYXJhbXMubGVuZ3RoPT09MSYmcGFyYW1zWzBdPT09MCl7dGhpcy5jdXJBdHRyPXRoaXMuZGVmQXR0cjtyZXR1cm47fXZhciBsPXBhcmFtcy5sZW5ndGgsaT0wLGZsYWdzPXRoaXMuY3VyQXR0cj4+MTgsZmc9dGhpcy5jdXJBdHRyPj45JjB4MWZmLGJnPXRoaXMuY3VyQXR0ciYweDFmZixwO2Zvcig7aTxsO2krKyl7cD1wYXJhbXNbaV07aWYocD49MzAmJnA8PTM3KXsvLyBmZyBjb2xvciA4XG5mZz1wLTMwO31lbHNlIGlmKHA+PTQwJiZwPD00Nyl7Ly8gYmcgY29sb3IgOFxuYmc9cC00MDt9ZWxzZSBpZihwPj05MCYmcDw9OTcpey8vIGZnIGNvbG9yIDE2XG5wKz04O2ZnPXAtOTA7fWVsc2UgaWYocD49MTAwJiZwPD0xMDcpey8vIGJnIGNvbG9yIDE2XG5wKz04O2JnPXAtMTAwO31lbHNlIGlmKHA9PT0wKXsvLyBkZWZhdWx0XG5mbGFncz10aGlzLmRlZkF0dHI+PjE4O2ZnPXRoaXMuZGVmQXR0cj4+OSYweDFmZjtiZz10aGlzLmRlZkF0dHImMHgxZmY7Ly8gZmxhZ3MgPSAwO1xuLy8gZmcgPSAweDFmZjtcbi8vIGJnID0gMHgxZmY7XG59ZWxzZSBpZihwPT09MSl7Ly8gYm9sZCB0ZXh0XG5mbGFnc3w9MTt9ZWxzZSBpZihwPT09NCl7Ly8gdW5kZXJsaW5lZCB0ZXh0XG5mbGFnc3w9Mjt9ZWxzZSBpZihwPT09NSl7Ly8gYmxpbmtcbmZsYWdzfD00O31lbHNlIGlmKHA9PT03KXsvLyBpbnZlcnNlIGFuZCBwb3NpdGl2ZVxuLy8gdGVzdCB3aXRoOiBlY2hvIC1lICdcXGVbMzFtXFxlWzQybWhlbGxvXFxlWzdtd29ybGRcXGVbMjdtaGlcXGVbbSdcbmZsYWdzfD04O31lbHNlIGlmKHA9PT04KXsvLyBpbnZpc2libGVcbmZsYWdzfD0xNjt9ZWxzZSBpZihwPT09MjIpey8vIG5vdCBib2xkXG5mbGFncyY9fjE7fWVsc2UgaWYocD09PTI0KXsvLyBub3QgdW5kZXJsaW5lZFxuZmxhZ3MmPX4yO31lbHNlIGlmKHA9PT0yNSl7Ly8gbm90IGJsaW5rXG5mbGFncyY9fjQ7fWVsc2UgaWYocD09PTI3KXsvLyBub3QgaW52ZXJzZVxuZmxhZ3MmPX44O31lbHNlIGlmKHA9PT0yOCl7Ly8gbm90IGludmlzaWJsZVxuZmxhZ3MmPX4xNjt9ZWxzZSBpZihwPT09Mzkpey8vIHJlc2V0IGZnXG5mZz10aGlzLmRlZkF0dHI+PjkmMHgxZmY7fWVsc2UgaWYocD09PTQ5KXsvLyByZXNldCBiZ1xuYmc9dGhpcy5kZWZBdHRyJjB4MWZmO31lbHNlIGlmKHA9PT0zOCl7Ly8gZmcgY29sb3IgMjU2XG5pZihwYXJhbXNbaSsxXT09PTIpe2krPTI7Zmc9bWF0Y2hDb2xvcihwYXJhbXNbaV0mMHhmZixwYXJhbXNbaSsxXSYweGZmLHBhcmFtc1tpKzJdJjB4ZmYpO2lmKGZnPT09LTEpZmc9MHgxZmY7aSs9Mjt9ZWxzZSBpZihwYXJhbXNbaSsxXT09PTUpe2krPTI7cD1wYXJhbXNbaV0mMHhmZjtmZz1wO319ZWxzZSBpZihwPT09NDgpey8vIGJnIGNvbG9yIDI1NlxuaWYocGFyYW1zW2krMV09PT0yKXtpKz0yO2JnPW1hdGNoQ29sb3IocGFyYW1zW2ldJjB4ZmYscGFyYW1zW2krMV0mMHhmZixwYXJhbXNbaSsyXSYweGZmKTtpZihiZz09PS0xKWJnPTB4MWZmO2krPTI7fWVsc2UgaWYocGFyYW1zW2krMV09PT01KXtpKz0yO3A9cGFyYW1zW2ldJjB4ZmY7Ymc9cDt9fWVsc2UgaWYocD09PTEwMCl7Ly8gcmVzZXQgZmcvYmdcbmZnPXRoaXMuZGVmQXR0cj4+OSYweDFmZjtiZz10aGlzLmRlZkF0dHImMHgxZmY7fWVsc2V7dGhpcy5lcnJvcignVW5rbm93biBTR1IgYXR0cmlidXRlOiAlZC4nLHApO319dGhpcy5jdXJBdHRyPWZsYWdzPDwxOHxmZzw8OXxiZzt9Oy8qKlxuICogQ1NJIFBzIG4gIERldmljZSBTdGF0dXMgUmVwb3J0IChEU1IpLlxuICogICAgIFBzID0gNSAgLT4gU3RhdHVzIFJlcG9ydC4gIFJlc3VsdCAoYGBPSycnKSBpc1xuICogICBDU0kgMCBuXG4gKiAgICAgUHMgPSA2ICAtPiBSZXBvcnQgQ3Vyc29yIFBvc2l0aW9uIChDUFIpIFtyb3c7Y29sdW1uXS5cbiAqICAgUmVzdWx0IGlzXG4gKiAgIENTSSByIDsgYyBSXG4gKiBDU0kgPyBQcyBuXG4gKiAgIERldmljZSBTdGF0dXMgUmVwb3J0IChEU1IsIERFQy1zcGVjaWZpYykuXG4gKiAgICAgUHMgPSA2ICAtPiBSZXBvcnQgQ3Vyc29yIFBvc2l0aW9uIChDUFIpIFtyb3c7Y29sdW1uXSBhcyBDU0lcbiAqICAgICA/IHIgOyBjIFIgKGFzc3VtZXMgcGFnZSBpcyB6ZXJvKS5cbiAqICAgICBQcyA9IDEgNSAgLT4gUmVwb3J0IFByaW50ZXIgc3RhdHVzIGFzIENTSSA/IDEgMCAgbiAgKHJlYWR5KS5cbiAqICAgICBvciBDU0kgPyAxIDEgIG4gIChub3QgcmVhZHkpLlxuICogICAgIFBzID0gMiA1ICAtPiBSZXBvcnQgVURLIHN0YXR1cyBhcyBDU0kgPyAyIDAgIG4gICh1bmxvY2tlZClcbiAqICAgICBvciBDU0kgPyAyIDEgIG4gIChsb2NrZWQpLlxuICogICAgIFBzID0gMiA2ICAtPiBSZXBvcnQgS2V5Ym9hcmQgc3RhdHVzIGFzXG4gKiAgIENTSSA/IDIgNyAgOyAgMSAgOyAgMCAgOyAgMCAgbiAgKE5vcnRoIEFtZXJpY2FuKS5cbiAqICAgVGhlIGxhc3QgdHdvIHBhcmFtZXRlcnMgYXBwbHkgdG8gVlQ0MDAgJiB1cCwgYW5kIGRlbm90ZSBrZXktXG4gKiAgIGJvYXJkIHJlYWR5IGFuZCBMSzAxIHJlc3BlY3RpdmVseS5cbiAqICAgICBQcyA9IDUgMyAgLT4gUmVwb3J0IExvY2F0b3Igc3RhdHVzIGFzXG4gKiAgIENTSSA/IDUgMyAgbiAgTG9jYXRvciBhdmFpbGFibGUsIGlmIGNvbXBpbGVkLWluLCBvclxuICogICBDU0kgPyA1IDAgIG4gIE5vIExvY2F0b3IsIGlmIG5vdC5cbiAqL1Rlcm1pbmFsLnByb3RvdHlwZS5kZXZpY2VTdGF0dXM9ZnVuY3Rpb24ocGFyYW1zKXtpZighdGhpcy5wcmVmaXgpe3N3aXRjaChwYXJhbXNbMF0pe2Nhc2UgNTovLyBzdGF0dXMgcmVwb3J0XG50aGlzLnNlbmQoJ1xceDFiWzBuJyk7YnJlYWs7Y2FzZSA2Oi8vIGN1cnNvciBwb3NpdGlvblxudGhpcy5zZW5kKCdcXHgxYlsnKyh0aGlzLnkrMSkrJzsnKyh0aGlzLngrMSkrJ1InKTticmVhazt9fWVsc2UgaWYodGhpcy5wcmVmaXg9PT0nPycpey8vIG1vZGVybiB4dGVybSBkb2VzbnQgc2VlbSB0b1xuLy8gcmVzcG9uZCB0byBhbnkgb2YgdGhlc2UgZXhjZXB0ID82LCA2LCBhbmQgNVxuc3dpdGNoKHBhcmFtc1swXSl7Y2FzZSA2Oi8vIGN1cnNvciBwb3NpdGlvblxudGhpcy5zZW5kKCdcXHgxYls/JysodGhpcy55KzEpKyc7JysodGhpcy54KzEpKydSJyk7YnJlYWs7Y2FzZSAxNTovLyBubyBwcmludGVyXG4vLyB0aGlzLnNlbmQoJ1xceDFiWz8xMW4nKTtcbmJyZWFrO2Nhc2UgMjU6Ly8gZG9udCBzdXBwb3J0IHVzZXIgZGVmaW5lZCBrZXlzXG4vLyB0aGlzLnNlbmQoJ1xceDFiWz8yMW4nKTtcbmJyZWFrO2Nhc2UgMjY6Ly8gbm9ydGggYW1lcmljYW4ga2V5Ym9hcmRcbi8vIHRoaXMuc2VuZCgnXFx4MWJbPzI3OzE7MDswbicpO1xuYnJlYWs7Y2FzZSA1MzovLyBubyBkZWMgbG9jYXRvci9tb3VzZVxuLy8gdGhpcy5zZW5kKCdcXHgxYls/NTBuJyk7XG5icmVhazt9fX07LyoqXG4gKiBBZGRpdGlvbnNcbiAqLy8qKlxuICogQ1NJIFBzIEBcbiAqIEluc2VydCBQcyAoQmxhbmspIENoYXJhY3RlcihzKSAoZGVmYXVsdCA9IDEpIChJQ0gpLlxuICovVGVybWluYWwucHJvdG90eXBlLmluc2VydENoYXJzPWZ1bmN0aW9uKHBhcmFtcyl7dmFyIHBhcmFtLHJvdyxqLGNoO3BhcmFtPXBhcmFtc1swXTtpZihwYXJhbTwxKXBhcmFtPTE7cm93PXRoaXMueSt0aGlzLnliYXNlO2o9dGhpcy54O2NoPVt0aGlzLmVyYXNlQXR0cigpLCcgJywxXTsvLyB4dGVybVxud2hpbGUocGFyYW0tLSYmajx0aGlzLmNvbHMpe3RoaXMubGluZXNbcm93XS5zcGxpY2UoaisrLDAsY2gpO3RoaXMubGluZXNbcm93XS5wb3AoKTt9fTsvKipcbiAqIENTSSBQcyBFXG4gKiBDdXJzb3IgTmV4dCBMaW5lIFBzIFRpbWVzIChkZWZhdWx0ID0gMSkgKENOTCkuXG4gKiBzYW1lIGFzIENTSSBQcyBCID9cbiAqL1Rlcm1pbmFsLnByb3RvdHlwZS5jdXJzb3JOZXh0TGluZT1mdW5jdGlvbihwYXJhbXMpe3ZhciBwYXJhbT1wYXJhbXNbMF07aWYocGFyYW08MSlwYXJhbT0xO3RoaXMueSs9cGFyYW07aWYodGhpcy55Pj10aGlzLnJvd3Mpe3RoaXMueT10aGlzLnJvd3MtMTt9dGhpcy54PTA7fTsvKipcbiAqIENTSSBQcyBGXG4gKiBDdXJzb3IgUHJlY2VkaW5nIExpbmUgUHMgVGltZXMgKGRlZmF1bHQgPSAxKSAoQ05MKS5cbiAqIHJldXNlIENTSSBQcyBBID9cbiAqL1Rlcm1pbmFsLnByb3RvdHlwZS5jdXJzb3JQcmVjZWRpbmdMaW5lPWZ1bmN0aW9uKHBhcmFtcyl7dmFyIHBhcmFtPXBhcmFtc1swXTtpZihwYXJhbTwxKXBhcmFtPTE7dGhpcy55LT1wYXJhbTtpZih0aGlzLnk8MCl0aGlzLnk9MDt0aGlzLng9MDt9Oy8qKlxuICogQ1NJIFBzIEdcbiAqIEN1cnNvciBDaGFyYWN0ZXIgQWJzb2x1dGUgIFtjb2x1bW5dIChkZWZhdWx0ID0gW3JvdywxXSkgKENIQSkuXG4gKi9UZXJtaW5hbC5wcm90b3R5cGUuY3Vyc29yQ2hhckFic29sdXRlPWZ1bmN0aW9uKHBhcmFtcyl7dmFyIHBhcmFtPXBhcmFtc1swXTtpZihwYXJhbTwxKXBhcmFtPTE7dGhpcy54PXBhcmFtLTE7fTsvKipcbiAqIENTSSBQcyBMXG4gKiBJbnNlcnQgUHMgTGluZShzKSAoZGVmYXVsdCA9IDEpIChJTCkuXG4gKi9UZXJtaW5hbC5wcm90b3R5cGUuaW5zZXJ0TGluZXM9ZnVuY3Rpb24ocGFyYW1zKXt2YXIgcGFyYW0scm93LGo7cGFyYW09cGFyYW1zWzBdO2lmKHBhcmFtPDEpcGFyYW09MTtyb3c9dGhpcy55K3RoaXMueWJhc2U7aj10aGlzLnJvd3MtMS10aGlzLnNjcm9sbEJvdHRvbTtqPXRoaXMucm93cy0xK3RoaXMueWJhc2UtaisxO3doaWxlKHBhcmFtLS0pey8vIHRlc3Q6IGVjaG8gLWUgJ1xcZVs0NG1cXGVbMUxcXGVbMG0nXG4vLyBibGFua0xpbmUodHJ1ZSkgLSB4dGVybS9saW51eCBiZWhhdmlvclxudGhpcy5saW5lcy5zcGxpY2Uocm93LDAsdGhpcy5ibGFua0xpbmUodHJ1ZSkpO3RoaXMubGluZXMuc3BsaWNlKGosMSk7fS8vIHRoaXMubWF4UmFuZ2UoKTtcbnRoaXMudXBkYXRlUmFuZ2UodGhpcy55KTt0aGlzLnVwZGF0ZVJhbmdlKHRoaXMuc2Nyb2xsQm90dG9tKTt9Oy8qKlxuICogQ1NJIFBzIE1cbiAqIERlbGV0ZSBQcyBMaW5lKHMpIChkZWZhdWx0ID0gMSkgKERMKS5cbiAqL1Rlcm1pbmFsLnByb3RvdHlwZS5kZWxldGVMaW5lcz1mdW5jdGlvbihwYXJhbXMpe3ZhciBwYXJhbSxyb3csajtwYXJhbT1wYXJhbXNbMF07aWYocGFyYW08MSlwYXJhbT0xO3Jvdz10aGlzLnkrdGhpcy55YmFzZTtqPXRoaXMucm93cy0xLXRoaXMuc2Nyb2xsQm90dG9tO2o9dGhpcy5yb3dzLTErdGhpcy55YmFzZS1qO3doaWxlKHBhcmFtLS0pey8vIHRlc3Q6IGVjaG8gLWUgJ1xcZVs0NG1cXGVbMU1cXGVbMG0nXG4vLyBibGFua0xpbmUodHJ1ZSkgLSB4dGVybS9saW51eCBiZWhhdmlvclxudGhpcy5saW5lcy5zcGxpY2UoaisxLDAsdGhpcy5ibGFua0xpbmUodHJ1ZSkpO3RoaXMubGluZXMuc3BsaWNlKHJvdywxKTt9Ly8gdGhpcy5tYXhSYW5nZSgpO1xudGhpcy51cGRhdGVSYW5nZSh0aGlzLnkpO3RoaXMudXBkYXRlUmFuZ2UodGhpcy5zY3JvbGxCb3R0b20pO307LyoqXG4gKiBDU0kgUHMgUFxuICogRGVsZXRlIFBzIENoYXJhY3RlcihzKSAoZGVmYXVsdCA9IDEpIChEQ0gpLlxuICovVGVybWluYWwucHJvdG90eXBlLmRlbGV0ZUNoYXJzPWZ1bmN0aW9uKHBhcmFtcyl7dmFyIHBhcmFtLHJvdyxjaDtwYXJhbT1wYXJhbXNbMF07aWYocGFyYW08MSlwYXJhbT0xO3Jvdz10aGlzLnkrdGhpcy55YmFzZTtjaD1bdGhpcy5lcmFzZUF0dHIoKSwnICcsMV07Ly8geHRlcm1cbndoaWxlKHBhcmFtLS0pe3RoaXMubGluZXNbcm93XS5zcGxpY2UodGhpcy54LDEpO3RoaXMubGluZXNbcm93XS5wdXNoKGNoKTt9fTsvKipcbiAqIENTSSBQcyBYXG4gKiBFcmFzZSBQcyBDaGFyYWN0ZXIocykgKGRlZmF1bHQgPSAxKSAoRUNIKS5cbiAqL1Rlcm1pbmFsLnByb3RvdHlwZS5lcmFzZUNoYXJzPWZ1bmN0aW9uKHBhcmFtcyl7dmFyIHBhcmFtLHJvdyxqLGNoO3BhcmFtPXBhcmFtc1swXTtpZihwYXJhbTwxKXBhcmFtPTE7cm93PXRoaXMueSt0aGlzLnliYXNlO2o9dGhpcy54O2NoPVt0aGlzLmVyYXNlQXR0cigpLCcgJywxXTsvLyB4dGVybVxud2hpbGUocGFyYW0tLSYmajx0aGlzLmNvbHMpe3RoaXMubGluZXNbcm93XVtqKytdPWNoO319Oy8qKlxuICogQ1NJIFBtIGAgIENoYXJhY3RlciBQb3NpdGlvbiBBYnNvbHV0ZVxuICogICBbY29sdW1uXSAoZGVmYXVsdCA9IFtyb3csMV0pIChIUEEpLlxuICovVGVybWluYWwucHJvdG90eXBlLmNoYXJQb3NBYnNvbHV0ZT1mdW5jdGlvbihwYXJhbXMpe3ZhciBwYXJhbT1wYXJhbXNbMF07aWYocGFyYW08MSlwYXJhbT0xO3RoaXMueD1wYXJhbS0xO2lmKHRoaXMueD49dGhpcy5jb2xzKXt0aGlzLng9dGhpcy5jb2xzLTE7fX07LyoqXG4gKiAxNDEgNjEgYSAqIEhQUiAtXG4gKiBIb3Jpem9udGFsIFBvc2l0aW9uIFJlbGF0aXZlXG4gKiByZXVzZSBDU0kgUHMgQyA/XG4gKi9UZXJtaW5hbC5wcm90b3R5cGUuSFBvc2l0aW9uUmVsYXRpdmU9ZnVuY3Rpb24ocGFyYW1zKXt2YXIgcGFyYW09cGFyYW1zWzBdO2lmKHBhcmFtPDEpcGFyYW09MTt0aGlzLngrPXBhcmFtO2lmKHRoaXMueD49dGhpcy5jb2xzKXt0aGlzLng9dGhpcy5jb2xzLTE7fX07LyoqXG4gKiBDU0kgUHMgYyAgU2VuZCBEZXZpY2UgQXR0cmlidXRlcyAoUHJpbWFyeSBEQSkuXG4gKiAgICAgUHMgPSAwICBvciBvbWl0dGVkIC0+IHJlcXVlc3QgYXR0cmlidXRlcyBmcm9tIHRlcm1pbmFsLiAgVGhlXG4gKiAgICAgcmVzcG9uc2UgZGVwZW5kcyBvbiB0aGUgZGVjVGVybWluYWxJRCByZXNvdXJjZSBzZXR0aW5nLlxuICogICAgIC0+IENTSSA/IDEgOyAyIGMgIChgYFZUMTAwIHdpdGggQWR2YW5jZWQgVmlkZW8gT3B0aW9uJycpXG4gKiAgICAgLT4gQ1NJID8gMSA7IDAgYyAgKGBgVlQxMDEgd2l0aCBObyBPcHRpb25zJycpXG4gKiAgICAgLT4gQ1NJID8gNiBjICAoYGBWVDEwMicnKVxuICogICAgIC0+IENTSSA/IDYgMCA7IDEgOyAyIDsgNiA7IDggOyA5IDsgMSA1IDsgYyAgKGBgVlQyMjAnJylcbiAqICAgVGhlIFZUMTAwLXN0eWxlIHJlc3BvbnNlIHBhcmFtZXRlcnMgZG8gbm90IG1lYW4gYW55dGhpbmcgYnlcbiAqICAgdGhlbXNlbHZlcy4gIFZUMjIwIHBhcmFtZXRlcnMgZG8sIHRlbGxpbmcgdGhlIGhvc3Qgd2hhdCBmZWEtXG4gKiAgIHR1cmVzIHRoZSB0ZXJtaW5hbCBzdXBwb3J0czpcbiAqICAgICBQcyA9IDEgIC0+IDEzMi1jb2x1bW5zLlxuICogICAgIFBzID0gMiAgLT4gUHJpbnRlci5cbiAqICAgICBQcyA9IDYgIC0+IFNlbGVjdGl2ZSBlcmFzZS5cbiAqICAgICBQcyA9IDggIC0+IFVzZXItZGVmaW5lZCBrZXlzLlxuICogICAgIFBzID0gOSAgLT4gTmF0aW9uYWwgcmVwbGFjZW1lbnQgY2hhcmFjdGVyIHNldHMuXG4gKiAgICAgUHMgPSAxIDUgIC0+IFRlY2huaWNhbCBjaGFyYWN0ZXJzLlxuICogICAgIFBzID0gMiAyICAtPiBBTlNJIGNvbG9yLCBlLmcuLCBWVDUyNS5cbiAqICAgICBQcyA9IDIgOSAgLT4gQU5TSSB0ZXh0IGxvY2F0b3IgKGkuZS4sIERFQyBMb2NhdG9yIG1vZGUpLlxuICogQ1NJID4gUHMgY1xuICogICBTZW5kIERldmljZSBBdHRyaWJ1dGVzIChTZWNvbmRhcnkgREEpLlxuICogICAgIFBzID0gMCAgb3Igb21pdHRlZCAtPiByZXF1ZXN0IHRoZSB0ZXJtaW5hbCdzIGlkZW50aWZpY2F0aW9uXG4gKiAgICAgY29kZS4gIFRoZSByZXNwb25zZSBkZXBlbmRzIG9uIHRoZSBkZWNUZXJtaW5hbElEIHJlc291cmNlIHNldC1cbiAqICAgICB0aW5nLiAgSXQgc2hvdWxkIGFwcGx5IG9ubHkgdG8gVlQyMjAgYW5kIHVwLCBidXQgeHRlcm0gZXh0ZW5kc1xuICogICAgIHRoaXMgdG8gVlQxMDAuXG4gKiAgICAgLT4gQ1NJICA+IFBwIDsgUHYgOyBQYyBjXG4gKiAgIHdoZXJlIFBwIGRlbm90ZXMgdGhlIHRlcm1pbmFsIHR5cGVcbiAqICAgICBQcCA9IDAgIC0+IGBgVlQxMDAnJy5cbiAqICAgICBQcCA9IDEgIC0+IGBgVlQyMjAnJy5cbiAqICAgYW5kIFB2IGlzIHRoZSBmaXJtd2FyZSB2ZXJzaW9uIChmb3IgeHRlcm0sIHRoaXMgd2FzIG9yaWdpbmFsbHlcbiAqICAgdGhlIFhGcmVlODYgcGF0Y2ggbnVtYmVyLCBzdGFydGluZyB3aXRoIDk1KS4gIEluIGEgREVDIHRlcm1pLVxuICogICBuYWwsIFBjIGluZGljYXRlcyB0aGUgUk9NIGNhcnRyaWRnZSByZWdpc3RyYXRpb24gbnVtYmVyIGFuZCBpc1xuICogICBhbHdheXMgemVyby5cbiAqIE1vcmUgaW5mb3JtYXRpb246XG4gKiAgIHh0ZXJtL2NoYXJwcm9jLmMgLSBsaW5lIDIwMTIsIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICogICB2aW0gcmVzcG9uZHMgd2l0aCBeW1s/MGMgb3IgXltbPzFjIGFmdGVyIHRoZSB0ZXJtaW5hbCdzIHJlc3BvbnNlICg/KVxuICovVGVybWluYWwucHJvdG90eXBlLnNlbmREZXZpY2VBdHRyaWJ1dGVzPWZ1bmN0aW9uKHBhcmFtcyl7aWYocGFyYW1zWzBdPjApcmV0dXJuO2lmKCF0aGlzLnByZWZpeCl7aWYodGhpcy5pcygneHRlcm0nKXx8dGhpcy5pcygncnh2dC11bmljb2RlJyl8fHRoaXMuaXMoJ3NjcmVlbicpKXt0aGlzLnNlbmQoJ1xceDFiWz8xOzJjJyk7fWVsc2UgaWYodGhpcy5pcygnbGludXgnKSl7dGhpcy5zZW5kKCdcXHgxYls/NmMnKTt9fWVsc2UgaWYodGhpcy5wcmVmaXg9PT0nPicpey8vIHh0ZXJtIGFuZCB1cnh2dFxuLy8gc2VlbSB0byBzcGl0IHRoaXNcbi8vIG91dCBhcm91bmQgfjM3MCB0aW1lcyAoPykuXG5pZih0aGlzLmlzKCd4dGVybScpKXt0aGlzLnNlbmQoJ1xceDFiWz4wOzI3NjswYycpO31lbHNlIGlmKHRoaXMuaXMoJ3J4dnQtdW5pY29kZScpKXt0aGlzLnNlbmQoJ1xceDFiWz44NTs5NTswYycpO31lbHNlIGlmKHRoaXMuaXMoJ2xpbnV4Jykpey8vIG5vdCBzdXBwb3J0ZWQgYnkgbGludXggY29uc29sZS5cbi8vIGxpbnV4IGNvbnNvbGUgZWNob2VzIHBhcmFtZXRlcnMuXG50aGlzLnNlbmQocGFyYW1zWzBdKydjJyk7fWVsc2UgaWYodGhpcy5pcygnc2NyZWVuJykpe3RoaXMuc2VuZCgnXFx4MWJbPjgzOzQwMDAzOzBjJyk7fX19Oy8qKlxuICogQ1NJIFBtIGRcbiAqIExpbmUgUG9zaXRpb24gQWJzb2x1dGUgIFtyb3ddIChkZWZhdWx0ID0gWzEsY29sdW1uXSkgKFZQQSkuXG4gKi9UZXJtaW5hbC5wcm90b3R5cGUubGluZVBvc0Fic29sdXRlPWZ1bmN0aW9uKHBhcmFtcyl7dmFyIHBhcmFtPXBhcmFtc1swXTtpZihwYXJhbTwxKXBhcmFtPTE7dGhpcy55PXBhcmFtLTE7aWYodGhpcy55Pj10aGlzLnJvd3Mpe3RoaXMueT10aGlzLnJvd3MtMTt9fTsvKipcbiAqIDE0NSA2NSBlICogVlBSIC0gVmVydGljYWwgUG9zaXRpb24gUmVsYXRpdmVcbiAqIHJldXNlIENTSSBQcyBCID9cbiAqL1Rlcm1pbmFsLnByb3RvdHlwZS5WUG9zaXRpb25SZWxhdGl2ZT1mdW5jdGlvbihwYXJhbXMpe3ZhciBwYXJhbT1wYXJhbXNbMF07aWYocGFyYW08MSlwYXJhbT0xO3RoaXMueSs9cGFyYW07aWYodGhpcy55Pj10aGlzLnJvd3Mpe3RoaXMueT10aGlzLnJvd3MtMTt9fTsvKipcbiAqIENTSSBQcyA7IFBzIGZcbiAqICAgSG9yaXpvbnRhbCBhbmQgVmVydGljYWwgUG9zaXRpb24gW3Jvdztjb2x1bW5dIChkZWZhdWx0ID1cbiAqICAgWzEsMV0pIChIVlApLlxuICovVGVybWluYWwucHJvdG90eXBlLkhWUG9zaXRpb249ZnVuY3Rpb24ocGFyYW1zKXtpZihwYXJhbXNbMF08MSlwYXJhbXNbMF09MTtpZihwYXJhbXNbMV08MSlwYXJhbXNbMV09MTt0aGlzLnk9cGFyYW1zWzBdLTE7aWYodGhpcy55Pj10aGlzLnJvd3Mpe3RoaXMueT10aGlzLnJvd3MtMTt9dGhpcy54PXBhcmFtc1sxXS0xO2lmKHRoaXMueD49dGhpcy5jb2xzKXt0aGlzLng9dGhpcy5jb2xzLTE7fX07LyoqXG4gKiBDU0kgUG0gaCAgU2V0IE1vZGUgKFNNKS5cbiAqICAgICBQcyA9IDIgIC0+IEtleWJvYXJkIEFjdGlvbiBNb2RlIChBTSkuXG4gKiAgICAgUHMgPSA0ICAtPiBJbnNlcnQgTW9kZSAoSVJNKS5cbiAqICAgICBQcyA9IDEgMiAgLT4gU2VuZC9yZWNlaXZlIChTUk0pLlxuICogICAgIFBzID0gMiAwICAtPiBBdXRvbWF0aWMgTmV3bGluZSAoTE5NKS5cbiAqIENTSSA/IFBtIGhcbiAqICAgREVDIFByaXZhdGUgTW9kZSBTZXQgKERFQ1NFVCkuXG4gKiAgICAgUHMgPSAxICAtPiBBcHBsaWNhdGlvbiBDdXJzb3IgS2V5cyAoREVDQ0tNKS5cbiAqICAgICBQcyA9IDIgIC0+IERlc2lnbmF0ZSBVU0FTQ0lJIGZvciBjaGFyYWN0ZXIgc2V0cyBHMC1HM1xuICogICAgIChERUNBTk0pLCBhbmQgc2V0IFZUMTAwIG1vZGUuXG4gKiAgICAgUHMgPSAzICAtPiAxMzIgQ29sdW1uIE1vZGUgKERFQ0NPTE0pLlxuICogICAgIFBzID0gNCAgLT4gU21vb3RoIChTbG93KSBTY3JvbGwgKERFQ1NDTE0pLlxuICogICAgIFBzID0gNSAgLT4gUmV2ZXJzZSBWaWRlbyAoREVDU0NOTSkuXG4gKiAgICAgUHMgPSA2ICAtPiBPcmlnaW4gTW9kZSAoREVDT00pLlxuICogICAgIFBzID0gNyAgLT4gV3JhcGFyb3VuZCBNb2RlIChERUNBV00pLlxuICogICAgIFBzID0gOCAgLT4gQXV0by1yZXBlYXQgS2V5cyAoREVDQVJNKS5cbiAqICAgICBQcyA9IDkgIC0+IFNlbmQgTW91c2UgWCAmIFkgb24gYnV0dG9uIHByZXNzLiAgU2VlIHRoZSBzZWMtXG4gKiAgICAgdGlvbiBNb3VzZSBUcmFja2luZy5cbiAqICAgICBQcyA9IDEgMCAgLT4gU2hvdyB0b29sYmFyIChyeHZ0KS5cbiAqICAgICBQcyA9IDEgMiAgLT4gU3RhcnQgQmxpbmtpbmcgQ3Vyc29yIChhdHQ2MTApLlxuICogICAgIFBzID0gMSA4ICAtPiBQcmludCBmb3JtIGZlZWQgKERFQ1BGRikuXG4gKiAgICAgUHMgPSAxIDkgIC0+IFNldCBwcmludCBleHRlbnQgdG8gZnVsbCBzY3JlZW4gKERFQ1BFWCkuXG4gKiAgICAgUHMgPSAyIDUgIC0+IFNob3cgQ3Vyc29yIChERUNUQ0VNKS5cbiAqICAgICBQcyA9IDMgMCAgLT4gU2hvdyBzY3JvbGxiYXIgKHJ4dnQpLlxuICogICAgIFBzID0gMyA1ICAtPiBFbmFibGUgZm9udC1zaGlmdGluZyBmdW5jdGlvbnMgKHJ4dnQpLlxuICogICAgIFBzID0gMyA4ICAtPiBFbnRlciBUZWt0cm9uaXggTW9kZSAoREVDVEVLKS5cbiAqICAgICBQcyA9IDQgMCAgLT4gQWxsb3cgODAgLT4gMTMyIE1vZGUuXG4gKiAgICAgUHMgPSA0IDEgIC0+IG1vcmUoMSkgZml4IChzZWUgY3Vyc2VzIHJlc291cmNlKS5cbiAqICAgICBQcyA9IDQgMiAgLT4gRW5hYmxlIE5hdGlvbiBSZXBsYWNlbWVudCBDaGFyYWN0ZXIgc2V0cyAoREVDTi1cbiAqICAgICBSQ00pLlxuICogICAgIFBzID0gNCA0ICAtPiBUdXJuIE9uIE1hcmdpbiBCZWxsLlxuICogICAgIFBzID0gNCA1ICAtPiBSZXZlcnNlLXdyYXBhcm91bmQgTW9kZS5cbiAqICAgICBQcyA9IDQgNiAgLT4gU3RhcnQgTG9nZ2luZy4gIFRoaXMgaXMgbm9ybWFsbHkgZGlzYWJsZWQgYnkgYVxuICogICAgIGNvbXBpbGUtdGltZSBvcHRpb24uXG4gKiAgICAgUHMgPSA0IDcgIC0+IFVzZSBBbHRlcm5hdGUgU2NyZWVuIEJ1ZmZlci4gIChUaGlzIG1heSBiZSBkaXMtXG4gKiAgICAgYWJsZWQgYnkgdGhlIHRpdGVJbmhpYml0IHJlc291cmNlKS5cbiAqICAgICBQcyA9IDYgNiAgLT4gQXBwbGljYXRpb24ga2V5cGFkIChERUNOS00pLlxuICogICAgIFBzID0gNiA3ICAtPiBCYWNrYXJyb3cga2V5IHNlbmRzIGJhY2tzcGFjZSAoREVDQktNKS5cbiAqICAgICBQcyA9IDEgMCAwIDAgIC0+IFNlbmQgTW91c2UgWCAmIFkgb24gYnV0dG9uIHByZXNzIGFuZFxuICogICAgIHJlbGVhc2UuICBTZWUgdGhlIHNlY3Rpb24gTW91c2UgVHJhY2tpbmcuXG4gKiAgICAgUHMgPSAxIDAgMCAxICAtPiBVc2UgSGlsaXRlIE1vdXNlIFRyYWNraW5nLlxuICogICAgIFBzID0gMSAwIDAgMiAgLT4gVXNlIENlbGwgTW90aW9uIE1vdXNlIFRyYWNraW5nLlxuICogICAgIFBzID0gMSAwIDAgMyAgLT4gVXNlIEFsbCBNb3Rpb24gTW91c2UgVHJhY2tpbmcuXG4gKiAgICAgUHMgPSAxIDAgMCA0ICAtPiBTZW5kIEZvY3VzSW4vRm9jdXNPdXQgZXZlbnRzLlxuICogICAgIFBzID0gMSAwIDAgNSAgLT4gRW5hYmxlIEV4dGVuZGVkIE1vdXNlIE1vZGUuXG4gKiAgICAgUHMgPSAxIDAgMSAwICAtPiBTY3JvbGwgdG8gYm90dG9tIG9uIHR0eSBvdXRwdXQgKHJ4dnQpLlxuICogICAgIFBzID0gMSAwIDEgMSAgLT4gU2Nyb2xsIHRvIGJvdHRvbSBvbiBrZXkgcHJlc3MgKHJ4dnQpLlxuICogICAgIFBzID0gMSAwIDMgNCAgLT4gSW50ZXJwcmV0IFwibWV0YVwiIGtleSwgc2V0cyBlaWdodGggYml0LlxuICogICAgIChlbmFibGVzIHRoZSBlaWdodEJpdElucHV0IHJlc291cmNlKS5cbiAqICAgICBQcyA9IDEgMCAzIDUgIC0+IEVuYWJsZSBzcGVjaWFsIG1vZGlmaWVycyBmb3IgQWx0IGFuZCBOdW0tXG4gKiAgICAgTG9jayBrZXlzLiAgKFRoaXMgZW5hYmxlcyB0aGUgbnVtTG9jayByZXNvdXJjZSkuXG4gKiAgICAgUHMgPSAxIDAgMyA2ICAtPiBTZW5kIEVTQyAgIHdoZW4gTWV0YSBtb2RpZmllcyBhIGtleS4gIChUaGlzXG4gKiAgICAgZW5hYmxlcyB0aGUgbWV0YVNlbmRzRXNjYXBlIHJlc291cmNlKS5cbiAqICAgICBQcyA9IDEgMCAzIDcgIC0+IFNlbmQgREVMIGZyb20gdGhlIGVkaXRpbmcta2V5cGFkIERlbGV0ZVxuICogICAgIGtleS5cbiAqICAgICBQcyA9IDEgMCAzIDkgIC0+IFNlbmQgRVNDICB3aGVuIEFsdCBtb2RpZmllcyBhIGtleS4gIChUaGlzXG4gKiAgICAgZW5hYmxlcyB0aGUgYWx0U2VuZHNFc2NhcGUgcmVzb3VyY2UpLlxuICogICAgIFBzID0gMSAwIDQgMCAgLT4gS2VlcCBzZWxlY3Rpb24gZXZlbiBpZiBub3QgaGlnaGxpZ2h0ZWQuXG4gKiAgICAgKFRoaXMgZW5hYmxlcyB0aGUga2VlcFNlbGVjdGlvbiByZXNvdXJjZSkuXG4gKiAgICAgUHMgPSAxIDAgNCAxICAtPiBVc2UgdGhlIENMSVBCT0FSRCBzZWxlY3Rpb24uICAoVGhpcyBlbmFibGVzXG4gKiAgICAgdGhlIHNlbGVjdFRvQ2xpcGJvYXJkIHJlc291cmNlKS5cbiAqICAgICBQcyA9IDEgMCA0IDIgIC0+IEVuYWJsZSBVcmdlbmN5IHdpbmRvdyBtYW5hZ2VyIGhpbnQgd2hlblxuICogICAgIENvbnRyb2wtRyBpcyByZWNlaXZlZC4gIChUaGlzIGVuYWJsZXMgdGhlIGJlbGxJc1VyZ2VudFxuICogICAgIHJlc291cmNlKS5cbiAqICAgICBQcyA9IDEgMCA0IDMgIC0+IEVuYWJsZSByYWlzaW5nIG9mIHRoZSB3aW5kb3cgd2hlbiBDb250cm9sLUdcbiAqICAgICBpcyByZWNlaXZlZC4gIChlbmFibGVzIHRoZSBwb3BPbkJlbGwgcmVzb3VyY2UpLlxuICogICAgIFBzID0gMSAwIDQgNyAgLT4gVXNlIEFsdGVybmF0ZSBTY3JlZW4gQnVmZmVyLiAgKFRoaXMgbWF5IGJlXG4gKiAgICAgZGlzYWJsZWQgYnkgdGhlIHRpdGVJbmhpYml0IHJlc291cmNlKS5cbiAqICAgICBQcyA9IDEgMCA0IDggIC0+IFNhdmUgY3Vyc29yIGFzIGluIERFQ1NDLiAgKFRoaXMgbWF5IGJlIGRpcy1cbiAqICAgICBhYmxlZCBieSB0aGUgdGl0ZUluaGliaXQgcmVzb3VyY2UpLlxuICogICAgIFBzID0gMSAwIDQgOSAgLT4gU2F2ZSBjdXJzb3IgYXMgaW4gREVDU0MgYW5kIHVzZSBBbHRlcm5hdGVcbiAqICAgICBTY3JlZW4gQnVmZmVyLCBjbGVhcmluZyBpdCBmaXJzdC4gIChUaGlzIG1heSBiZSBkaXNhYmxlZCBieVxuICogICAgIHRoZSB0aXRlSW5oaWJpdCByZXNvdXJjZSkuICBUaGlzIGNvbWJpbmVzIHRoZSBlZmZlY3RzIG9mIHRoZSAxXG4gKiAgICAgMCA0IDcgIGFuZCAxIDAgNCA4ICBtb2Rlcy4gIFVzZSB0aGlzIHdpdGggdGVybWluZm8tYmFzZWRcbiAqICAgICBhcHBsaWNhdGlvbnMgcmF0aGVyIHRoYW4gdGhlIDQgNyAgbW9kZS5cbiAqICAgICBQcyA9IDEgMCA1IDAgIC0+IFNldCB0ZXJtaW5mby90ZXJtY2FwIGZ1bmN0aW9uLWtleSBtb2RlLlxuICogICAgIFBzID0gMSAwIDUgMSAgLT4gU2V0IFN1biBmdW5jdGlvbi1rZXkgbW9kZS5cbiAqICAgICBQcyA9IDEgMCA1IDIgIC0+IFNldCBIUCBmdW5jdGlvbi1rZXkgbW9kZS5cbiAqICAgICBQcyA9IDEgMCA1IDMgIC0+IFNldCBTQ08gZnVuY3Rpb24ta2V5IG1vZGUuXG4gKiAgICAgUHMgPSAxIDAgNiAwICAtPiBTZXQgbGVnYWN5IGtleWJvYXJkIGVtdWxhdGlvbiAoWDExUjYpLlxuICogICAgIFBzID0gMSAwIDYgMSAgLT4gU2V0IFZUMjIwIGtleWJvYXJkIGVtdWxhdGlvbi5cbiAqICAgICBQcyA9IDIgMCAwIDQgIC0+IFNldCBicmFja2V0ZWQgcGFzdGUgbW9kZS5cbiAqIE1vZGVzOlxuICogICBodHRwOiAqdnQxMDAubmV0L2RvY3MvdnQyMjAtcm0vY2hhcHRlcjQuaHRtbFxuICovVGVybWluYWwucHJvdG90eXBlLnNldE1vZGU9ZnVuY3Rpb24ocGFyYW1zKXtpZigodHlwZW9mIHBhcmFtcz09PSd1bmRlZmluZWQnPyd1bmRlZmluZWQnOl90eXBlb2YocGFyYW1zKSk9PT0nb2JqZWN0Jyl7dmFyIGw9cGFyYW1zLmxlbmd0aCxpPTA7Zm9yKDtpPGw7aSsrKXt0aGlzLnNldE1vZGUocGFyYW1zW2ldKTt9cmV0dXJuO31pZighdGhpcy5wcmVmaXgpe3N3aXRjaChwYXJhbXMpe2Nhc2UgNDp0aGlzLmluc2VydE1vZGU9dHJ1ZTticmVhaztjYXNlIDIwOi8vdGhpcy5jb252ZXJ0RW9sID0gdHJ1ZTtcbmJyZWFrO319ZWxzZSBpZih0aGlzLnByZWZpeD09PSc/Jyl7c3dpdGNoKHBhcmFtcyl7Y2FzZSAxOnRoaXMuYXBwbGljYXRpb25DdXJzb3I9dHJ1ZTticmVhaztjYXNlIDI6dGhpcy5zZXRnQ2hhcnNldCgwLFRlcm1pbmFsLmNoYXJzZXRzLlVTKTt0aGlzLnNldGdDaGFyc2V0KDEsVGVybWluYWwuY2hhcnNldHMuVVMpO3RoaXMuc2V0Z0NoYXJzZXQoMixUZXJtaW5hbC5jaGFyc2V0cy5VUyk7dGhpcy5zZXRnQ2hhcnNldCgzLFRlcm1pbmFsLmNoYXJzZXRzLlVTKTsvLyBzZXQgVlQxMDAgbW9kZSBoZXJlXG5icmVhaztjYXNlIDM6Ly8gMTMyIGNvbCBtb2RlXG50aGlzLnNhdmVkQ29scz10aGlzLmNvbHM7dGhpcy5yZXNpemUoMTMyLHRoaXMucm93cyk7YnJlYWs7Y2FzZSA2OnRoaXMub3JpZ2luTW9kZT10cnVlO2JyZWFrO2Nhc2UgNzp0aGlzLndyYXBhcm91bmRNb2RlPXRydWU7YnJlYWs7Y2FzZSAxMjovLyB0aGlzLmN1cnNvckJsaW5rID0gdHJ1ZTtcbmJyZWFrO2Nhc2UgNjY6dGhpcy5sb2coJ1NlcmlhbCBwb3J0IHJlcXVlc3RlZCBhcHBsaWNhdGlvbiBrZXlwYWQuJyk7dGhpcy5hcHBsaWNhdGlvbktleXBhZD10cnVlO3RoaXMudmlld3BvcnQuc3luY1Njcm9sbEFyZWEoKTticmVhaztjYXNlIDk6Ly8gWDEwIE1vdXNlXG4vLyBubyByZWxlYXNlLCBubyBtb3Rpb24sIG5vIHdoZWVsLCBubyBtb2RpZmllcnMuXG5jYXNlIDEwMDA6Ly8gdnQyMDAgbW91c2Vcbi8vIG5vIG1vdGlvbi5cbi8vIG5vIG1vZGlmaWVycywgZXhjZXB0IGNvbnRyb2wgb24gdGhlIHdoZWVsLlxuY2FzZSAxMDAyOi8vIGJ1dHRvbiBldmVudCBtb3VzZVxuY2FzZSAxMDAzOi8vIGFueSBldmVudCBtb3VzZVxuLy8gYW55IGV2ZW50IC0gc2VuZHMgbW90aW9uIGV2ZW50cyxcbi8vIGV2ZW4gaWYgdGhlcmUgaXMgbm8gYnV0dG9uIGhlbGQgZG93bi5cbnRoaXMueDEwTW91c2U9cGFyYW1zPT09OTt0aGlzLnZ0MjAwTW91c2U9cGFyYW1zPT09MTAwMDt0aGlzLm5vcm1hbE1vdXNlPXBhcmFtcz4xMDAwO3RoaXMubW91c2VFdmVudHM9dHJ1ZTt0aGlzLmVsZW1lbnQuc3R5bGUuY3Vyc29yPSdkZWZhdWx0Jzt0aGlzLmxvZygnQmluZGluZyB0byBtb3VzZSBldmVudHMuJyk7YnJlYWs7Y2FzZSAxMDA0Oi8vIHNlbmQgZm9jdXNpbi9mb2N1c291dCBldmVudHNcbi8vIGZvY3VzaW46IF5bW0lcbi8vIGZvY3Vzb3V0OiBeW1tPXG50aGlzLnNlbmRGb2N1cz10cnVlO2JyZWFrO2Nhc2UgMTAwNTovLyB1dGY4IGV4dCBtb2RlIG1vdXNlXG50aGlzLnV0Zk1vdXNlPXRydWU7Ly8gZm9yIHdpZGUgdGVybWluYWxzXG4vLyBzaW1wbHkgZW5jb2RlcyBsYXJnZSB2YWx1ZXMgYXMgdXRmOCBjaGFyYWN0ZXJzXG5icmVhaztjYXNlIDEwMDY6Ly8gc2dyIGV4dCBtb2RlIG1vdXNlXG50aGlzLnNnck1vdXNlPXRydWU7Ly8gZm9yIHdpZGUgdGVybWluYWxzXG4vLyBkb2VzIG5vdCBhZGQgMzIgdG8gZmllbGRzXG4vLyBwcmVzczogXltbPGI7eDt5TVxuLy8gcmVsZWFzZTogXltbPGI7eDt5bVxuYnJlYWs7Y2FzZSAxMDE1Oi8vIHVyeHZ0IGV4dCBtb2RlIG1vdXNlXG50aGlzLnVyeHZ0TW91c2U9dHJ1ZTsvLyBmb3Igd2lkZSB0ZXJtaW5hbHNcbi8vIG51bWJlcnMgZm9yIGZpZWxkc1xuLy8gcHJlc3M6IF5bW2I7eDt5TVxuLy8gbW90aW9uOiBeW1tiO3g7eVRcbmJyZWFrO2Nhc2UgMjU6Ly8gc2hvdyBjdXJzb3JcbnRoaXMuY3Vyc29ySGlkZGVuPWZhbHNlO2JyZWFrO2Nhc2UgMTA0OTovLyBhbHQgc2NyZWVuIGJ1ZmZlciBjdXJzb3Jcbi8vdGhpcy5zYXZlQ3Vyc29yKCk7XG47Ly8gRkFMTC1USFJPVUdIXG5jYXNlIDQ3Oi8vIGFsdCBzY3JlZW4gYnVmZmVyXG5jYXNlIDEwNDc6Ly8gYWx0IHNjcmVlbiBidWZmZXJcbmlmKCF0aGlzLm5vcm1hbCl7dmFyIG5vcm1hbD17bGluZXM6dGhpcy5saW5lcyx5YmFzZTp0aGlzLnliYXNlLHlkaXNwOnRoaXMueWRpc3AseDp0aGlzLngseTp0aGlzLnksc2Nyb2xsVG9wOnRoaXMuc2Nyb2xsVG9wLHNjcm9sbEJvdHRvbTp0aGlzLnNjcm9sbEJvdHRvbSx0YWJzOnRoaXMudGFicy8vIFhYWCBzYXZlIGNoYXJzZXQocykgaGVyZT9cbi8vIGNoYXJzZXQ6IHRoaXMuY2hhcnNldCxcbi8vIGdsZXZlbDogdGhpcy5nbGV2ZWwsXG4vLyBjaGFyc2V0czogdGhpcy5jaGFyc2V0c1xufTt0aGlzLnJlc2V0KCk7dGhpcy5ub3JtYWw9bm9ybWFsO3RoaXMuc2hvd0N1cnNvcigpO31icmVhazt9fX07LyoqXG4gKiBDU0kgUG0gbCAgUmVzZXQgTW9kZSAoUk0pLlxuICogICAgIFBzID0gMiAgLT4gS2V5Ym9hcmQgQWN0aW9uIE1vZGUgKEFNKS5cbiAqICAgICBQcyA9IDQgIC0+IFJlcGxhY2UgTW9kZSAoSVJNKS5cbiAqICAgICBQcyA9IDEgMiAgLT4gU2VuZC9yZWNlaXZlIChTUk0pLlxuICogICAgIFBzID0gMiAwICAtPiBOb3JtYWwgTGluZWZlZWQgKExOTSkuXG4gKiBDU0kgPyBQbSBsXG4gKiAgIERFQyBQcml2YXRlIE1vZGUgUmVzZXQgKERFQ1JTVCkuXG4gKiAgICAgUHMgPSAxICAtPiBOb3JtYWwgQ3Vyc29yIEtleXMgKERFQ0NLTSkuXG4gKiAgICAgUHMgPSAyICAtPiBEZXNpZ25hdGUgVlQ1MiBtb2RlIChERUNBTk0pLlxuICogICAgIFBzID0gMyAgLT4gODAgQ29sdW1uIE1vZGUgKERFQ0NPTE0pLlxuICogICAgIFBzID0gNCAgLT4gSnVtcCAoRmFzdCkgU2Nyb2xsIChERUNTQ0xNKS5cbiAqICAgICBQcyA9IDUgIC0+IE5vcm1hbCBWaWRlbyAoREVDU0NOTSkuXG4gKiAgICAgUHMgPSA2ICAtPiBOb3JtYWwgQ3Vyc29yIE1vZGUgKERFQ09NKS5cbiAqICAgICBQcyA9IDcgIC0+IE5vIFdyYXBhcm91bmQgTW9kZSAoREVDQVdNKS5cbiAqICAgICBQcyA9IDggIC0+IE5vIEF1dG8tcmVwZWF0IEtleXMgKERFQ0FSTSkuXG4gKiAgICAgUHMgPSA5ICAtPiBEb24ndCBzZW5kIE1vdXNlIFggJiBZIG9uIGJ1dHRvbiBwcmVzcy5cbiAqICAgICBQcyA9IDEgMCAgLT4gSGlkZSB0b29sYmFyIChyeHZ0KS5cbiAqICAgICBQcyA9IDEgMiAgLT4gU3RvcCBCbGlua2luZyBDdXJzb3IgKGF0dDYxMCkuXG4gKiAgICAgUHMgPSAxIDggIC0+IERvbid0IHByaW50IGZvcm0gZmVlZCAoREVDUEZGKS5cbiAqICAgICBQcyA9IDEgOSAgLT4gTGltaXQgcHJpbnQgdG8gc2Nyb2xsaW5nIHJlZ2lvbiAoREVDUEVYKS5cbiAqICAgICBQcyA9IDIgNSAgLT4gSGlkZSBDdXJzb3IgKERFQ1RDRU0pLlxuICogICAgIFBzID0gMyAwICAtPiBEb24ndCBzaG93IHNjcm9sbGJhciAocnh2dCkuXG4gKiAgICAgUHMgPSAzIDUgIC0+IERpc2FibGUgZm9udC1zaGlmdGluZyBmdW5jdGlvbnMgKHJ4dnQpLlxuICogICAgIFBzID0gNCAwICAtPiBEaXNhbGxvdyA4MCAtPiAxMzIgTW9kZS5cbiAqICAgICBQcyA9IDQgMSAgLT4gTm8gbW9yZSgxKSBmaXggKHNlZSBjdXJzZXMgcmVzb3VyY2UpLlxuICogICAgIFBzID0gNCAyICAtPiBEaXNhYmxlIE5hdGlvbiBSZXBsYWNlbWVudCBDaGFyYWN0ZXIgc2V0cyAoREVDLVxuICogICAgIE5SQ00pLlxuICogICAgIFBzID0gNCA0ICAtPiBUdXJuIE9mZiBNYXJnaW4gQmVsbC5cbiAqICAgICBQcyA9IDQgNSAgLT4gTm8gUmV2ZXJzZS13cmFwYXJvdW5kIE1vZGUuXG4gKiAgICAgUHMgPSA0IDYgIC0+IFN0b3AgTG9nZ2luZy4gIChUaGlzIGlzIG5vcm1hbGx5IGRpc2FibGVkIGJ5IGFcbiAqICAgICBjb21waWxlLXRpbWUgb3B0aW9uKS5cbiAqICAgICBQcyA9IDQgNyAgLT4gVXNlIE5vcm1hbCBTY3JlZW4gQnVmZmVyLlxuICogICAgIFBzID0gNiA2ICAtPiBOdW1lcmljIGtleXBhZCAoREVDTktNKS5cbiAqICAgICBQcyA9IDYgNyAgLT4gQmFja2Fycm93IGtleSBzZW5kcyBkZWxldGUgKERFQ0JLTSkuXG4gKiAgICAgUHMgPSAxIDAgMCAwICAtPiBEb24ndCBzZW5kIE1vdXNlIFggJiBZIG9uIGJ1dHRvbiBwcmVzcyBhbmRcbiAqICAgICByZWxlYXNlLiAgU2VlIHRoZSBzZWN0aW9uIE1vdXNlIFRyYWNraW5nLlxuICogICAgIFBzID0gMSAwIDAgMSAgLT4gRG9uJ3QgdXNlIEhpbGl0ZSBNb3VzZSBUcmFja2luZy5cbiAqICAgICBQcyA9IDEgMCAwIDIgIC0+IERvbid0IHVzZSBDZWxsIE1vdGlvbiBNb3VzZSBUcmFja2luZy5cbiAqICAgICBQcyA9IDEgMCAwIDMgIC0+IERvbid0IHVzZSBBbGwgTW90aW9uIE1vdXNlIFRyYWNraW5nLlxuICogICAgIFBzID0gMSAwIDAgNCAgLT4gRG9uJ3Qgc2VuZCBGb2N1c0luL0ZvY3VzT3V0IGV2ZW50cy5cbiAqICAgICBQcyA9IDEgMCAwIDUgIC0+IERpc2FibGUgRXh0ZW5kZWQgTW91c2UgTW9kZS5cbiAqICAgICBQcyA9IDEgMCAxIDAgIC0+IERvbid0IHNjcm9sbCB0byBib3R0b20gb24gdHR5IG91dHB1dFxuICogICAgIChyeHZ0KS5cbiAqICAgICBQcyA9IDEgMCAxIDEgIC0+IERvbid0IHNjcm9sbCB0byBib3R0b20gb24ga2V5IHByZXNzIChyeHZ0KS5cbiAqICAgICBQcyA9IDEgMCAzIDQgIC0+IERvbid0IGludGVycHJldCBcIm1ldGFcIiBrZXkuICAoVGhpcyBkaXNhYmxlc1xuICogICAgIHRoZSBlaWdodEJpdElucHV0IHJlc291cmNlKS5cbiAqICAgICBQcyA9IDEgMCAzIDUgIC0+IERpc2FibGUgc3BlY2lhbCBtb2RpZmllcnMgZm9yIEFsdCBhbmQgTnVtLVxuICogICAgIExvY2sga2V5cy4gIChUaGlzIGRpc2FibGVzIHRoZSBudW1Mb2NrIHJlc291cmNlKS5cbiAqICAgICBQcyA9IDEgMCAzIDYgIC0+IERvbid0IHNlbmQgRVNDICB3aGVuIE1ldGEgbW9kaWZpZXMgYSBrZXkuXG4gKiAgICAgKFRoaXMgZGlzYWJsZXMgdGhlIG1ldGFTZW5kc0VzY2FwZSByZXNvdXJjZSkuXG4gKiAgICAgUHMgPSAxIDAgMyA3ICAtPiBTZW5kIFZUMjIwIFJlbW92ZSBmcm9tIHRoZSBlZGl0aW5nLWtleXBhZFxuICogICAgIERlbGV0ZSBrZXkuXG4gKiAgICAgUHMgPSAxIDAgMyA5ICAtPiBEb24ndCBzZW5kIEVTQyAgd2hlbiBBbHQgbW9kaWZpZXMgYSBrZXkuXG4gKiAgICAgKFRoaXMgZGlzYWJsZXMgdGhlIGFsdFNlbmRzRXNjYXBlIHJlc291cmNlKS5cbiAqICAgICBQcyA9IDEgMCA0IDAgIC0+IERvIG5vdCBrZWVwIHNlbGVjdGlvbiB3aGVuIG5vdCBoaWdobGlnaHRlZC5cbiAqICAgICAoVGhpcyBkaXNhYmxlcyB0aGUga2VlcFNlbGVjdGlvbiByZXNvdXJjZSkuXG4gKiAgICAgUHMgPSAxIDAgNCAxICAtPiBVc2UgdGhlIFBSSU1BUlkgc2VsZWN0aW9uLiAgKFRoaXMgZGlzYWJsZXNcbiAqICAgICB0aGUgc2VsZWN0VG9DbGlwYm9hcmQgcmVzb3VyY2UpLlxuICogICAgIFBzID0gMSAwIDQgMiAgLT4gRGlzYWJsZSBVcmdlbmN5IHdpbmRvdyBtYW5hZ2VyIGhpbnQgd2hlblxuICogICAgIENvbnRyb2wtRyBpcyByZWNlaXZlZC4gIChUaGlzIGRpc2FibGVzIHRoZSBiZWxsSXNVcmdlbnRcbiAqICAgICByZXNvdXJjZSkuXG4gKiAgICAgUHMgPSAxIDAgNCAzICAtPiBEaXNhYmxlIHJhaXNpbmcgb2YgdGhlIHdpbmRvdyB3aGVuIENvbnRyb2wtXG4gKiAgICAgRyBpcyByZWNlaXZlZC4gIChUaGlzIGRpc2FibGVzIHRoZSBwb3BPbkJlbGwgcmVzb3VyY2UpLlxuICogICAgIFBzID0gMSAwIDQgNyAgLT4gVXNlIE5vcm1hbCBTY3JlZW4gQnVmZmVyLCBjbGVhcmluZyBzY3JlZW5cbiAqICAgICBmaXJzdCBpZiBpbiB0aGUgQWx0ZXJuYXRlIFNjcmVlbi4gIChUaGlzIG1heSBiZSBkaXNhYmxlZCBieVxuICogICAgIHRoZSB0aXRlSW5oaWJpdCByZXNvdXJjZSkuXG4gKiAgICAgUHMgPSAxIDAgNCA4ICAtPiBSZXN0b3JlIGN1cnNvciBhcyBpbiBERUNSQy4gIChUaGlzIG1heSBiZVxuICogICAgIGRpc2FibGVkIGJ5IHRoZSB0aXRlSW5oaWJpdCByZXNvdXJjZSkuXG4gKiAgICAgUHMgPSAxIDAgNCA5ICAtPiBVc2UgTm9ybWFsIFNjcmVlbiBCdWZmZXIgYW5kIHJlc3RvcmUgY3Vyc29yXG4gKiAgICAgYXMgaW4gREVDUkMuICAoVGhpcyBtYXkgYmUgZGlzYWJsZWQgYnkgdGhlIHRpdGVJbmhpYml0XG4gKiAgICAgcmVzb3VyY2UpLiAgVGhpcyBjb21iaW5lcyB0aGUgZWZmZWN0cyBvZiB0aGUgMSAwIDQgNyAgYW5kIDEgMFxuICogICAgIDQgOCAgbW9kZXMuICBVc2UgdGhpcyB3aXRoIHRlcm1pbmZvLWJhc2VkIGFwcGxpY2F0aW9ucyByYXRoZXJcbiAqICAgICB0aGFuIHRoZSA0IDcgIG1vZGUuXG4gKiAgICAgUHMgPSAxIDAgNSAwICAtPiBSZXNldCB0ZXJtaW5mby90ZXJtY2FwIGZ1bmN0aW9uLWtleSBtb2RlLlxuICogICAgIFBzID0gMSAwIDUgMSAgLT4gUmVzZXQgU3VuIGZ1bmN0aW9uLWtleSBtb2RlLlxuICogICAgIFBzID0gMSAwIDUgMiAgLT4gUmVzZXQgSFAgZnVuY3Rpb24ta2V5IG1vZGUuXG4gKiAgICAgUHMgPSAxIDAgNSAzICAtPiBSZXNldCBTQ08gZnVuY3Rpb24ta2V5IG1vZGUuXG4gKiAgICAgUHMgPSAxIDAgNiAwICAtPiBSZXNldCBsZWdhY3kga2V5Ym9hcmQgZW11bGF0aW9uIChYMTFSNikuXG4gKiAgICAgUHMgPSAxIDAgNiAxICAtPiBSZXNldCBrZXlib2FyZCBlbXVsYXRpb24gdG8gU3VuL1BDIHN0eWxlLlxuICogICAgIFBzID0gMiAwIDAgNCAgLT4gUmVzZXQgYnJhY2tldGVkIHBhc3RlIG1vZGUuXG4gKi9UZXJtaW5hbC5wcm90b3R5cGUucmVzZXRNb2RlPWZ1bmN0aW9uKHBhcmFtcyl7aWYoKHR5cGVvZiBwYXJhbXM9PT0ndW5kZWZpbmVkJz8ndW5kZWZpbmVkJzpfdHlwZW9mKHBhcmFtcykpPT09J29iamVjdCcpe3ZhciBsPXBhcmFtcy5sZW5ndGgsaT0wO2Zvcig7aTxsO2krKyl7dGhpcy5yZXNldE1vZGUocGFyYW1zW2ldKTt9cmV0dXJuO31pZighdGhpcy5wcmVmaXgpe3N3aXRjaChwYXJhbXMpe2Nhc2UgNDp0aGlzLmluc2VydE1vZGU9ZmFsc2U7YnJlYWs7Y2FzZSAyMDovL3RoaXMuY29udmVydEVvbCA9IGZhbHNlO1xuYnJlYWs7fX1lbHNlIGlmKHRoaXMucHJlZml4PT09Jz8nKXtzd2l0Y2gocGFyYW1zKXtjYXNlIDE6dGhpcy5hcHBsaWNhdGlvbkN1cnNvcj1mYWxzZTticmVhaztjYXNlIDM6aWYodGhpcy5jb2xzPT09MTMyJiZ0aGlzLnNhdmVkQ29scyl7dGhpcy5yZXNpemUodGhpcy5zYXZlZENvbHMsdGhpcy5yb3dzKTt9ZGVsZXRlIHRoaXMuc2F2ZWRDb2xzO2JyZWFrO2Nhc2UgNjp0aGlzLm9yaWdpbk1vZGU9ZmFsc2U7YnJlYWs7Y2FzZSA3OnRoaXMud3JhcGFyb3VuZE1vZGU9ZmFsc2U7YnJlYWs7Y2FzZSAxMjovLyB0aGlzLmN1cnNvckJsaW5rID0gZmFsc2U7XG5icmVhaztjYXNlIDY2OnRoaXMubG9nKCdTd2l0Y2hpbmcgYmFjayB0byBub3JtYWwga2V5cGFkLicpO3RoaXMuYXBwbGljYXRpb25LZXlwYWQ9ZmFsc2U7dGhpcy52aWV3cG9ydC5zeW5jU2Nyb2xsQXJlYSgpO2JyZWFrO2Nhc2UgOTovLyBYMTAgTW91c2VcbmNhc2UgMTAwMDovLyB2dDIwMCBtb3VzZVxuY2FzZSAxMDAyOi8vIGJ1dHRvbiBldmVudCBtb3VzZVxuY2FzZSAxMDAzOi8vIGFueSBldmVudCBtb3VzZVxudGhpcy54MTBNb3VzZT1mYWxzZTt0aGlzLnZ0MjAwTW91c2U9ZmFsc2U7dGhpcy5ub3JtYWxNb3VzZT1mYWxzZTt0aGlzLm1vdXNlRXZlbnRzPWZhbHNlO3RoaXMuZWxlbWVudC5zdHlsZS5jdXJzb3I9Jyc7YnJlYWs7Y2FzZSAxMDA0Oi8vIHNlbmQgZm9jdXNpbi9mb2N1c291dCBldmVudHNcbnRoaXMuc2VuZEZvY3VzPWZhbHNlO2JyZWFrO2Nhc2UgMTAwNTovLyB1dGY4IGV4dCBtb2RlIG1vdXNlXG50aGlzLnV0Zk1vdXNlPWZhbHNlO2JyZWFrO2Nhc2UgMTAwNjovLyBzZ3IgZXh0IG1vZGUgbW91c2VcbnRoaXMuc2dyTW91c2U9ZmFsc2U7YnJlYWs7Y2FzZSAxMDE1Oi8vIHVyeHZ0IGV4dCBtb2RlIG1vdXNlXG50aGlzLnVyeHZ0TW91c2U9ZmFsc2U7YnJlYWs7Y2FzZSAyNTovLyBoaWRlIGN1cnNvclxudGhpcy5jdXJzb3JIaWRkZW49dHJ1ZTticmVhaztjYXNlIDEwNDk6Ly8gYWx0IHNjcmVlbiBidWZmZXIgY3Vyc29yXG47Ly8gRkFMTC1USFJPVUdIXG5jYXNlIDQ3Oi8vIG5vcm1hbCBzY3JlZW4gYnVmZmVyXG5jYXNlIDEwNDc6Ly8gbm9ybWFsIHNjcmVlbiBidWZmZXIgLSBjbGVhcmluZyBpdCBmaXJzdFxuaWYodGhpcy5ub3JtYWwpe3RoaXMubGluZXM9dGhpcy5ub3JtYWwubGluZXM7dGhpcy55YmFzZT10aGlzLm5vcm1hbC55YmFzZTt0aGlzLnlkaXNwPXRoaXMubm9ybWFsLnlkaXNwO3RoaXMueD10aGlzLm5vcm1hbC54O3RoaXMueT10aGlzLm5vcm1hbC55O3RoaXMuc2Nyb2xsVG9wPXRoaXMubm9ybWFsLnNjcm9sbFRvcDt0aGlzLnNjcm9sbEJvdHRvbT10aGlzLm5vcm1hbC5zY3JvbGxCb3R0b207dGhpcy50YWJzPXRoaXMubm9ybWFsLnRhYnM7dGhpcy5ub3JtYWw9bnVsbDsvLyBpZiAocGFyYW1zID09PSAxMDQ5KSB7XG4vLyAgIHRoaXMueCA9IHRoaXMuc2F2ZWRYO1xuLy8gICB0aGlzLnkgPSB0aGlzLnNhdmVkWTtcbi8vIH1cbnRoaXMucmVmcmVzaCgwLHRoaXMucm93cy0xKTt0aGlzLnNob3dDdXJzb3IoKTt9YnJlYWs7fX19Oy8qKlxuICogQ1NJIFBzIDsgUHMgclxuICogICBTZXQgU2Nyb2xsaW5nIFJlZ2lvbiBbdG9wO2JvdHRvbV0gKGRlZmF1bHQgPSBmdWxsIHNpemUgb2Ygd2luLVxuICogICBkb3cpIChERUNTVEJNKS5cbiAqIENTSSA/IFBtIHJcbiAqL1Rlcm1pbmFsLnByb3RvdHlwZS5zZXRTY3JvbGxSZWdpb249ZnVuY3Rpb24ocGFyYW1zKXtpZih0aGlzLnByZWZpeClyZXR1cm47dGhpcy5zY3JvbGxUb3A9KHBhcmFtc1swXXx8MSktMTt0aGlzLnNjcm9sbEJvdHRvbT0ocGFyYW1zWzFdfHx0aGlzLnJvd3MpLTE7dGhpcy54PTA7dGhpcy55PTA7fTsvKipcbiAqIENTSSBzXG4gKiAgIFNhdmUgY3Vyc29yIChBTlNJLlNZUykuXG4gKi9UZXJtaW5hbC5wcm90b3R5cGUuc2F2ZUN1cnNvcj1mdW5jdGlvbihwYXJhbXMpe3RoaXMuc2F2ZWRYPXRoaXMueDt0aGlzLnNhdmVkWT10aGlzLnk7fTsvKipcbiAqIENTSSB1XG4gKiAgIFJlc3RvcmUgY3Vyc29yIChBTlNJLlNZUykuXG4gKi9UZXJtaW5hbC5wcm90b3R5cGUucmVzdG9yZUN1cnNvcj1mdW5jdGlvbihwYXJhbXMpe3RoaXMueD10aGlzLnNhdmVkWHx8MDt0aGlzLnk9dGhpcy5zYXZlZFl8fDA7fTsvKipcbiAqIExlc3NlciBVc2VkXG4gKi8vKipcbiAqIENTSSBQcyBJXG4gKiAgIEN1cnNvciBGb3J3YXJkIFRhYnVsYXRpb24gUHMgdGFiIHN0b3BzIChkZWZhdWx0ID0gMSkgKENIVCkuXG4gKi9UZXJtaW5hbC5wcm90b3R5cGUuY3Vyc29yRm9yd2FyZFRhYj1mdW5jdGlvbihwYXJhbXMpe3ZhciBwYXJhbT1wYXJhbXNbMF18fDE7d2hpbGUocGFyYW0tLSl7dGhpcy54PXRoaXMubmV4dFN0b3AoKTt9fTsvKipcbiAqIENTSSBQcyBTICBTY3JvbGwgdXAgUHMgbGluZXMgKGRlZmF1bHQgPSAxKSAoU1UpLlxuICovVGVybWluYWwucHJvdG90eXBlLnNjcm9sbFVwPWZ1bmN0aW9uKHBhcmFtcyl7dmFyIHBhcmFtPXBhcmFtc1swXXx8MTt3aGlsZShwYXJhbS0tKXt0aGlzLmxpbmVzLnNwbGljZSh0aGlzLnliYXNlK3RoaXMuc2Nyb2xsVG9wLDEpO3RoaXMubGluZXMuc3BsaWNlKHRoaXMueWJhc2UrdGhpcy5zY3JvbGxCb3R0b20sMCx0aGlzLmJsYW5rTGluZSgpKTt9Ly8gdGhpcy5tYXhSYW5nZSgpO1xudGhpcy51cGRhdGVSYW5nZSh0aGlzLnNjcm9sbFRvcCk7dGhpcy51cGRhdGVSYW5nZSh0aGlzLnNjcm9sbEJvdHRvbSk7fTsvKipcbiAgICAgKiBDU0kgUHMgVCAgU2Nyb2xsIGRvd24gUHMgbGluZXMgKGRlZmF1bHQgPSAxKSAoU0QpLlxuICAgICAqL1Rlcm1pbmFsLnByb3RvdHlwZS5zY3JvbGxEb3duPWZ1bmN0aW9uKHBhcmFtcyl7dmFyIHBhcmFtPXBhcmFtc1swXXx8MTt3aGlsZShwYXJhbS0tKXt0aGlzLmxpbmVzLnNwbGljZSh0aGlzLnliYXNlK3RoaXMuc2Nyb2xsQm90dG9tLDEpO3RoaXMubGluZXMuc3BsaWNlKHRoaXMueWJhc2UrdGhpcy5zY3JvbGxUb3AsMCx0aGlzLmJsYW5rTGluZSgpKTt9Ly8gdGhpcy5tYXhSYW5nZSgpO1xudGhpcy51cGRhdGVSYW5nZSh0aGlzLnNjcm9sbFRvcCk7dGhpcy51cGRhdGVSYW5nZSh0aGlzLnNjcm9sbEJvdHRvbSk7fTsvKipcbiAqIENTSSBQcyA7IFBzIDsgUHMgOyBQcyA7IFBzIFRcbiAqICAgSW5pdGlhdGUgaGlnaGxpZ2h0IG1vdXNlIHRyYWNraW5nLiAgUGFyYW1ldGVycyBhcmVcbiAqICAgW2Z1bmM7c3RhcnR4O3N0YXJ0eTtmaXJzdHJvdztsYXN0cm93XS4gIFNlZSB0aGUgc2VjdGlvbiBNb3VzZVxuICogICBUcmFja2luZy5cbiAqL1Rlcm1pbmFsLnByb3RvdHlwZS5pbml0TW91c2VUcmFja2luZz1mdW5jdGlvbihwYXJhbXMpey8vIFJlbGV2YW50OiBERUNTRVQgMTAwMVxufTsvKipcbiAqIENTSSA+IFBzOyBQcyBUXG4gKiAgIFJlc2V0IG9uZSBvciBtb3JlIGZlYXR1cmVzIG9mIHRoZSB0aXRsZSBtb2RlcyB0byB0aGUgZGVmYXVsdFxuICogICB2YWx1ZS4gIE5vcm1hbGx5LCBcInJlc2V0XCIgZGlzYWJsZXMgdGhlIGZlYXR1cmUuICBJdCBpcyBwb3NzaS1cbiAqICAgYmxlIHRvIGRpc2FibGUgdGhlIGFiaWxpdHkgdG8gcmVzZXQgZmVhdHVyZXMgYnkgY29tcGlsaW5nIGFcbiAqICAgZGlmZmVyZW50IGRlZmF1bHQgZm9yIHRoZSB0aXRsZSBtb2RlcyBpbnRvIHh0ZXJtLlxuICogICAgIFBzID0gMCAgLT4gRG8gbm90IHNldCB3aW5kb3cvaWNvbiBsYWJlbHMgdXNpbmcgaGV4YWRlY2ltYWwuXG4gKiAgICAgUHMgPSAxICAtPiBEbyBub3QgcXVlcnkgd2luZG93L2ljb24gbGFiZWxzIHVzaW5nIGhleGFkZWNpLVxuICogICAgIG1hbC5cbiAqICAgICBQcyA9IDIgIC0+IERvIG5vdCBzZXQgd2luZG93L2ljb24gbGFiZWxzIHVzaW5nIFVURi04LlxuICogICAgIFBzID0gMyAgLT4gRG8gbm90IHF1ZXJ5IHdpbmRvdy9pY29uIGxhYmVscyB1c2luZyBVVEYtOC5cbiAqICAgKFNlZSBkaXNjdXNzaW9uIG9mIFwiVGl0bGUgTW9kZXNcIikuXG4gKi9UZXJtaW5hbC5wcm90b3R5cGUucmVzZXRUaXRsZU1vZGVzPWZ1bmN0aW9uKHBhcmFtcyl7O307LyoqXG4gKiBDU0kgUHMgWiAgQ3Vyc29yIEJhY2t3YXJkIFRhYnVsYXRpb24gUHMgdGFiIHN0b3BzIChkZWZhdWx0ID0gMSkgKENCVCkuXG4gKi9UZXJtaW5hbC5wcm90b3R5cGUuY3Vyc29yQmFja3dhcmRUYWI9ZnVuY3Rpb24ocGFyYW1zKXt2YXIgcGFyYW09cGFyYW1zWzBdfHwxO3doaWxlKHBhcmFtLS0pe3RoaXMueD10aGlzLnByZXZTdG9wKCk7fX07LyoqXG4gKiBDU0kgUHMgYiAgUmVwZWF0IHRoZSBwcmVjZWRpbmcgZ3JhcGhpYyBjaGFyYWN0ZXIgUHMgdGltZXMgKFJFUCkuXG4gKi9UZXJtaW5hbC5wcm90b3R5cGUucmVwZWF0UHJlY2VkaW5nQ2hhcmFjdGVyPWZ1bmN0aW9uKHBhcmFtcyl7dmFyIHBhcmFtPXBhcmFtc1swXXx8MSxsaW5lPXRoaXMubGluZXNbdGhpcy55YmFzZSt0aGlzLnldLGNoPWxpbmVbdGhpcy54LTFdfHxbdGhpcy5kZWZBdHRyLCcgJywxXTt3aGlsZShwYXJhbS0tKXtsaW5lW3RoaXMueCsrXT1jaDt9fTsvKipcbiAqIENTSSBQcyBnICBUYWIgQ2xlYXIgKFRCQykuXG4gKiAgICAgUHMgPSAwICAtPiBDbGVhciBDdXJyZW50IENvbHVtbiAoZGVmYXVsdCkuXG4gKiAgICAgUHMgPSAzICAtPiBDbGVhciBBbGwuXG4gKiBQb3RlbnRpYWxseTpcbiAqICAgUHMgPSAyICAtPiBDbGVhciBTdG9wcyBvbiBMaW5lLlxuICogICBodHRwOi8vdnQxMDAubmV0L2FubmFyYm9yL2FhYS11Zy9zZWN0aW9uNi5odG1sXG4gKi9UZXJtaW5hbC5wcm90b3R5cGUudGFiQ2xlYXI9ZnVuY3Rpb24ocGFyYW1zKXt2YXIgcGFyYW09cGFyYW1zWzBdO2lmKHBhcmFtPD0wKXtkZWxldGUgdGhpcy50YWJzW3RoaXMueF07fWVsc2UgaWYocGFyYW09PT0zKXt0aGlzLnRhYnM9e307fX07LyoqXG4gKiBDU0kgUG0gaSAgTWVkaWEgQ29weSAoTUMpLlxuICogICAgIFBzID0gMCAgLT4gUHJpbnQgc2NyZWVuIChkZWZhdWx0KS5cbiAqICAgICBQcyA9IDQgIC0+IFR1cm4gb2ZmIHByaW50ZXIgY29udHJvbGxlciBtb2RlLlxuICogICAgIFBzID0gNSAgLT4gVHVybiBvbiBwcmludGVyIGNvbnRyb2xsZXIgbW9kZS5cbiAqIENTSSA/IFBtIGlcbiAqICAgTWVkaWEgQ29weSAoTUMsIERFQy1zcGVjaWZpYykuXG4gKiAgICAgUHMgPSAxICAtPiBQcmludCBsaW5lIGNvbnRhaW5pbmcgY3Vyc29yLlxuICogICAgIFBzID0gNCAgLT4gVHVybiBvZmYgYXV0b3ByaW50IG1vZGUuXG4gKiAgICAgUHMgPSA1ICAtPiBUdXJuIG9uIGF1dG9wcmludCBtb2RlLlxuICogICAgIFBzID0gMSAgMCAgLT4gUHJpbnQgY29tcG9zZWQgZGlzcGxheSwgaWdub3JlcyBERUNQRVguXG4gKiAgICAgUHMgPSAxICAxICAtPiBQcmludCBhbGwgcGFnZXMuXG4gKi9UZXJtaW5hbC5wcm90b3R5cGUubWVkaWFDb3B5PWZ1bmN0aW9uKHBhcmFtcyl7O307LyoqXG4gKiBDU0kgPiBQczsgUHMgbVxuICogICBTZXQgb3IgcmVzZXQgcmVzb3VyY2UtdmFsdWVzIHVzZWQgYnkgeHRlcm0gdG8gZGVjaWRlIHdoZXRoZXJcbiAqICAgdG8gY29uc3RydWN0IGVzY2FwZSBzZXF1ZW5jZXMgaG9sZGluZyBpbmZvcm1hdGlvbiBhYm91dCB0aGVcbiAqICAgbW9kaWZpZXJzIHByZXNzZWQgd2l0aCBhIGdpdmVuIGtleS4gIFRoZSBmaXJzdCBwYXJhbWV0ZXIgaWRlbi1cbiAqICAgdGlmaWVzIHRoZSByZXNvdXJjZSB0byBzZXQvcmVzZXQuICBUaGUgc2Vjb25kIHBhcmFtZXRlciBpcyB0aGVcbiAqICAgdmFsdWUgdG8gYXNzaWduIHRvIHRoZSByZXNvdXJjZS4gIElmIHRoZSBzZWNvbmQgcGFyYW1ldGVyIGlzXG4gKiAgIG9taXR0ZWQsIHRoZSByZXNvdXJjZSBpcyByZXNldCB0byBpdHMgaW5pdGlhbCB2YWx1ZS5cbiAqICAgICBQcyA9IDEgIC0+IG1vZGlmeUN1cnNvcktleXMuXG4gKiAgICAgUHMgPSAyICAtPiBtb2RpZnlGdW5jdGlvbktleXMuXG4gKiAgICAgUHMgPSA0ICAtPiBtb2RpZnlPdGhlcktleXMuXG4gKiAgIElmIG5vIHBhcmFtZXRlcnMgYXJlIGdpdmVuLCBhbGwgcmVzb3VyY2VzIGFyZSByZXNldCB0byB0aGVpclxuICogICBpbml0aWFsIHZhbHVlcy5cbiAqL1Rlcm1pbmFsLnByb3RvdHlwZS5zZXRSZXNvdXJjZXM9ZnVuY3Rpb24ocGFyYW1zKXs7fTsvKipcbiAqIENTSSA+IFBzIG5cbiAqICAgRGlzYWJsZSBtb2RpZmllcnMgd2hpY2ggbWF5IGJlIGVuYWJsZWQgdmlhIHRoZSBDU0kgPiBQczsgUHMgbVxuICogICBzZXF1ZW5jZS4gIFRoaXMgY29ycmVzcG9uZHMgdG8gYSByZXNvdXJjZSB2YWx1ZSBvZiBcIi0xXCIsIHdoaWNoXG4gKiAgIGNhbm5vdCBiZSBzZXQgd2l0aCB0aGUgb3RoZXIgc2VxdWVuY2UuICBUaGUgcGFyYW1ldGVyIGlkZW50aS1cbiAqICAgZmllcyB0aGUgcmVzb3VyY2UgdG8gYmUgZGlzYWJsZWQ6XG4gKiAgICAgUHMgPSAxICAtPiBtb2RpZnlDdXJzb3JLZXlzLlxuICogICAgIFBzID0gMiAgLT4gbW9kaWZ5RnVuY3Rpb25LZXlzLlxuICogICAgIFBzID0gNCAgLT4gbW9kaWZ5T3RoZXJLZXlzLlxuICogICBJZiB0aGUgcGFyYW1ldGVyIGlzIG9taXR0ZWQsIG1vZGlmeUZ1bmN0aW9uS2V5cyBpcyBkaXNhYmxlZC5cbiAqICAgV2hlbiBtb2RpZnlGdW5jdGlvbktleXMgaXMgZGlzYWJsZWQsIHh0ZXJtIHVzZXMgdGhlIG1vZGlmaWVyXG4gKiAgIGtleXMgdG8gbWFrZSBhbiBleHRlbmRlZCBzZXF1ZW5jZSBvZiBmdW5jdGlvbnMgcmF0aGVyIHRoYW5cbiAqICAgYWRkaW5nIGEgcGFyYW1ldGVyIHRvIGVhY2ggZnVuY3Rpb24ga2V5IHRvIGRlbm90ZSB0aGUgbW9kaS1cbiAqICAgZmllcnMuXG4gKi9UZXJtaW5hbC5wcm90b3R5cGUuZGlzYWJsZU1vZGlmaWVycz1mdW5jdGlvbihwYXJhbXMpezt9Oy8qKlxuICogQ1NJID4gUHMgcFxuICogICBTZXQgcmVzb3VyY2UgdmFsdWUgcG9pbnRlck1vZGUuICBUaGlzIGlzIHVzZWQgYnkgeHRlcm0gdG9cbiAqICAgZGVjaWRlIHdoZXRoZXIgdG8gaGlkZSB0aGUgcG9pbnRlciBjdXJzb3IgYXMgdGhlIHVzZXIgdHlwZXMuXG4gKiAgIFZhbGlkIHZhbHVlcyBmb3IgdGhlIHBhcmFtZXRlcjpcbiAqICAgICBQcyA9IDAgIC0+IG5ldmVyIGhpZGUgdGhlIHBvaW50ZXIuXG4gKiAgICAgUHMgPSAxICAtPiBoaWRlIGlmIHRoZSBtb3VzZSB0cmFja2luZyBtb2RlIGlzIG5vdCBlbmFibGVkLlxuICogICAgIFBzID0gMiAgLT4gYWx3YXlzIGhpZGUgdGhlIHBvaW50ZXIuICBJZiBubyBwYXJhbWV0ZXIgaXNcbiAqICAgICBnaXZlbiwgeHRlcm0gdXNlcyB0aGUgZGVmYXVsdCwgd2hpY2ggaXMgMSAuXG4gKi9UZXJtaW5hbC5wcm90b3R5cGUuc2V0UG9pbnRlck1vZGU9ZnVuY3Rpb24ocGFyYW1zKXs7fTsvKipcbiAqIENTSSAhIHAgICBTb2Z0IHRlcm1pbmFsIHJlc2V0IChERUNTVFIpLlxuICogaHR0cDovL3Z0MTAwLm5ldC9kb2NzL3Z0MjIwLXJtL3RhYmxlNC0xMC5odG1sXG4gKi9UZXJtaW5hbC5wcm90b3R5cGUuc29mdFJlc2V0PWZ1bmN0aW9uKHBhcmFtcyl7dGhpcy5jdXJzb3JIaWRkZW49ZmFsc2U7dGhpcy5pbnNlcnRNb2RlPWZhbHNlO3RoaXMub3JpZ2luTW9kZT1mYWxzZTt0aGlzLndyYXBhcm91bmRNb2RlPWZhbHNlOy8vIGF1dG93cmFwXG50aGlzLmFwcGxpY2F0aW9uS2V5cGFkPWZhbHNlOy8vID9cbnRoaXMudmlld3BvcnQuc3luY1Njcm9sbEFyZWEoKTt0aGlzLmFwcGxpY2F0aW9uQ3Vyc29yPWZhbHNlO3RoaXMuc2Nyb2xsVG9wPTA7dGhpcy5zY3JvbGxCb3R0b209dGhpcy5yb3dzLTE7dGhpcy5jdXJBdHRyPXRoaXMuZGVmQXR0cjt0aGlzLng9dGhpcy55PTA7Ly8gP1xudGhpcy5jaGFyc2V0PW51bGw7dGhpcy5nbGV2ZWw9MDsvLyA/P1xudGhpcy5jaGFyc2V0cz1bbnVsbF07Ly8gPz9cbn07LyoqXG4gKiBDU0kgUHMkIHBcbiAqICAgUmVxdWVzdCBBTlNJIG1vZGUgKERFQ1JRTSkuICBGb3IgVlQzMDAgYW5kIHVwLCByZXBseSBpc1xuICogICAgIENTSSBQczsgUG0kIHlcbiAqICAgd2hlcmUgUHMgaXMgdGhlIG1vZGUgbnVtYmVyIGFzIGluIFJNLCBhbmQgUG0gaXMgdGhlIG1vZGVcbiAqICAgdmFsdWU6XG4gKiAgICAgMCAtIG5vdCByZWNvZ25pemVkXG4gKiAgICAgMSAtIHNldFxuICogICAgIDIgLSByZXNldFxuICogICAgIDMgLSBwZXJtYW5lbnRseSBzZXRcbiAqICAgICA0IC0gcGVybWFuZW50bHkgcmVzZXRcbiAqL1Rlcm1pbmFsLnByb3RvdHlwZS5yZXF1ZXN0QW5zaU1vZGU9ZnVuY3Rpb24ocGFyYW1zKXs7fTsvKipcbiAqIENTSSA/IFBzJCBwXG4gKiAgIFJlcXVlc3QgREVDIHByaXZhdGUgbW9kZSAoREVDUlFNKS4gIEZvciBWVDMwMCBhbmQgdXAsIHJlcGx5IGlzXG4gKiAgICAgQ1NJID8gUHM7IFBtJCBwXG4gKiAgIHdoZXJlIFBzIGlzIHRoZSBtb2RlIG51bWJlciBhcyBpbiBERUNTRVQsIFBtIGlzIHRoZSBtb2RlIHZhbHVlXG4gKiAgIGFzIGluIHRoZSBBTlNJIERFQ1JRTS5cbiAqL1Rlcm1pbmFsLnByb3RvdHlwZS5yZXF1ZXN0UHJpdmF0ZU1vZGU9ZnVuY3Rpb24ocGFyYW1zKXs7fTsvKipcbiAqIENTSSBQcyA7IFBzIFwiIHBcbiAqICAgU2V0IGNvbmZvcm1hbmNlIGxldmVsIChERUNTQ0wpLiAgVmFsaWQgdmFsdWVzIGZvciB0aGUgZmlyc3RcbiAqICAgcGFyYW1ldGVyOlxuICogICAgIFBzID0gNiAxICAtPiBWVDEwMC5cbiAqICAgICBQcyA9IDYgMiAgLT4gVlQyMDAuXG4gKiAgICAgUHMgPSA2IDMgIC0+IFZUMzAwLlxuICogICBWYWxpZCB2YWx1ZXMgZm9yIHRoZSBzZWNvbmQgcGFyYW1ldGVyOlxuICogICAgIFBzID0gMCAgLT4gOC1iaXQgY29udHJvbHMuXG4gKiAgICAgUHMgPSAxICAtPiA3LWJpdCBjb250cm9scyAoYWx3YXlzIHNldCBmb3IgVlQxMDApLlxuICogICAgIFBzID0gMiAgLT4gOC1iaXQgY29udHJvbHMuXG4gKi9UZXJtaW5hbC5wcm90b3R5cGUuc2V0Q29uZm9ybWFuY2VMZXZlbD1mdW5jdGlvbihwYXJhbXMpezt9Oy8qKlxuICogQ1NJIFBzIHEgIExvYWQgTEVEcyAoREVDTEwpLlxuICogICAgIFBzID0gMCAgLT4gQ2xlYXIgYWxsIExFRFMgKGRlZmF1bHQpLlxuICogICAgIFBzID0gMSAgLT4gTGlnaHQgTnVtIExvY2suXG4gKiAgICAgUHMgPSAyICAtPiBMaWdodCBDYXBzIExvY2suXG4gKiAgICAgUHMgPSAzICAtPiBMaWdodCBTY3JvbGwgTG9jay5cbiAqICAgICBQcyA9IDIgIDEgIC0+IEV4dGluZ3Vpc2ggTnVtIExvY2suXG4gKiAgICAgUHMgPSAyICAyICAtPiBFeHRpbmd1aXNoIENhcHMgTG9jay5cbiAqICAgICBQcyA9IDIgIDMgIC0+IEV4dGluZ3Vpc2ggU2Nyb2xsIExvY2suXG4gKi9UZXJtaW5hbC5wcm90b3R5cGUubG9hZExFRHM9ZnVuY3Rpb24ocGFyYW1zKXs7fTsvKipcbiAqIENTSSBQcyBTUCBxXG4gKiAgIFNldCBjdXJzb3Igc3R5bGUgKERFQ1NDVVNSLCBWVDUyMCkuXG4gKiAgICAgUHMgPSAwICAtPiBibGlua2luZyBibG9jay5cbiAqICAgICBQcyA9IDEgIC0+IGJsaW5raW5nIGJsb2NrIChkZWZhdWx0KS5cbiAqICAgICBQcyA9IDIgIC0+IHN0ZWFkeSBibG9jay5cbiAqICAgICBQcyA9IDMgIC0+IGJsaW5raW5nIHVuZGVybGluZS5cbiAqICAgICBQcyA9IDQgIC0+IHN0ZWFkeSB1bmRlcmxpbmUuXG4gKi9UZXJtaW5hbC5wcm90b3R5cGUuc2V0Q3Vyc29yU3R5bGU9ZnVuY3Rpb24ocGFyYW1zKXs7fTsvKipcbiAqIENTSSBQcyBcIiBxXG4gKiAgIFNlbGVjdCBjaGFyYWN0ZXIgcHJvdGVjdGlvbiBhdHRyaWJ1dGUgKERFQ1NDQSkuICBWYWxpZCB2YWx1ZXNcbiAqICAgZm9yIHRoZSBwYXJhbWV0ZXI6XG4gKiAgICAgUHMgPSAwICAtPiBERUNTRUQgYW5kIERFQ1NFTCBjYW4gZXJhc2UgKGRlZmF1bHQpLlxuICogICAgIFBzID0gMSAgLT4gREVDU0VEIGFuZCBERUNTRUwgY2Fubm90IGVyYXNlLlxuICogICAgIFBzID0gMiAgLT4gREVDU0VEIGFuZCBERUNTRUwgY2FuIGVyYXNlLlxuICovVGVybWluYWwucHJvdG90eXBlLnNldENoYXJQcm90ZWN0aW9uQXR0cj1mdW5jdGlvbihwYXJhbXMpezt9Oy8qKlxuICogQ1NJID8gUG0gclxuICogICBSZXN0b3JlIERFQyBQcml2YXRlIE1vZGUgVmFsdWVzLiAgVGhlIHZhbHVlIG9mIFBzIHByZXZpb3VzbHlcbiAqICAgc2F2ZWQgaXMgcmVzdG9yZWQuICBQcyB2YWx1ZXMgYXJlIHRoZSBzYW1lIGFzIGZvciBERUNTRVQuXG4gKi9UZXJtaW5hbC5wcm90b3R5cGUucmVzdG9yZVByaXZhdGVWYWx1ZXM9ZnVuY3Rpb24ocGFyYW1zKXs7fTsvKipcbiAqIENTSSBQdDsgUGw7IFBiOyBQcjsgUHMkIHJcbiAqICAgQ2hhbmdlIEF0dHJpYnV0ZXMgaW4gUmVjdGFuZ3VsYXIgQXJlYSAoREVDQ0FSQSksIFZUNDAwIGFuZCB1cC5cbiAqICAgICBQdDsgUGw7IFBiOyBQciBkZW5vdGVzIHRoZSByZWN0YW5nbGUuXG4gKiAgICAgUHMgZGVub3RlcyB0aGUgU0dSIGF0dHJpYnV0ZXMgdG8gY2hhbmdlOiAwLCAxLCA0LCA1LCA3LlxuICogTk9URTogeHRlcm0gZG9lc24ndCBlbmFibGUgdGhpcyBjb2RlIGJ5IGRlZmF1bHQuXG4gKi9UZXJtaW5hbC5wcm90b3R5cGUuc2V0QXR0ckluUmVjdGFuZ2xlPWZ1bmN0aW9uKHBhcmFtcyl7dmFyIHQ9cGFyYW1zWzBdLGw9cGFyYW1zWzFdLGI9cGFyYW1zWzJdLHI9cGFyYW1zWzNdLGF0dHI9cGFyYW1zWzRdO3ZhciBsaW5lLGk7Zm9yKDt0PGIrMTt0Kyspe2xpbmU9dGhpcy5saW5lc1t0aGlzLnliYXNlK3RdO2ZvcihpPWw7aTxyO2krKyl7bGluZVtpXT1bYXR0cixsaW5lW2ldWzFdXTt9fS8vIHRoaXMubWF4UmFuZ2UoKTtcbnRoaXMudXBkYXRlUmFuZ2UocGFyYW1zWzBdKTt0aGlzLnVwZGF0ZVJhbmdlKHBhcmFtc1syXSk7fTsvKipcbiAqIENTSSBQYzsgUHQ7IFBsOyBQYjsgUHIkIHhcbiAqICAgRmlsbCBSZWN0YW5ndWxhciBBcmVhIChERUNGUkEpLCBWVDQyMCBhbmQgdXAuXG4gKiAgICAgUGMgaXMgdGhlIGNoYXJhY3RlciB0byB1c2UuXG4gKiAgICAgUHQ7IFBsOyBQYjsgUHIgZGVub3RlcyB0aGUgcmVjdGFuZ2xlLlxuICogTk9URTogeHRlcm0gZG9lc24ndCBlbmFibGUgdGhpcyBjb2RlIGJ5IGRlZmF1bHQuXG4gKi9UZXJtaW5hbC5wcm90b3R5cGUuZmlsbFJlY3RhbmdsZT1mdW5jdGlvbihwYXJhbXMpe3ZhciBjaD1wYXJhbXNbMF0sdD1wYXJhbXNbMV0sbD1wYXJhbXNbMl0sYj1wYXJhbXNbM10scj1wYXJhbXNbNF07dmFyIGxpbmUsaTtmb3IoO3Q8YisxO3QrKyl7bGluZT10aGlzLmxpbmVzW3RoaXMueWJhc2UrdF07Zm9yKGk9bDtpPHI7aSsrKXtsaW5lW2ldPVtsaW5lW2ldWzBdLFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpXTt9fS8vIHRoaXMubWF4UmFuZ2UoKTtcbnRoaXMudXBkYXRlUmFuZ2UocGFyYW1zWzFdKTt0aGlzLnVwZGF0ZVJhbmdlKHBhcmFtc1szXSk7fTsvKipcbiAqIENTSSBQcyA7IFB1ICcgelxuICogICBFbmFibGUgTG9jYXRvciBSZXBvcnRpbmcgKERFQ0VMUikuXG4gKiAgIFZhbGlkIHZhbHVlcyBmb3IgdGhlIGZpcnN0IHBhcmFtZXRlcjpcbiAqICAgICBQcyA9IDAgIC0+IExvY2F0b3IgZGlzYWJsZWQgKGRlZmF1bHQpLlxuICogICAgIFBzID0gMSAgLT4gTG9jYXRvciBlbmFibGVkLlxuICogICAgIFBzID0gMiAgLT4gTG9jYXRvciBlbmFibGVkIGZvciBvbmUgcmVwb3J0LCB0aGVuIGRpc2FibGVkLlxuICogICBUaGUgc2Vjb25kIHBhcmFtZXRlciBzcGVjaWZpZXMgdGhlIGNvb3JkaW5hdGUgdW5pdCBmb3IgbG9jYXRvclxuICogICByZXBvcnRzLlxuICogICBWYWxpZCB2YWx1ZXMgZm9yIHRoZSBzZWNvbmQgcGFyYW1ldGVyOlxuICogICAgIFB1ID0gMCAgPC0gb3Igb21pdHRlZCAtPiBkZWZhdWx0IHRvIGNoYXJhY3RlciBjZWxscy5cbiAqICAgICBQdSA9IDEgIDwtIGRldmljZSBwaHlzaWNhbCBwaXhlbHMuXG4gKiAgICAgUHUgPSAyICA8LSBjaGFyYWN0ZXIgY2VsbHMuXG4gKi9UZXJtaW5hbC5wcm90b3R5cGUuZW5hYmxlTG9jYXRvclJlcG9ydGluZz1mdW5jdGlvbihwYXJhbXMpe3ZhciB2YWw9cGFyYW1zWzBdPjA7Ly90aGlzLm1vdXNlRXZlbnRzID0gdmFsO1xuLy90aGlzLmRlY0xvY2F0b3IgPSB2YWw7XG59Oy8qKlxuICogQ1NJIFB0OyBQbDsgUGI7IFByJCB6XG4gKiAgIEVyYXNlIFJlY3Rhbmd1bGFyIEFyZWEgKERFQ0VSQSksIFZUNDAwIGFuZCB1cC5cbiAqICAgICBQdDsgUGw7IFBiOyBQciBkZW5vdGVzIHRoZSByZWN0YW5nbGUuXG4gKiBOT1RFOiB4dGVybSBkb2Vzbid0IGVuYWJsZSB0aGlzIGNvZGUgYnkgZGVmYXVsdC5cbiAqL1Rlcm1pbmFsLnByb3RvdHlwZS5lcmFzZVJlY3RhbmdsZT1mdW5jdGlvbihwYXJhbXMpe3ZhciB0PXBhcmFtc1swXSxsPXBhcmFtc1sxXSxiPXBhcmFtc1syXSxyPXBhcmFtc1szXTt2YXIgbGluZSxpLGNoO2NoPVt0aGlzLmVyYXNlQXR0cigpLCcgJywxXTsvLyB4dGVybT9cbmZvcig7dDxiKzE7dCsrKXtsaW5lPXRoaXMubGluZXNbdGhpcy55YmFzZSt0XTtmb3IoaT1sO2k8cjtpKyspe2xpbmVbaV09Y2g7fX0vLyB0aGlzLm1heFJhbmdlKCk7XG50aGlzLnVwZGF0ZVJhbmdlKHBhcmFtc1swXSk7dGhpcy51cGRhdGVSYW5nZShwYXJhbXNbMl0pO307LyoqXG4gKiBDU0kgUCBtIFNQIH1cbiAqIEluc2VydCBQIHMgQ29sdW1uKHMpIChkZWZhdWx0ID0gMSkgKERFQ0lDKSwgVlQ0MjAgYW5kIHVwLlxuICogTk9URTogeHRlcm0gZG9lc24ndCBlbmFibGUgdGhpcyBjb2RlIGJ5IGRlZmF1bHQuXG4gKi9UZXJtaW5hbC5wcm90b3R5cGUuaW5zZXJ0Q29sdW1ucz1mdW5jdGlvbigpe3ZhciBwYXJhbT1wYXJhbXNbMF0sbD10aGlzLnliYXNlK3RoaXMucm93cyxjaD1bdGhpcy5lcmFzZUF0dHIoKSwnICcsMV0vLyB4dGVybT9cbixpO3doaWxlKHBhcmFtLS0pe2ZvcihpPXRoaXMueWJhc2U7aTxsO2krKyl7dGhpcy5saW5lc1tpXS5zcGxpY2UodGhpcy54KzEsMCxjaCk7dGhpcy5saW5lc1tpXS5wb3AoKTt9fXRoaXMubWF4UmFuZ2UoKTt9Oy8qKlxuICogQ1NJIFAgbSBTUCB+XG4gKiBEZWxldGUgUCBzIENvbHVtbihzKSAoZGVmYXVsdCA9IDEpIChERUNEQyksIFZUNDIwIGFuZCB1cFxuICogTk9URTogeHRlcm0gZG9lc24ndCBlbmFibGUgdGhpcyBjb2RlIGJ5IGRlZmF1bHQuXG4gKi9UZXJtaW5hbC5wcm90b3R5cGUuZGVsZXRlQ29sdW1ucz1mdW5jdGlvbigpe3ZhciBwYXJhbT1wYXJhbXNbMF0sbD10aGlzLnliYXNlK3RoaXMucm93cyxjaD1bdGhpcy5lcmFzZUF0dHIoKSwnICcsMV0vLyB4dGVybT9cbixpO3doaWxlKHBhcmFtLS0pe2ZvcihpPXRoaXMueWJhc2U7aTxsO2krKyl7dGhpcy5saW5lc1tpXS5zcGxpY2UodGhpcy54LDEpO3RoaXMubGluZXNbaV0ucHVzaChjaCk7fX10aGlzLm1heFJhbmdlKCk7fTsvKipcbiAqIENoYXJhY3RlciBTZXRzXG4gKi9UZXJtaW5hbC5jaGFyc2V0cz17fTsvLyBERUMgU3BlY2lhbCBDaGFyYWN0ZXIgYW5kIExpbmUgRHJhd2luZyBTZXQuXG4vLyBodHRwOi8vdnQxMDAubmV0L2RvY3MvdnQxMDItdWcvdGFibGU1LTEzLmh0bWxcbi8vIEEgbG90IG9mIGN1cnNlcyBhcHBzIHVzZSB0aGlzIGlmIHRoZXkgc2VlIFRFUk09eHRlcm0uXG4vLyB0ZXN0aW5nOiBlY2hvIC1lICdcXGUoMGFcXGUoQidcbi8vIFRoZSB4dGVybSBvdXRwdXQgc29tZXRpbWVzIHNlZW1zIHRvIGNvbmZsaWN0IHdpdGggdGhlXG4vLyByZWZlcmVuY2UgYWJvdmUuIHh0ZXJtIHNlZW1zIGluIGxpbmUgd2l0aCB0aGUgcmVmZXJlbmNlXG4vLyB3aGVuIHJ1bm5pbmcgdnR0ZXN0IGhvd2V2ZXIuXG4vLyBUaGUgdGFibGUgYmVsb3cgbm93IHVzZXMgeHRlcm0ncyBvdXRwdXQgZnJvbSB2dHRlc3QuXG5UZXJtaW5hbC5jaGFyc2V0cy5TQ0xEPXsvLyAoMFxuJ2AnOidcXHUyNUM2JywvLyAn4peGJ1xuJ2EnOidcXHUyNTkyJywvLyAn4paSJ1xuJ2InOidcXHQnLC8vICdcXHQnXG4nYyc6J1xcZicsLy8gJ1xcZidcbidkJzonXFxyJywvLyAnXFxyJ1xuJ2UnOidcXG4nLC8vICdcXG4nXG4nZic6J1xceEIwJywvLyAnwrAnXG4nZyc6J1xceEIxJywvLyAnwrEnXG4naCc6J1xcdTI0MjQnLC8vICdcXHUyNDI0JyAoTkwpXG4naSc6J1xceDBCJywvLyAnXFx2J1xuJ2onOidcXHUyNTE4JywvLyAn4pSYJ1xuJ2snOidcXHUyNTEwJywvLyAn4pSQJ1xuJ2wnOidcXHUyNTBDJywvLyAn4pSMJ1xuJ20nOidcXHUyNTE0JywvLyAn4pSUJ1xuJ24nOidcXHUyNTNDJywvLyAn4pS8J1xuJ28nOidcXHUyM0JBJywvLyAn4o66J1xuJ3AnOidcXHUyM0JCJywvLyAn4o67J1xuJ3EnOidcXHUyNTAwJywvLyAn4pSAJ1xuJ3InOidcXHUyM0JDJywvLyAn4o68J1xuJ3MnOidcXHUyM0JEJywvLyAn4o69J1xuJ3QnOidcXHUyNTFDJywvLyAn4pScJ1xuJ3UnOidcXHUyNTI0JywvLyAn4pSkJ1xuJ3YnOidcXHUyNTM0JywvLyAn4pS0J1xuJ3cnOidcXHUyNTJDJywvLyAn4pSsJ1xuJ3gnOidcXHUyNTAyJywvLyAn4pSCJ1xuJ3knOidcXHUyMjY0JywvLyAn4omkJ1xuJ3onOidcXHUyMjY1JywvLyAn4omlJ1xuJ3snOidcXHUwM0MwJywvLyAnz4AnXG4nfCc6J1xcdTIyNjAnLC8vICfiiaAnXG4nfSc6J1xceEEzJywvLyAnwqMnXG4nfic6J1xceEI3Jy8vICfCtydcbn07VGVybWluYWwuY2hhcnNldHMuVUs9bnVsbDsvLyAoQVxuVGVybWluYWwuY2hhcnNldHMuVVM9bnVsbDsvLyAoQiAoVVNBU0NJSSlcblRlcm1pbmFsLmNoYXJzZXRzLkR1dGNoPW51bGw7Ly8gKDRcblRlcm1pbmFsLmNoYXJzZXRzLkZpbm5pc2g9bnVsbDsvLyAoQyBvciAoNVxuVGVybWluYWwuY2hhcnNldHMuRnJlbmNoPW51bGw7Ly8gKFJcblRlcm1pbmFsLmNoYXJzZXRzLkZyZW5jaENhbmFkaWFuPW51bGw7Ly8gKFFcblRlcm1pbmFsLmNoYXJzZXRzLkdlcm1hbj1udWxsOy8vIChLXG5UZXJtaW5hbC5jaGFyc2V0cy5JdGFsaWFuPW51bGw7Ly8gKFlcblRlcm1pbmFsLmNoYXJzZXRzLk5vcndlZ2lhbkRhbmlzaD1udWxsOy8vIChFIG9yICg2XG5UZXJtaW5hbC5jaGFyc2V0cy5TcGFuaXNoPW51bGw7Ly8gKFpcblRlcm1pbmFsLmNoYXJzZXRzLlN3ZWRpc2g9bnVsbDsvLyAoSCBvciAoN1xuVGVybWluYWwuY2hhcnNldHMuU3dpc3M9bnVsbDsvLyAoPVxuVGVybWluYWwuY2hhcnNldHMuSVNPTGF0aW49bnVsbDsvLyAvQVxuLyoqXG4gKiBIZWxwZXJzXG4gKi9mdW5jdGlvbiBjb250YWlucyhlbCxhcnIpe2Zvcih2YXIgaT0wO2k8YXJyLmxlbmd0aDtpKz0xKXtpZihlbD09PWFycltpXSl7cmV0dXJuIHRydWU7fX1yZXR1cm4gZmFsc2U7fWZ1bmN0aW9uIG9uKGVsLHR5cGUsaGFuZGxlcixjYXB0dXJlKXtpZighQXJyYXkuaXNBcnJheShlbCkpe2VsPVtlbF07fWVsLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCl7ZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHR5cGUsaGFuZGxlcixjYXB0dXJlfHxmYWxzZSk7fSk7fWZ1bmN0aW9uIG9mZihlbCx0eXBlLGhhbmRsZXIsY2FwdHVyZSl7ZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLGhhbmRsZXIsY2FwdHVyZXx8ZmFsc2UpO31mdW5jdGlvbiBjYW5jZWwoZXYsZm9yY2Upe2lmKCF0aGlzLmNhbmNlbEV2ZW50cyYmIWZvcmNlKXtyZXR1cm47fWV2LnByZXZlbnREZWZhdWx0KCk7ZXYuc3RvcFByb3BhZ2F0aW9uKCk7cmV0dXJuIGZhbHNlO31mdW5jdGlvbiBpbmhlcml0cyhjaGlsZCxwYXJlbnQpe2Z1bmN0aW9uIGYoKXt0aGlzLmNvbnN0cnVjdG9yPWNoaWxkO31mLnByb3RvdHlwZT1wYXJlbnQucHJvdG90eXBlO2NoaWxkLnByb3RvdHlwZT1uZXcgZigpO30vLyBpZiBib2xkIGlzIGJyb2tlbiwgd2UgY2FuJ3Rcbi8vIHVzZSBpdCBpbiB0aGUgdGVybWluYWwuXG5mdW5jdGlvbiBpc0JvbGRCcm9rZW4oZG9jdW1lbnQpe3ZhciBib2R5PWRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdib2R5JylbMF07dmFyIGVsPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtlbC5pbm5lckhUTUw9J2hlbGxvIHdvcmxkJztib2R5LmFwcGVuZENoaWxkKGVsKTt2YXIgdzE9ZWwuc2Nyb2xsV2lkdGg7ZWwuc3R5bGUuZm9udFdlaWdodD0nYm9sZCc7dmFyIHcyPWVsLnNjcm9sbFdpZHRoO2JvZHkucmVtb3ZlQ2hpbGQoZWwpO3JldHVybiB3MSE9PXcyO31mdW5jdGlvbiBpbmRleE9mKG9iaixlbCl7dmFyIGk9b2JqLmxlbmd0aDt3aGlsZShpLS0pe2lmKG9ialtpXT09PWVsKXJldHVybiBpO31yZXR1cm4tMTt9ZnVuY3Rpb24gaXNUaGlyZExldmVsU2hpZnQodGVybSxldil7dmFyIHRoaXJkTGV2ZWxLZXk9dGVybS5pc01hYyYmZXYuYWx0S2V5JiYhZXYuY3RybEtleSYmIWV2Lm1ldGFLZXl8fHRlcm0uaXNNU1dpbmRvd3MmJmV2LmFsdEtleSYmZXYuY3RybEtleSYmIWV2Lm1ldGFLZXk7aWYoZXYudHlwZT09J2tleXByZXNzJyl7cmV0dXJuIHRoaXJkTGV2ZWxLZXk7fS8vIERvbid0IGludm9rZSBmb3IgYXJyb3dzLCBwYWdlRG93biwgaG9tZSwgYmFja3NwYWNlLCBldGMuIChvbiBub24ta2V5cHJlc3MgZXZlbnRzKVxucmV0dXJuIHRoaXJkTGV2ZWxLZXkmJighZXYua2V5Q29kZXx8ZXYua2V5Q29kZT40Nyk7fWZ1bmN0aW9uIG1hdGNoQ29sb3IocjEsZzEsYjEpe3ZhciBoYXNoPXIxPDwxNnxnMTw8OHxiMTtpZihtYXRjaENvbG9yLl9jYWNoZVtoYXNoXSE9bnVsbCl7cmV0dXJuIG1hdGNoQ29sb3IuX2NhY2hlW2hhc2hdO312YXIgbGRpZmY9SW5maW5pdHksbGk9LTEsaT0wLGMscjIsZzIsYjIsZGlmZjtmb3IoO2k8VGVybWluYWwudmNvbG9ycy5sZW5ndGg7aSsrKXtjPVRlcm1pbmFsLnZjb2xvcnNbaV07cjI9Y1swXTtnMj1jWzFdO2IyPWNbMl07ZGlmZj1tYXRjaENvbG9yLmRpc3RhbmNlKHIxLGcxLGIxLHIyLGcyLGIyKTtpZihkaWZmPT09MCl7bGk9aTticmVhazt9aWYoZGlmZjxsZGlmZil7bGRpZmY9ZGlmZjtsaT1pO319cmV0dXJuIG1hdGNoQ29sb3IuX2NhY2hlW2hhc2hdPWxpO31tYXRjaENvbG9yLl9jYWNoZT17fTsvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE2MzM4Mjhcbm1hdGNoQ29sb3IuZGlzdGFuY2U9ZnVuY3Rpb24ocjEsZzEsYjEscjIsZzIsYjIpe3JldHVybiBNYXRoLnBvdygzMCoocjEtcjIpLDIpK01hdGgucG93KDU5KihnMS1nMiksMikrTWF0aC5wb3coMTEqKGIxLWIyKSwyKTt9O2Z1bmN0aW9uIGVhY2gob2JqLGl0ZXIsY29uKXtpZihvYmouZm9yRWFjaClyZXR1cm4gb2JqLmZvckVhY2goaXRlcixjb24pO2Zvcih2YXIgaT0wO2k8b2JqLmxlbmd0aDtpKyspe2l0ZXIuY2FsbChjb24sb2JqW2ldLGksb2JqKTt9fWZ1bmN0aW9uIGtleXMob2JqKXtpZihPYmplY3Qua2V5cylyZXR1cm4gT2JqZWN0LmtleXMob2JqKTt2YXIga2V5LGtleXM9W107Zm9yKGtleSBpbiBvYmope2lmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosa2V5KSl7a2V5cy5wdXNoKGtleSk7fX1yZXR1cm4ga2V5czt9dmFyIHdjd2lkdGg9ZnVuY3Rpb24ob3B0cyl7Ly8gZXh0cmFjdGVkIGZyb20gaHR0cHM6Ly93d3cuY2wuY2FtLmFjLnVrLyU3RW1nazI1L3Vjcy93Y3dpZHRoLmNcbi8vIGNvbWJpbmluZyBjaGFyYWN0ZXJzXG52YXIgQ09NQklOSU5HPVtbMHgwMzAwLDB4MDM2Rl0sWzB4MDQ4MywweDA0ODZdLFsweDA0ODgsMHgwNDg5XSxbMHgwNTkxLDB4MDVCRF0sWzB4MDVCRiwweDA1QkZdLFsweDA1QzEsMHgwNUMyXSxbMHgwNUM0LDB4MDVDNV0sWzB4MDVDNywweDA1QzddLFsweDA2MDAsMHgwNjAzXSxbMHgwNjEwLDB4MDYxNV0sWzB4MDY0QiwweDA2NUVdLFsweDA2NzAsMHgwNjcwXSxbMHgwNkQ2LDB4MDZFNF0sWzB4MDZFNywweDA2RThdLFsweDA2RUEsMHgwNkVEXSxbMHgwNzBGLDB4MDcwRl0sWzB4MDcxMSwweDA3MTFdLFsweDA3MzAsMHgwNzRBXSxbMHgwN0E2LDB4MDdCMF0sWzB4MDdFQiwweDA3RjNdLFsweDA5MDEsMHgwOTAyXSxbMHgwOTNDLDB4MDkzQ10sWzB4MDk0MSwweDA5NDhdLFsweDA5NEQsMHgwOTREXSxbMHgwOTUxLDB4MDk1NF0sWzB4MDk2MiwweDA5NjNdLFsweDA5ODEsMHgwOTgxXSxbMHgwOUJDLDB4MDlCQ10sWzB4MDlDMSwweDA5QzRdLFsweDA5Q0QsMHgwOUNEXSxbMHgwOUUyLDB4MDlFM10sWzB4MEEwMSwweDBBMDJdLFsweDBBM0MsMHgwQTNDXSxbMHgwQTQxLDB4MEE0Ml0sWzB4MEE0NywweDBBNDhdLFsweDBBNEIsMHgwQTREXSxbMHgwQTcwLDB4MEE3MV0sWzB4MEE4MSwweDBBODJdLFsweDBBQkMsMHgwQUJDXSxbMHgwQUMxLDB4MEFDNV0sWzB4MEFDNywweDBBQzhdLFsweDBBQ0QsMHgwQUNEXSxbMHgwQUUyLDB4MEFFM10sWzB4MEIwMSwweDBCMDFdLFsweDBCM0MsMHgwQjNDXSxbMHgwQjNGLDB4MEIzRl0sWzB4MEI0MSwweDBCNDNdLFsweDBCNEQsMHgwQjREXSxbMHgwQjU2LDB4MEI1Nl0sWzB4MEI4MiwweDBCODJdLFsweDBCQzAsMHgwQkMwXSxbMHgwQkNELDB4MEJDRF0sWzB4MEMzRSwweDBDNDBdLFsweDBDNDYsMHgwQzQ4XSxbMHgwQzRBLDB4MEM0RF0sWzB4MEM1NSwweDBDNTZdLFsweDBDQkMsMHgwQ0JDXSxbMHgwQ0JGLDB4MENCRl0sWzB4MENDNiwweDBDQzZdLFsweDBDQ0MsMHgwQ0NEXSxbMHgwQ0UyLDB4MENFM10sWzB4MEQ0MSwweDBENDNdLFsweDBENEQsMHgwRDREXSxbMHgwRENBLDB4MERDQV0sWzB4MEREMiwweDBERDRdLFsweDBERDYsMHgwREQ2XSxbMHgwRTMxLDB4MEUzMV0sWzB4MEUzNCwweDBFM0FdLFsweDBFNDcsMHgwRTRFXSxbMHgwRUIxLDB4MEVCMV0sWzB4MEVCNCwweDBFQjldLFsweDBFQkIsMHgwRUJDXSxbMHgwRUM4LDB4MEVDRF0sWzB4MEYxOCwweDBGMTldLFsweDBGMzUsMHgwRjM1XSxbMHgwRjM3LDB4MEYzN10sWzB4MEYzOSwweDBGMzldLFsweDBGNzEsMHgwRjdFXSxbMHgwRjgwLDB4MEY4NF0sWzB4MEY4NiwweDBGODddLFsweDBGOTAsMHgwRjk3XSxbMHgwRjk5LDB4MEZCQ10sWzB4MEZDNiwweDBGQzZdLFsweDEwMkQsMHgxMDMwXSxbMHgxMDMyLDB4MTAzMl0sWzB4MTAzNiwweDEwMzddLFsweDEwMzksMHgxMDM5XSxbMHgxMDU4LDB4MTA1OV0sWzB4MTE2MCwweDExRkZdLFsweDEzNUYsMHgxMzVGXSxbMHgxNzEyLDB4MTcxNF0sWzB4MTczMiwweDE3MzRdLFsweDE3NTIsMHgxNzUzXSxbMHgxNzcyLDB4MTc3M10sWzB4MTdCNCwweDE3QjVdLFsweDE3QjcsMHgxN0JEXSxbMHgxN0M2LDB4MTdDNl0sWzB4MTdDOSwweDE3RDNdLFsweDE3REQsMHgxN0REXSxbMHgxODBCLDB4MTgwRF0sWzB4MThBOSwweDE4QTldLFsweDE5MjAsMHgxOTIyXSxbMHgxOTI3LDB4MTkyOF0sWzB4MTkzMiwweDE5MzJdLFsweDE5MzksMHgxOTNCXSxbMHgxQTE3LDB4MUExOF0sWzB4MUIwMCwweDFCMDNdLFsweDFCMzQsMHgxQjM0XSxbMHgxQjM2LDB4MUIzQV0sWzB4MUIzQywweDFCM0NdLFsweDFCNDIsMHgxQjQyXSxbMHgxQjZCLDB4MUI3M10sWzB4MURDMCwweDFEQ0FdLFsweDFERkUsMHgxREZGXSxbMHgyMDBCLDB4MjAwRl0sWzB4MjAyQSwweDIwMkVdLFsweDIwNjAsMHgyMDYzXSxbMHgyMDZBLDB4MjA2Rl0sWzB4MjBEMCwweDIwRUZdLFsweDMwMkEsMHgzMDJGXSxbMHgzMDk5LDB4MzA5QV0sWzB4QTgwNiwweEE4MDZdLFsweEE4MEIsMHhBODBCXSxbMHhBODI1LDB4QTgyNl0sWzB4RkIxRSwweEZCMUVdLFsweEZFMDAsMHhGRTBGXSxbMHhGRTIwLDB4RkUyM10sWzB4RkVGRiwweEZFRkZdLFsweEZGRjksMHhGRkZCXSxbMHgxMEEwMSwweDEwQTAzXSxbMHgxMEEwNSwweDEwQTA2XSxbMHgxMEEwQywweDEwQTBGXSxbMHgxMEEzOCwweDEwQTNBXSxbMHgxMEEzRiwweDEwQTNGXSxbMHgxRDE2NywweDFEMTY5XSxbMHgxRDE3MywweDFEMTgyXSxbMHgxRDE4NSwweDFEMThCXSxbMHgxRDFBQSwweDFEMUFEXSxbMHgxRDI0MiwweDFEMjQ0XSxbMHhFMDAwMSwweEUwMDAxXSxbMHhFMDAyMCwweEUwMDdGXSxbMHhFMDEwMCwweEUwMUVGXV07Ly8gYmluYXJ5IHNlYXJjaFxuZnVuY3Rpb24gYmlzZWFyY2godWNzKXt2YXIgbWluPTA7dmFyIG1heD1DT01CSU5JTkcubGVuZ3RoLTE7dmFyIG1pZDtpZih1Y3M8Q09NQklOSU5HWzBdWzBdfHx1Y3M+Q09NQklOSU5HW21heF1bMV0pcmV0dXJuIGZhbHNlO3doaWxlKG1heD49bWluKXttaWQ9TWF0aC5mbG9vcigobWluK21heCkvMik7aWYodWNzPkNPTUJJTklOR1ttaWRdWzFdKW1pbj1taWQrMTtlbHNlIGlmKHVjczxDT01CSU5JTkdbbWlkXVswXSltYXg9bWlkLTE7ZWxzZSByZXR1cm4gdHJ1ZTt9cmV0dXJuIGZhbHNlO31mdW5jdGlvbiB3Y3dpZHRoKHVjcyl7Ly8gdGVzdCBmb3IgOC1iaXQgY29udHJvbCBjaGFyYWN0ZXJzXG5pZih1Y3M9PT0wKXJldHVybiBvcHRzLm51bDtpZih1Y3M8MzJ8fHVjcz49MHg3ZiYmdWNzPDB4YTApcmV0dXJuIG9wdHMuY29udHJvbDsvLyBiaW5hcnkgc2VhcmNoIGluIHRhYmxlIG9mIG5vbi1zcGFjaW5nIGNoYXJhY3RlcnNcbmlmKGJpc2VhcmNoKHVjcykpcmV0dXJuIDA7Ly8gaWYgd2UgYXJyaXZlIGhlcmUsIHVjcyBpcyBub3QgYSBjb21iaW5pbmcgb3IgQzAvQzEgY29udHJvbCBjaGFyYWN0ZXJcbnJldHVybiAxKyh1Y3M+PTB4MTEwMCYmKHVjczw9MHgxMTVmfHwvLyBIYW5ndWwgSmFtbyBpbml0LiBjb25zb25hbnRzXG51Y3M9PTB4MjMyOXx8dWNzPT0weDIzMmF8fHVjcz49MHgyZTgwJiZ1Y3M8PTB4YTRjZiYmdWNzIT0weDMwM2Z8fC8vIENKSy4uWWlcbnVjcz49MHhhYzAwJiZ1Y3M8PTB4ZDdhM3x8Ly8gSGFuZ3VsIFN5bGxhYmxlc1xudWNzPj0weGY5MDAmJnVjczw9MHhmYWZmfHwvLyBDSksgQ29tcGF0IElkZW9ncmFwaHNcbnVjcz49MHhmZTEwJiZ1Y3M8PTB4ZmUxOXx8Ly8gVmVydGljYWwgZm9ybXNcbnVjcz49MHhmZTMwJiZ1Y3M8PTB4ZmU2Znx8Ly8gQ0pLIENvbXBhdCBGb3Jtc1xudWNzPj0weGZmMDAmJnVjczw9MHhmZjYwfHwvLyBGdWxsd2lkdGggRm9ybXNcbnVjcz49MHhmZmUwJiZ1Y3M8PTB4ZmZlNnx8dWNzPj0weDIwMDAwJiZ1Y3M8PTB4MmZmZmR8fHVjcz49MHgzMDAwMCYmdWNzPD0weDNmZmZkKSk7fXJldHVybiB3Y3dpZHRoO30oe251bDowLGNvbnRyb2w6MH0pOy8vIGNvbmZpZ3VyYWJsZSBvcHRpb25zXG4vKipcbiAqIEV4cG9zZVxuICovVGVybWluYWwuRXZlbnRFbWl0dGVyPV9FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyO1Rlcm1pbmFsLkNvbXBvc2l0aW9uSGVscGVyPV9Db21wb3NpdGlvbkhlbHBlci5Db21wb3NpdGlvbkhlbHBlcjtUZXJtaW5hbC5WaWV3cG9ydD1fVmlld3BvcnQuVmlld3BvcnQ7VGVybWluYWwuaW5oZXJpdHM9aW5oZXJpdHM7LyoqXG4gKiBBZGRzIGFuIGV2ZW50IGxpc3RlbmVyIHRvIHRoZSB0ZXJtaW5hbC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQgVGhlIG5hbWUgb2YgdGhlIGV2ZW50LiBUT0RPOiBEb2N1bWVudCBhbGwgZXZlbnQgdHlwZXNcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIGV2ZW50IGlzIHRyaWdnZXJlZC5cbiAqL1Rlcm1pbmFsLm9uPW9uO1Rlcm1pbmFsLm9mZj1vZmY7VGVybWluYWwuY2FuY2VsPWNhbmNlbDttb2R1bGUuZXhwb3J0cz1UZXJtaW5hbDtcblxufSkuY2FsbCh0aGlzLFwiL3NyY1wiKVxuXG59LHtcIi4vQ29tcG9zaXRpb25IZWxwZXIuanNcIjoxLFwiLi9FdmVudEVtaXR0ZXIuanNcIjoyLFwiLi9WaWV3cG9ydC5qc1wiOjMsXCIuL2hhbmRsZXJzL0NsaXBib2FyZC5qc1wiOjR9XX0se30sWzVdKSg1KVxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD14dGVybS5qcy5tYXBcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3h0ZXJtL2Rpc3QveHRlcm0uanNcbiAqKiBtb2R1bGUgaWQgPSAxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9